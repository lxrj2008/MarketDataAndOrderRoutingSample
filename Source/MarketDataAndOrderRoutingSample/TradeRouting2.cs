// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/trade_routing_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace TradeRouting2 {

  /// <summary>Holder for reflection information generated from WebAPI/trade_routing_2.proto</summary>
  public static partial class TradeRouting2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/trade_routing_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TradeRouting2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChxXZWJBUEkvdHJhZGVfcm91dGluZ18yLnByb3RvEg90cmFkZV9yb3V0aW5n",
            "XzIaF1dlYkFQSS9tZXRhZGF0YV8yLnByb3RvGhRXZWJBUEkvb3JkZXJfMi5w",
            "cm90bxoUY29tbW9uL2RlY2ltYWwucHJvdG8aFWNvbW1vbi9zaGFyZWRfMS5w",
            "cm90bxofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byKgBwoRVHJh",
            "ZGVTdWJzY3JpcHRpb24SCgoCaWQYASACKA0SGwoTc3Vic2NyaXB0aW9uX3Nj",
            "b3BlcxgCIAMoDRIYChBwdWJsaWNhdGlvbl90eXBlGAMgASgNEhIKCmFjY291",
            "bnRfaWQYBCABKA0SGwoTc2FsZXNfc2VyaWVzX251bWJlchgFIAEoCRIUCgxi",
            "cm9rZXJhZ2VfaWQYBiABKA0SEQoJc3Vic2NyaWJlGAcgAigIEiYKGmxhc3Rf",
            "b3JkZXJfdXBkYXRlX3V0Y190aW1lGAggASgSQgIYARJDCh9sYXN0X29yZGVy",
            "X3VwZGF0ZV91dGNfdGltZXN0YW1wGA4gASgLMhouZ29vZ2xlLnByb3RvYnVm",
            "LlRpbWVzdGFtcBIcChRza2lwX29yZGVyc19zbmFwc2hvdBgJIAEoCBIgChhj",
            "b25maXJtZWRfcG9zaXRpb25zX29ubHkYCiABKAgSGgoSbWF0Y2hpbmdfYWxn",
            "b3JpdGhtGAsgASgNEhwKFG1hdGNoX2ludHJhZGF5X2ZpcnN0GAwgASgIEiUK",
            "HWhpc3RvcmljYWxfbWF0Y2hpbmdfYWxnb3JpdGhtGA0gASgNEhwKFGluY2x1",
            "ZGVfY3Jvc3Nfb3JkZXJzGA8gASgIEkMKFW9yZGVyX3NuYXBzaG90X2ZpbHRl",
            "chgQIAEoCzIkLnRyYWRlX3JvdXRpbmdfMi5PcmRlclNuYXBzaG90RmlsdGVy",
            "IncKEVN1YnNjcmlwdGlvblNjb3BlEh0KGVNVQlNDUklQVElPTl9TQ09QRV9P",
            "UkRFUlMQARIgChxTVUJTQ1JJUFRJT05fU0NPUEVfUE9TSVRJT05TEAISIQod",
            "U1VCU0NSSVBUSU9OX1NDT1BFX0NPTExBVEVSQUwQAyKXAQoPUHVibGljYXRp",
            "b25UeXBlEhwKGFBVQkxJQ0FUSU9OX1RZUEVfQUNDT1VOVBABEiEKHVBVQkxJ",
            "Q0FUSU9OX1RZUEVfU0FMRVNfU0VSSUVTEAISHgoaUFVCTElDQVRJT05fVFlQ",
            "RV9CUk9LRVJBR0UQAxIjCh9QVUJMSUNBVElPTl9UWVBFX0FMTF9BVVRIT1JJ",
            "WkVEEAQiagoRTWF0Y2hpbmdBbGdvcml0aG0SGwoXTUFUQ0hJTkdfQUxHT1JJ",
            "VEhNX0ZJRk8QARIbChdNQVRDSElOR19BTEdPUklUSE1fSEJIUxACEhsKF01B",
            "VENISU5HX0FMR09SSVRITV9MSUZPEAMi3wIKF1RyYWRlU3Vic2NyaXB0aW9u",
            "U3RhdHVzEgoKAmlkGAEgAigNEhMKC3N0YXR1c19jb2RlGAIgAigNEhgKDHRl",
            "eHRfbWVzc2FnZRgDIAEoCUICGAESHwoHZGV0YWlscxgEIAEoCzIOLnNoYXJl",
            "ZF8xLlRleHQi5wEKClN0YXR1c0NvZGUSFwoTU1RBVFVTX0NPREVfU1VDQ0VT",
            "UxAAEhwKGFNUQVRVU19DT0RFX0RJU0NPTk5FQ1RFRBABEhcKE1NUQVRVU19D",
            "T0RFX0ZBSUxVUkUQZRIsCihTVEFUVVNfQ09ERV9TVUJTQ1JJUFRJT05fTElN",
            "SVRfVklPTEFUSU9OEGYSJgoiU1RBVFVTX0NPREVfSU5WQUxJRF9QVUJMSUNB",
            "VElPTl9JRBBnEjMKL1NUQVRVU19DT0RFX1NVQlNDUklCRURfQUNDT1VOVFNf",
            "TElNSVRfVklPTEFUSU9OEGgiTwoXVHJhZGVTbmFwc2hvdENvbXBsZXRpb24S",
            "FwoPc3Vic2NyaXB0aW9uX2lkGAEgAigNEhsKE3N1YnNjcmlwdGlvbl9zY29w",
            "ZXMYAiADKA0ijwEKE09yZGVyU25hcHNob3RGaWx0ZXISFgoOb3JkZXJfc3Rh",
            "dHVzZXMYASADKA0SSwoZdHJhbnNhY3Rpb25fc3RhdHVzX2ZpbHRlchgCIAEo",
            "CzIoLnRyYWRlX3JvdXRpbmdfMi5UcmFuc2FjdGlvblN0YXR1c0ZpbHRlchIT",
            "CgtvcmRlcl90eXBlcxgDIAMoDSJSChdUcmFuc2FjdGlvblN0YXR1c0ZpbHRl",
            "chIZChFza2lwX3RyYW5zYWN0aW9ucxgBIAEoCBIcChR0cmFuc2FjdGlvbl9z",
            "dGF0dXNlcxgCIAMoDSL8AgoOUG9zaXRpb25TdGF0dXMSGAoQc3Vic2NyaXB0",
            "aW9uX2lkcxgBIAMoDRITCgtpc19zbmFwc2hvdBgCIAEoCBISCgphY2NvdW50",
            "X2lkGAMgAigREhMKC2NvbnRyYWN0X2lkGAQgAigNEiIKFmlzX3Nob3J0X29w",
            "ZW5fcG9zaXRpb24YBSACKAhCAhgBEjUKDm9wZW5fcG9zaXRpb25zGAYgAygL",
            "Mh0udHJhZGVfcm91dGluZ18yLk9wZW5Qb3NpdGlvbhJJChlwdXJjaGFzZV9h",
            "bmRfc2FsZXNfZ3JvdXBzGAcgAygLMiYudHJhZGVfcm91dGluZ18yLlB1cmNo",
            "YXNlQW5kU2FsZXNHcm91cBI3ChFjb250cmFjdF9tZXRhZGF0YRgIIAEoCzIc",
            "Lm1ldGFkYXRhXzIuQ29udHJhY3RNZXRhZGF0YRIzChZ0b2RheV9maWxsX2Nv",
            "bW1pc3Npb25zGAkgAygLMhMub3JkZXJfMi5Db21taXNzaW9uIsUCCgxPcGVu",
            "UG9zaXRpb24SCgoCaWQYASACKBESFgoKdWludDMyX3F0eRgCIAEoDUICGAES",
            "GQoDcXR5GAwgASgLMgwuY3FnLkRlY2ltYWwSFQoNcHJpY2VfY29ycmVjdBgD",
            "IAIoARISCgp0cmFkZV9kYXRlGAQgAigSEhYKDnN0YXRlbWVudF9kYXRlGAUg",
            "AigSEhoKDnRyYWRlX3V0Y190aW1lGAYgASgSQgIYARI3ChN0cmFkZV91dGNf",
            "dGltZXN0YW1wGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIV",
            "Cg1pc19hZ2dyZWdhdGVkGAcgAigIEhAKCGlzX3Nob3J0GAkgAigIEhsKDGlz",
            "X3llc3RlcmRheRgKIAEoCDoFZmFsc2USGAoQc3BlY3VsYXRpb25fdHlwZRgL",
            "IAEoDSJ4ChVQdXJjaGFzZUFuZFNhbGVzR3JvdXASCgoCaWQYASACKBESHAoU",
            "cmVhbGl6ZWRfcHJvZml0X2xvc3MYAiACKAESNQoObWF0Y2hlZF90cmFkZXMY",
            "AyADKAsyHS50cmFkZV9yb3V0aW5nXzIuTWF0Y2hlZFRyYWRlIsMCCgxNYXRj",
            "aGVkVHJhZGUSFgoKdWludDMyX3F0eRgBIAEoDUICGAESGQoDcXR5GAwgASgL",
            "MgwuY3FnLkRlY2ltYWwSEAoIaXNfc2hvcnQYAiABKAgSDQoFcHJpY2UYAyAC",
            "KAESEgoKdHJhZGVfZGF0ZRgEIAIoEhIWCg5zdGF0ZW1lbnRfZGF0ZRgFIAIo",
            "EhIaCg50cmFkZV91dGNfdGltZRgGIAEoEkICGAESNwoTdHJhZGVfdXRjX3Rp",
            "bWVzdGFtcBgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFQoN",
            "aXNfYWdncmVnYXRlZBgHIAIoCBIbCgxpc195ZXN0ZXJkYXkYCSABKAg6BWZh",
            "bHNlEhAKCGlzX2Nsb3NlGAogASgIEhgKEHNwZWN1bGF0aW9uX3R5cGUYCyAB",
            "KA0iqAIKEENvbGxhdGVyYWxTdGF0dXMSGAoQc3Vic2NyaXB0aW9uX2lkcxgB",
            "IAMoDRITCgtpc19zbmFwc2hvdBgCIAEoCBISCgphY2NvdW50X2lkGAMgAigR",
            "EhAKCGN1cnJlbmN5GAQgAigJEhQKDHRvdGFsX21hcmdpbhgFIAIoARIXCg9w",
            "b3NpdGlvbl9tYXJnaW4YCyABKAESGAoQcHVyY2hhc2luZ19wb3dlchgGIAIo",
            "ARILCgNvdGUYByABKAESCwoDbXZvGAggASgBEgsKA212ZhgKIAEoARIVCg1t",
            "YXJnaW5fY3JlZGl0GAkgASgBEjgKFHN0YXR1c191dGNfdGltZXN0YW1wGAwg",
            "ASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCL7AQoXSGlzdG9yaWNh",
            "bE9yZGVyc1JlcXVlc3QSEQoJZnJvbV9kYXRlGAEgAigSEg8KB3RvX2RhdGUY",
            "AiABKBISEwoLYWNjb3VudF9pZHMYAyADKBESHAoUaW5jbHVkZV9jcm9zc19v",
            "cmRlcnMYBCABKAgSQwoVb3JkZXJfc25hcHNob3RfZmlsdGVyGAUgASgLMiQu",
            "dHJhZGVfcm91dGluZ18yLk9yZGVyU25hcHNob3RGaWx0ZXISHgoWbWF4X29y",
            "ZGVyX3N0YXR1c19jb3VudBgGIAEoDRIkChxtYXhfdHJhbnNhY3Rpb25fc3Rh",
            "dHVzX2NvdW50GAcgASgNIpQBChZIaXN0b3JpY2FsT3JkZXJzUmVwb3J0EiwK",
            "Dm9yZGVyX3N0YXR1c2VzGAEgAygLMhQub3JkZXJfMi5PcmRlclN0YXR1cxIi",
            "ChpvcmRlcl9zdGF0dXNfbGltaXRfcmVhY2hlZBgCIAEoCBIoCiB0cmFuc2Fj",
            "dGlvbl9zdGF0dXNfbGltaXRfcmVhY2hlZBgDIAEoCCJACilCcm9rZXJhZ2VU",
            "cmFkaW5nRmVhdHVyZUVudGl0bGVtZW50UmVxdWVzdBITCgthY2NvdW50X2lk",
            "cxgBIAMoESKBAQooQnJva2VyYWdlVHJhZGluZ0ZlYXR1cmVFbnRpdGxlbWVu",
            "dFJlcG9ydBJVChx0cmFkaW5nX2ZlYXR1cmVfZW50aXRsZW1lbnRzGAEgAygL",
            "Mi8udHJhZGVfcm91dGluZ18yLlRyYWRpbmdGZWF0dXJlRW50aXRsZW1lbnRF",
            "bnRyeSJJCh5UcmFkaW5nRmVhdHVyZUVudGl0bGVtZW50RW50cnkSEgoKYWNj",
            "b3VudF9pZBgBIAEoERITCgtlbnRpdGxlbWVudBgCIAEoDSruBAoZVHJhZGlu",
            "Z0ZlYXR1cmVFbnRpdGxlbWVudBJKCkZUUkFESU5HX0ZFQVRVUkVfRU5USVRM",
            "RU1FTlRfRElTQUxMT1dfU0tJUF9OT05fRkFTVF9DTElDS19DT05GSVJNQVRJ",
            "T05TEAMSTgpKVFJBRElOR19GRUFUVVJFX0VOVElUTEVNRU5UX0RJU0FMTE9X",
            "X1NLSVBfTk9OX0REVF9GQVNUX0NMSUNLX0NPTkZJUk1BVElPTlMQBBIxCi1U",
            "UkFESU5HX0ZFQVRVUkVfRU5USVRMRU1FTlRfRElTQUxMT1dfSEVBRFNfVVAQ",
            "BRIzCi9UUkFESU5HX0ZFQVRVUkVfRU5USVRMRU1FTlRfRElTQUxMT1dfT1JE",
            "RVJfVklFVxAGEj4KOlRSQURJTkdfRkVBVFVSRV9FTlRJVExFTUVOVF9ESVNB",
            "TExPV19SRVNQT05TSVZFX0RPTV9UUkFERVIQCBI7CjdUUkFESU5HX0ZFQVRV",
            "UkVfRU5USVRMRU1FTlRfRElTQUxMT1dfRFlOQU1JQ19ET01fVFJBREVSEAkS",
            "PAo4VFJBRElOR19GRUFUVVJFX0VOVElUTEVNRU5UX0RJU0FMTE9XX0JVWV9T",
            "RUxMX0ZBU1RfQ0xJQ0sQCxJKCkZUUkFESU5HX0ZFQVRVUkVfRU5USVRMRU1F",
            "TlRfRElTQUxMT1dfU0tJUF9ERFRfRkFTVF9DTElDS19DT05GSVJNQVRJT05T",
            "EAwSRgpCVFJBRElOR19GRUFUVVJFX0VOVElUTEVNRU5UX0RJU0FMTE9XX1NL",
            "SVBfRk9SQ0VfT1JERVJfQ09ORklSTUFUSU9OEA0="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Metadata2.Metadata2Reflection.Descriptor, global::Order2.Order2Reflection.Descriptor, global::Cqg.DecimalReflection.Descriptor, global::Shared1.Shared1Reflection.Descriptor, global::Google.Protobuf.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::TradeRouting2.TradingFeatureEntitlement), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSubscription), global::TradeRouting2.TradeSubscription.Parser, new[]{ "Id", "SubscriptionScopes", "PublicationType", "AccountId", "SalesSeriesNumber", "BrokerageId", "Subscribe", "LastOrderUpdateUtcTime", "LastOrderUpdateUtcTimestamp", "SkipOrdersSnapshot", "ConfirmedPositionsOnly", "MatchingAlgorithm", "MatchIntradayFirst", "HistoricalMatchingAlgorithm", "IncludeCrossOrders", "OrderSnapshotFilter" }, null, new[]{ typeof(global::TradeRouting2.TradeSubscription.Types.SubscriptionScope), typeof(global::TradeRouting2.TradeSubscription.Types.PublicationType), typeof(global::TradeRouting2.TradeSubscription.Types.MatchingAlgorithm) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSubscriptionStatus), global::TradeRouting2.TradeSubscriptionStatus.Parser, new[]{ "Id", "StatusCode", "TextMessage", "Details" }, null, new[]{ typeof(global::TradeRouting2.TradeSubscriptionStatus.Types.StatusCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSnapshotCompletion), global::TradeRouting2.TradeSnapshotCompletion.Parser, new[]{ "SubscriptionId", "SubscriptionScopes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.OrderSnapshotFilter), global::TradeRouting2.OrderSnapshotFilter.Parser, new[]{ "OrderStatuses", "TransactionStatusFilter", "OrderTypes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TransactionStatusFilter), global::TradeRouting2.TransactionStatusFilter.Parser, new[]{ "SkipTransactions", "TransactionStatuses" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.PositionStatus), global::TradeRouting2.PositionStatus.Parser, new[]{ "SubscriptionIds", "IsSnapshot", "AccountId", "ContractId", "IsShortOpenPosition", "OpenPositions", "PurchaseAndSalesGroups", "ContractMetadata", "TodayFillCommissions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.OpenPosition), global::TradeRouting2.OpenPosition.Parser, new[]{ "Id", "Uint32Qty", "Qty", "PriceCorrect", "TradeDate", "StatementDate", "TradeUtcTime", "TradeUtcTimestamp", "IsAggregated", "IsShort", "IsYesterday", "SpeculationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.PurchaseAndSalesGroup), global::TradeRouting2.PurchaseAndSalesGroup.Parser, new[]{ "Id", "RealizedProfitLoss", "MatchedTrades" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.MatchedTrade), global::TradeRouting2.MatchedTrade.Parser, new[]{ "Uint32Qty", "Qty", "IsShort", "Price", "TradeDate", "StatementDate", "TradeUtcTime", "TradeUtcTimestamp", "IsAggregated", "IsYesterday", "IsClose", "SpeculationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.CollateralStatus), global::TradeRouting2.CollateralStatus.Parser, new[]{ "SubscriptionIds", "IsSnapshot", "AccountId", "Currency", "TotalMargin", "PositionMargin", "PurchasingPower", "Ote", "Mvo", "Mvf", "MarginCredit", "StatusUtcTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.HistoricalOrdersRequest), global::TradeRouting2.HistoricalOrdersRequest.Parser, new[]{ "FromDate", "ToDate", "AccountIds", "IncludeCrossOrders", "OrderSnapshotFilter", "MaxOrderStatusCount", "MaxTransactionStatusCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.HistoricalOrdersReport), global::TradeRouting2.HistoricalOrdersReport.Parser, new[]{ "OrderStatuses", "OrderStatusLimitReached", "TransactionStatusLimitReached" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.BrokerageTradingFeatureEntitlementRequest), global::TradeRouting2.BrokerageTradingFeatureEntitlementRequest.Parser, new[]{ "AccountIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.BrokerageTradingFeatureEntitlementReport), global::TradeRouting2.BrokerageTradingFeatureEntitlementReport.Parser, new[]{ "TradingFeatureEntitlements" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradingFeatureEntitlementEntry), global::TradeRouting2.TradingFeatureEntitlementEntry.Parser, new[]{ "AccountId", "Entitlement" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Trading feature entitlements.
  /// </summary>
  public enum TradingFeatureEntitlement {
    /// <summary>
    /// Disallow skipping non-fast click confirmations.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_SKIP_NON_FAST_CLICK_CONFIRMATIONS")] DisallowSkipNonFastClickConfirmations = 3,
    /// <summary>
    /// Disallow skipping Responsive DOMTrader fast click confirmations.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_SKIP_NON_DDT_FAST_CLICK_CONFIRMATIONS")] DisallowSkipNonDdtFastClickConfirmations = 4,
    /// <summary>
    /// Disallow Heads Up.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_HEADS_UP")] DisallowHeadsUp = 5,
    /// <summary>
    /// Disallow Order View.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_ORDER_VIEW")] DisallowOrderView = 6,
    /// <summary>
    /// Disallow Responsive DOMTrader.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_RESPONSIVE_DOM_TRADER")] DisallowResponsiveDomTrader = 8,
    /// <summary>
    /// Disallow Dynamic DOMTrader.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_DYNAMIC_DOM_TRADER")] DisallowDynamicDomTrader = 9,
    /// <summary>
    /// Disallow buy/sell fast click.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_BUY_SELL_FAST_CLICK")] DisallowBuySellFastClick = 11,
    /// <summary>
    /// Disallow skipping Dynamic DOMTrader fast click confirmations.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_SKIP_DDT_FAST_CLICK_CONFIRMATIONS")] DisallowSkipDdtFastClickConfirmations = 12,
    /// <summary>
    /// Disallow skipping force order confirmation.
    /// </summary>
    [pbr::OriginalName("TRADING_FEATURE_ENTITLEMENT_DISALLOW_SKIP_FORCE_ORDER_CONFIRMATION")] DisallowSkipForceOrderConfirmation = 13,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Subscription to trade routing data and notifications about trading information updates.
  /// Client can be subscribed to several publications.
  /// If some account is subscribed by several publications then client will receive a separate snapshot per subscription
  /// but one real time update with a list of subscriptions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TradeSubscription : pb::IMessage<TradeSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSubscription> _parser = new pb::MessageParser<TradeSubscription>(() => new TradeSubscription());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TradeSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscription(TradeSubscription other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      subscriptionScopes_ = other.subscriptionScopes_.Clone();
      publicationType_ = other.publicationType_;
      accountId_ = other.accountId_;
      salesSeriesNumber_ = other.salesSeriesNumber_;
      brokerageId_ = other.brokerageId_;
      subscribe_ = other.subscribe_;
      lastOrderUpdateUtcTime_ = other.lastOrderUpdateUtcTime_;
      lastOrderUpdateUtcTimestamp_ = other.lastOrderUpdateUtcTimestamp_ != null ? other.lastOrderUpdateUtcTimestamp_.Clone() : null;
      skipOrdersSnapshot_ = other.skipOrdersSnapshot_;
      confirmedPositionsOnly_ = other.confirmedPositionsOnly_;
      matchingAlgorithm_ = other.matchingAlgorithm_;
      matchIntradayFirst_ = other.matchIntradayFirst_;
      historicalMatchingAlgorithm_ = other.historicalMatchingAlgorithm_;
      includeCrossOrders_ = other.includeCrossOrders_;
      orderSnapshotFilter_ = other.orderSnapshotFilter_ != null ? other.orderSnapshotFilter_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscription Clone() {
      return new TradeSubscription(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    /// <summary>
    /// ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subscription_scopes" field.</summary>
    public const int SubscriptionScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionScopes_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> subscriptionScopes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// This field is associated with SubscriptionScope enum type.
    /// Request is rejected if subscription_scopes contains duplicates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> SubscriptionScopes {
      get { return subscriptionScopes_; }
    }

    /// <summary>Field number for the "publication_type" field.</summary>
    public const int PublicationTypeFieldNumber = 3;
    private readonly static uint PublicationTypeDefaultValue = 0;

    private uint publicationType_;
    /// <summary>
    /// This field is associated with PublicationType enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PublicationType {
      get { if ((_hasBits0 & 2) != 0) { return publicationType_; } else { return PublicationTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        publicationType_ = value;
      }
    }
    /// <summary>Gets whether the "publication_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPublicationType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "publication_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPublicationType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 4;
    private readonly static uint AccountIdDefaultValue = 0;

    private uint accountId_;
    /// <summary>
    /// Account ID when publicationType = PUBLICATION_TYPE_ACCOUNT.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint AccountId {
      get { if ((_hasBits0 & 4) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sales_series_number" field.</summary>
    public const int SalesSeriesNumberFieldNumber = 5;
    private readonly static string SalesSeriesNumberDefaultValue = "";

    private string salesSeriesNumber_;
    /// <summary>
    /// Sales series number when publicationType = PUBLICATION_TYPE_SALES_SERIES.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SalesSeriesNumber {
      get { return salesSeriesNumber_ ?? SalesSeriesNumberDefaultValue; }
      set {
        salesSeriesNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sales_series_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSalesSeriesNumber {
      get { return salesSeriesNumber_ != null; }
    }
    /// <summary>Clears the value of the "sales_series_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSalesSeriesNumber() {
      salesSeriesNumber_ = null;
    }

    /// <summary>Field number for the "brokerage_id" field.</summary>
    public const int BrokerageIdFieldNumber = 6;
    private readonly static uint BrokerageIdDefaultValue = 0;

    private uint brokerageId_;
    /// <summary>
    /// Brokerage ID when publicationType = PUBLICATION_TYPE_BROKERAGE or PUBLICATION_TYPE_SALES_SERIES.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint BrokerageId {
      get { if ((_hasBits0 & 8) != 0) { return brokerageId_; } else { return BrokerageIdDefaultValue; } }
      set {
        _hasBits0 |= 8;
        brokerageId_ = value;
      }
    }
    /// <summary>Gets whether the "brokerage_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBrokerageId {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "brokerage_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBrokerageId() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "subscribe" field.</summary>
    public const int SubscribeFieldNumber = 7;
    private readonly static bool SubscribeDefaultValue = false;

    private bool subscribe_;
    /// <summary>
    /// True to subscribe, false to unsubscribe (only id value is used to unsubscribe).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Subscribe {
      get { if ((_hasBits0 & 16) != 0) { return subscribe_; } else { return SubscribeDefaultValue; } }
      set {
        _hasBits0 |= 16;
        subscribe_ = value;
      }
    }
    /// <summary>Gets whether the "subscribe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubscribe {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "subscribe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubscribe() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "last_order_update_utc_time" field.</summary>
    public const int LastOrderUpdateUtcTimeFieldNumber = 8;
    private readonly static long LastOrderUpdateUtcTimeDefaultValue = 0L;

    private long lastOrderUpdateUtcTime_;
    /// <summary>
    /// Note: use last_order_update_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long LastOrderUpdateUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return lastOrderUpdateUtcTime_; } else { return LastOrderUpdateUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        lastOrderUpdateUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "last_order_update_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLastOrderUpdateUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "last_order_update_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLastOrderUpdateUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "last_order_update_utc_timestamp" field.</summary>
    public const int LastOrderUpdateUtcTimestampFieldNumber = 14;
    private global::Google.Protobuf.Timestamp lastOrderUpdateUtcTimestamp_;
    /// <summary>
    /// Optionally limit request to receive information about orders
    /// that were updated/added after specified server related time (inclusive).
    /// It is used to reduce amount of information necessary to send after re-connection.
    /// Client should be ready for duplicates that have to be detected by corresponding IDs.
    /// If specified it's used instead of last_order_update_utc_time field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp LastOrderUpdateUtcTimestamp {
      get { return lastOrderUpdateUtcTimestamp_; }
      set {
        lastOrderUpdateUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "skip_orders_snapshot" field.</summary>
    public const int SkipOrdersSnapshotFieldNumber = 9;
    private readonly static bool SkipOrdersSnapshotDefaultValue = false;

    private bool skipOrdersSnapshot_;
    /// <summary>
    /// True means sending only real time data and skip sending an initial orders snapshot,
    /// send initial snapshot otherwise.
    /// NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
    /// use last_order_update_utc_time instead.
    /// NOTE: when set to True, WebAPI server does not send order snapshots for accounts authorized during
    /// the subscription.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SkipOrdersSnapshot {
      get { if ((_hasBits0 & 64) != 0) { return skipOrdersSnapshot_; } else { return SkipOrdersSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 64;
        skipOrdersSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "skip_orders_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSkipOrdersSnapshot {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "skip_orders_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSkipOrdersSnapshot() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "confirmed_positions_only" field.</summary>
    public const int ConfirmedPositionsOnlyFieldNumber = 10;
    private readonly static bool ConfirmedPositionsOnlyDefaultValue = false;

    private bool confirmedPositionsOnly_;
    /// <summary>
    /// True means sending only FCM confirmed positions and their updates (if subscribed)
    /// without matching with current day fills, send matched net positions otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ConfirmedPositionsOnly {
      get { if ((_hasBits0 & 128) != 0) { return confirmedPositionsOnly_; } else { return ConfirmedPositionsOnlyDefaultValue; } }
      set {
        _hasBits0 |= 128;
        confirmedPositionsOnly_ = value;
      }
    }
    /// <summary>Gets whether the "confirmed_positions_only" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConfirmedPositionsOnly {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "confirmed_positions_only" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfirmedPositionsOnly() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "matching_algorithm" field.</summary>
    public const int MatchingAlgorithmFieldNumber = 11;
    private readonly static uint MatchingAlgorithmDefaultValue = 0;

    private uint matchingAlgorithm_;
    /// <summary>
    /// This field is associated with MatchingAlgorithm enum type.
    /// MATCHING_ALGORITHM_FIFO is used if omitted.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// For other contract types it is always MATCHING_ALGORITHM_FIFO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MatchingAlgorithm {
      get { if ((_hasBits0 & 256) != 0) { return matchingAlgorithm_; } else { return MatchingAlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 256;
        matchingAlgorithm_ = value;
      }
    }
    /// <summary>Gets whether the "matching_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMatchingAlgorithm {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "matching_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMatchingAlgorithm() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "match_intraday_first" field.</summary>
    public const int MatchIntradayFirstFieldNumber = 12;
    private readonly static bool MatchIntradayFirstDefaultValue = false;

    private bool matchIntradayFirst_;
    /// <summary>
    /// If true or omitted then intraday trades are matched first
    /// and then intraday leftover is matched against previous close positions.
    /// If false then previous day open positions and intraday fills are matched in a single pass.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// For other contract types it is always false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool MatchIntradayFirst {
      get { if ((_hasBits0 & 512) != 0) { return matchIntradayFirst_; } else { return MatchIntradayFirstDefaultValue; } }
      set {
        _hasBits0 |= 512;
        matchIntradayFirst_ = value;
      }
    }
    /// <summary>Gets whether the "match_intraday_first" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMatchIntradayFirst {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "match_intraday_first" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMatchIntradayFirst() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "historical_matching_algorithm" field.</summary>
    public const int HistoricalMatchingAlgorithmFieldNumber = 13;
    private readonly static uint HistoricalMatchingAlgorithmDefaultValue = 0;

    private uint historicalMatchingAlgorithm_;
    /// <summary>
    /// This field is associated with MatchingAlgorithm enum type.
    /// Historical positions Matching algorithm. The same as matching_algorithm if omitted.
    /// It is ignored if match_intraday_first is false.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint HistoricalMatchingAlgorithm {
      get { if ((_hasBits0 & 1024) != 0) { return historicalMatchingAlgorithm_; } else { return HistoricalMatchingAlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        historicalMatchingAlgorithm_ = value;
      }
    }
    /// <summary>Gets whether the "historical_matching_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHistoricalMatchingAlgorithm {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "historical_matching_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHistoricalMatchingAlgorithm() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "include_cross_orders" field.</summary>
    public const int IncludeCrossOrdersFieldNumber = 15;
    private readonly static bool IncludeCrossOrdersDefaultValue = false;

    private bool includeCrossOrders_;
    /// <summary>
    /// If this field set to true, statuses on orders with ORDER_TYPE_CROSS type will be
    /// included into responses. See CrossOrderParameters message.
    /// Note that order statuses with cross order type are excluded from snapshot only if 
    /// include_cross_orders set to false (or empty) and ORDER_TYPE_CROSS type is not included 
    /// into order_snapshot_filter.order_types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeCrossOrders {
      get { if ((_hasBits0 & 2048) != 0) { return includeCrossOrders_; } else { return IncludeCrossOrdersDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        includeCrossOrders_ = value;
      }
    }
    /// <summary>Gets whether the "include_cross_orders" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIncludeCrossOrders {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "include_cross_orders" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIncludeCrossOrders() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "order_snapshot_filter" field.</summary>
    public const int OrderSnapshotFilterFieldNumber = 16;
    private global::TradeRouting2.OrderSnapshotFilter orderSnapshotFilter_;
    /// <summary>
    /// Only order statuses that match the filter are included in a snapshot.
    /// By default no filtration is done by the filter.
    /// Affects result for scope SUBSCRIPTION_SCOPE_ORDERS.
    /// Note that snapshot might still include additional data in responses (e.g. when multiple trade
    /// subscriptions with different snapshot filters are requested).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TradeRouting2.OrderSnapshotFilter OrderSnapshotFilter {
      get { return orderSnapshotFilter_; }
      set {
        orderSnapshotFilter_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TradeSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TradeSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if(!subscriptionScopes_.Equals(other.subscriptionScopes_)) return false;
      if (PublicationType != other.PublicationType) return false;
      if (AccountId != other.AccountId) return false;
      if (SalesSeriesNumber != other.SalesSeriesNumber) return false;
      if (BrokerageId != other.BrokerageId) return false;
      if (Subscribe != other.Subscribe) return false;
      if (LastOrderUpdateUtcTime != other.LastOrderUpdateUtcTime) return false;
      if (!object.Equals(LastOrderUpdateUtcTimestamp, other.LastOrderUpdateUtcTimestamp)) return false;
      if (SkipOrdersSnapshot != other.SkipOrdersSnapshot) return false;
      if (ConfirmedPositionsOnly != other.ConfirmedPositionsOnly) return false;
      if (MatchingAlgorithm != other.MatchingAlgorithm) return false;
      if (MatchIntradayFirst != other.MatchIntradayFirst) return false;
      if (HistoricalMatchingAlgorithm != other.HistoricalMatchingAlgorithm) return false;
      if (IncludeCrossOrders != other.IncludeCrossOrders) return false;
      if (!object.Equals(OrderSnapshotFilter, other.OrderSnapshotFilter)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      hash ^= subscriptionScopes_.GetHashCode();
      if (HasPublicationType) hash ^= PublicationType.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasSalesSeriesNumber) hash ^= SalesSeriesNumber.GetHashCode();
      if (HasBrokerageId) hash ^= BrokerageId.GetHashCode();
      if (HasSubscribe) hash ^= Subscribe.GetHashCode();
      if (HasLastOrderUpdateUtcTime) hash ^= LastOrderUpdateUtcTime.GetHashCode();
      if (lastOrderUpdateUtcTimestamp_ != null) hash ^= LastOrderUpdateUtcTimestamp.GetHashCode();
      if (HasSkipOrdersSnapshot) hash ^= SkipOrdersSnapshot.GetHashCode();
      if (HasConfirmedPositionsOnly) hash ^= ConfirmedPositionsOnly.GetHashCode();
      if (HasMatchingAlgorithm) hash ^= MatchingAlgorithm.GetHashCode();
      if (HasMatchIntradayFirst) hash ^= MatchIntradayFirst.GetHashCode();
      if (HasHistoricalMatchingAlgorithm) hash ^= HistoricalMatchingAlgorithm.GetHashCode();
      if (HasIncludeCrossOrders) hash ^= IncludeCrossOrders.GetHashCode();
      if (orderSnapshotFilter_ != null) hash ^= OrderSnapshotFilter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      subscriptionScopes_.WriteTo(output, _repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        output.WriteRawTag(24);
        output.WriteUInt32(PublicationType);
      }
      if (HasAccountId) {
        output.WriteRawTag(32);
        output.WriteUInt32(AccountId);
      }
      if (HasSalesSeriesNumber) {
        output.WriteRawTag(42);
        output.WriteString(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        output.WriteRawTag(48);
        output.WriteUInt32(BrokerageId);
      }
      if (HasSubscribe) {
        output.WriteRawTag(56);
        output.WriteBool(Subscribe);
      }
      if (HasLastOrderUpdateUtcTime) {
        output.WriteRawTag(64);
        output.WriteSInt64(LastOrderUpdateUtcTime);
      }
      if (HasSkipOrdersSnapshot) {
        output.WriteRawTag(72);
        output.WriteBool(SkipOrdersSnapshot);
      }
      if (HasConfirmedPositionsOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ConfirmedPositionsOnly);
      }
      if (HasMatchingAlgorithm) {
        output.WriteRawTag(88);
        output.WriteUInt32(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        output.WriteRawTag(96);
        output.WriteBool(MatchIntradayFirst);
      }
      if (HasHistoricalMatchingAlgorithm) {
        output.WriteRawTag(104);
        output.WriteUInt32(HistoricalMatchingAlgorithm);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LastOrderUpdateUtcTimestamp);
      }
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(120);
        output.WriteBool(IncludeCrossOrders);
      }
      if (orderSnapshotFilter_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(OrderSnapshotFilter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      subscriptionScopes_.WriteTo(ref output, _repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        output.WriteRawTag(24);
        output.WriteUInt32(PublicationType);
      }
      if (HasAccountId) {
        output.WriteRawTag(32);
        output.WriteUInt32(AccountId);
      }
      if (HasSalesSeriesNumber) {
        output.WriteRawTag(42);
        output.WriteString(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        output.WriteRawTag(48);
        output.WriteUInt32(BrokerageId);
      }
      if (HasSubscribe) {
        output.WriteRawTag(56);
        output.WriteBool(Subscribe);
      }
      if (HasLastOrderUpdateUtcTime) {
        output.WriteRawTag(64);
        output.WriteSInt64(LastOrderUpdateUtcTime);
      }
      if (HasSkipOrdersSnapshot) {
        output.WriteRawTag(72);
        output.WriteBool(SkipOrdersSnapshot);
      }
      if (HasConfirmedPositionsOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ConfirmedPositionsOnly);
      }
      if (HasMatchingAlgorithm) {
        output.WriteRawTag(88);
        output.WriteUInt32(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        output.WriteRawTag(96);
        output.WriteBool(MatchIntradayFirst);
      }
      if (HasHistoricalMatchingAlgorithm) {
        output.WriteRawTag(104);
        output.WriteUInt32(HistoricalMatchingAlgorithm);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LastOrderUpdateUtcTimestamp);
      }
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(120);
        output.WriteBool(IncludeCrossOrders);
      }
      if (orderSnapshotFilter_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(OrderSnapshotFilter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      size += subscriptionScopes_.CalculateSize(_repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PublicationType);
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AccountId);
      }
      if (HasSalesSeriesNumber) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BrokerageId);
      }
      if (HasSubscribe) {
        size += 1 + 1;
      }
      if (HasLastOrderUpdateUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(LastOrderUpdateUtcTime);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastOrderUpdateUtcTimestamp);
      }
      if (HasSkipOrdersSnapshot) {
        size += 1 + 1;
      }
      if (HasConfirmedPositionsOnly) {
        size += 1 + 1;
      }
      if (HasMatchingAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        size += 1 + 1;
      }
      if (HasHistoricalMatchingAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HistoricalMatchingAlgorithm);
      }
      if (HasIncludeCrossOrders) {
        size += 1 + 1;
      }
      if (orderSnapshotFilter_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OrderSnapshotFilter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TradeSubscription other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      subscriptionScopes_.Add(other.subscriptionScopes_);
      if (other.HasPublicationType) {
        PublicationType = other.PublicationType;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasSalesSeriesNumber) {
        SalesSeriesNumber = other.SalesSeriesNumber;
      }
      if (other.HasBrokerageId) {
        BrokerageId = other.BrokerageId;
      }
      if (other.HasSubscribe) {
        Subscribe = other.Subscribe;
      }
      if (other.HasLastOrderUpdateUtcTime) {
        LastOrderUpdateUtcTime = other.LastOrderUpdateUtcTime;
      }
      if (other.lastOrderUpdateUtcTimestamp_ != null) {
        if (lastOrderUpdateUtcTimestamp_ == null) {
          LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        LastOrderUpdateUtcTimestamp.MergeFrom(other.LastOrderUpdateUtcTimestamp);
      }
      if (other.HasSkipOrdersSnapshot) {
        SkipOrdersSnapshot = other.SkipOrdersSnapshot;
      }
      if (other.HasConfirmedPositionsOnly) {
        ConfirmedPositionsOnly = other.ConfirmedPositionsOnly;
      }
      if (other.HasMatchingAlgorithm) {
        MatchingAlgorithm = other.MatchingAlgorithm;
      }
      if (other.HasMatchIntradayFirst) {
        MatchIntradayFirst = other.MatchIntradayFirst;
      }
      if (other.HasHistoricalMatchingAlgorithm) {
        HistoricalMatchingAlgorithm = other.HistoricalMatchingAlgorithm;
      }
      if (other.HasIncludeCrossOrders) {
        IncludeCrossOrders = other.IncludeCrossOrders;
      }
      if (other.orderSnapshotFilter_ != null) {
        if (orderSnapshotFilter_ == null) {
          OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
        }
        OrderSnapshotFilter.MergeFrom(other.OrderSnapshotFilter);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(input, _repeated_subscriptionScopes_codec);
            break;
          }
          case 24: {
            PublicationType = input.ReadUInt32();
            break;
          }
          case 32: {
            AccountId = input.ReadUInt32();
            break;
          }
          case 42: {
            SalesSeriesNumber = input.ReadString();
            break;
          }
          case 48: {
            BrokerageId = input.ReadUInt32();
            break;
          }
          case 56: {
            Subscribe = input.ReadBool();
            break;
          }
          case 64: {
            LastOrderUpdateUtcTime = input.ReadSInt64();
            break;
          }
          case 72: {
            SkipOrdersSnapshot = input.ReadBool();
            break;
          }
          case 80: {
            ConfirmedPositionsOnly = input.ReadBool();
            break;
          }
          case 88: {
            MatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 96: {
            MatchIntradayFirst = input.ReadBool();
            break;
          }
          case 104: {
            HistoricalMatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 114: {
            if (lastOrderUpdateUtcTimestamp_ == null) {
              LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(LastOrderUpdateUtcTimestamp);
            break;
          }
          case 120: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
          case 130: {
            if (orderSnapshotFilter_ == null) {
              OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
            }
            input.ReadMessage(OrderSnapshotFilter);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(ref input, _repeated_subscriptionScopes_codec);
            break;
          }
          case 24: {
            PublicationType = input.ReadUInt32();
            break;
          }
          case 32: {
            AccountId = input.ReadUInt32();
            break;
          }
          case 42: {
            SalesSeriesNumber = input.ReadString();
            break;
          }
          case 48: {
            BrokerageId = input.ReadUInt32();
            break;
          }
          case 56: {
            Subscribe = input.ReadBool();
            break;
          }
          case 64: {
            LastOrderUpdateUtcTime = input.ReadSInt64();
            break;
          }
          case 72: {
            SkipOrdersSnapshot = input.ReadBool();
            break;
          }
          case 80: {
            ConfirmedPositionsOnly = input.ReadBool();
            break;
          }
          case 88: {
            MatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 96: {
            MatchIntradayFirst = input.ReadBool();
            break;
          }
          case 104: {
            HistoricalMatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 114: {
            if (lastOrderUpdateUtcTimestamp_ == null) {
              LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(LastOrderUpdateUtcTimestamp);
            break;
          }
          case 120: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
          case 130: {
            if (orderSnapshotFilter_ == null) {
              OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
            }
            input.ReadMessage(OrderSnapshotFilter);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TradeSubscription message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Scope of the subscription (provide a list).
      /// </summary>
      public enum SubscriptionScope {
        /// <summary>
        /// Subscribe to order updates.
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_ORDERS")] Orders = 1,
        /// <summary>
        /// Subscribe to open positions and matched trades updates.
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_POSITIONS")] Positions = 2,
        /// <summary>
        /// Subscribe to collateral updates (current margin and purchasing power).
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_COLLATERAL")] Collateral = 3,
      }

      /// <summary>
      /// Type of the publication to subscribe.
      /// </summary>
      public enum PublicationType {
        /// <summary>
        /// Subscribe to a single account.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_ACCOUNT")] Account = 1,
        /// <summary>
        /// Subscribe to all accounts of a specific sales series.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_SALES_SERIES")] SalesSeries = 2,
        /// <summary>
        /// Subscribe to all accounts of a specific brokerage.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_BROKERAGE")] Brokerage = 3,
        /// <summary>
        /// Subscribe to all accounts this user is authorized for (default).
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_ALL_AUTHORIZED")] AllAuthorized = 4,
      }

      /// <summary>
      /// Positions matching algorithm (for position subscription).
      /// </summary>
      public enum MatchingAlgorithm {
        /// <summary>
        /// First In, First Out.
        /// The first order filled is the first order offset when an order on the opposite side of the market is executed.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_FIFO")] Fifo = 1,
        /// <summary>
        /// High Buy, High Sell. The highest buy is matched with the highest sell.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_HBHS")] Hbhs = 2,
        /// <summary>
        /// Last In, First Out.
        /// The last order filled is the first order offset when an order on the opposite side of the market is executed.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_LIFO")] Lifo = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Server status for a trade subscription.
  /// It is sent before or along with a snapshot of initial status information.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TradeSubscriptionStatus : pb::IMessage<TradeSubscriptionStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSubscriptionStatus> _parser = new pb::MessageParser<TradeSubscriptionStatus>(() => new TradeSubscriptionStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TradeSubscriptionStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscriptionStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscriptionStatus(TradeSubscriptionStatus other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      statusCode_ = other.statusCode_;
      textMessage_ = other.textMessage_;
      details_ = other.details_ != null ? other.details_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSubscriptionStatus Clone() {
      return new TradeSubscriptionStatus(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    /// <summary>
    /// Subscription Id this result is sent for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private readonly static uint StatusCodeDefaultValue = 0;

    private uint statusCode_;
    /// <summary>
    /// Subscription result.
    /// This field is associated with StatusCode enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint StatusCode {
      get { if ((_hasBits0 & 2) != 0) { return statusCode_; } else { return StatusCodeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        statusCode_ = value;
      }
    }
    /// <summary>Gets whether the "status_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatusCode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "status_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatusCode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "text_message" field.</summary>
    public const int TextMessageFieldNumber = 3;
    private readonly static string TextMessageDefaultValue = "";

    private string textMessage_;
    /// <summary>
    /// Note: use 'details' instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TextMessage {
      get { return textMessage_ ?? TextMessageDefaultValue; }
      set {
        textMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text_message" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTextMessage {
      get { return textMessage_ != null; }
    }
    /// <summary>Clears the value of the "text_message" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTextMessage() {
      textMessage_ = null;
    }

    /// <summary>Field number for the "details" field.</summary>
    public const int DetailsFieldNumber = 4;
    private global::Shared1.Text details_;
    /// <summary>
    /// Optional details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Shared1.Text Details {
      get { return details_; }
      set {
        details_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TradeSubscriptionStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TradeSubscriptionStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (StatusCode != other.StatusCode) return false;
      if (TextMessage != other.TextMessage) return false;
      if (!object.Equals(Details, other.Details)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasStatusCode) hash ^= StatusCode.GetHashCode();
      if (HasTextMessage) hash ^= TextMessage.GetHashCode();
      if (details_ != null) hash ^= Details.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasTextMessage) {
        output.WriteRawTag(26);
        output.WriteString(TextMessage);
      }
      if (details_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Details);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasTextMessage) {
        output.WriteRawTag(26);
        output.WriteString(TextMessage);
      }
      if (details_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Details);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasStatusCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StatusCode);
      }
      if (HasTextMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TextMessage);
      }
      if (details_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Details);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TradeSubscriptionStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.HasTextMessage) {
        TextMessage = other.TextMessage;
      }
      if (other.details_ != null) {
        if (details_ == null) {
          Details = new global::Shared1.Text();
        }
        Details.MergeFrom(other.Details);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 26: {
            TextMessage = input.ReadString();
            break;
          }
          case 34: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 26: {
            TextMessage = input.ReadString();
            break;
          }
          case 34: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TradeSubscriptionStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Possible result codes.
      /// </summary>
      public enum StatusCode {
        /// <summary>
        /// success codes (0 - 99)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUCCESS")] Success = 0,
        /// <summary>
        /// Currently subscription is [partially] disconnect because of communication issues.
        /// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
        /// sending SUCCESS status once communication issues are resolved following with all necessary data updates.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DISCONNECTED")] Disconnected = 1,
        /// <summary>
        /// failure codes (100+)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_FAILURE")] Failure = 101,
        /// <summary>
        /// The limit of the subscriptions has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIPTION_LIMIT_VIOLATION")] SubscriptionLimitViolation = 102,
        /// <summary>
        /// Unknown or ambiguous account, sales series number, or brokerage id in the subscription.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_INVALID_PUBLICATION_ID")] InvalidPublicationId = 103,
        /// <summary>
        /// The limit of subscribed accounts has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIBED_ACCOUNTS_LIMIT_VIOLATION")] SubscribedAccountsLimitViolation = 104,
      }

    }
    #endregion

  }

  /// <summary>
  /// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TradeSnapshotCompletion : pb::IMessage<TradeSnapshotCompletion>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSnapshotCompletion> _parser = new pb::MessageParser<TradeSnapshotCompletion>(() => new TradeSnapshotCompletion());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TradeSnapshotCompletion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSnapshotCompletion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSnapshotCompletion(TradeSnapshotCompletion other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionId_ = other.subscriptionId_;
      subscriptionScopes_ = other.subscriptionScopes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradeSnapshotCompletion Clone() {
      return new TradeSnapshotCompletion(this);
    }

    /// <summary>Field number for the "subscription_id" field.</summary>
    public const int SubscriptionIdFieldNumber = 1;
    private readonly static uint SubscriptionIdDefaultValue = 0;

    private uint subscriptionId_;
    /// <summary>
    /// ID of a corresponding trade subscription.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SubscriptionId {
      get { if ((_hasBits0 & 1) != 0) { return subscriptionId_; } else { return SubscriptionIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        subscriptionId_ = value;
      }
    }
    /// <summary>Gets whether the "subscription_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubscriptionId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "subscription_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubscriptionId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subscription_scopes" field.</summary>
    public const int SubscriptionScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionScopes_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> subscriptionScopes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of subscription scopes whose snapshots are completed.
    /// Completion message for one scope is sent only once but they can be combined
    /// (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
    /// This field is associated with TradeSubscription.SubscriptionScope enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> SubscriptionScopes {
      get { return subscriptionScopes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TradeSnapshotCompletion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TradeSnapshotCompletion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SubscriptionId != other.SubscriptionId) return false;
      if(!subscriptionScopes_.Equals(other.subscriptionScopes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSubscriptionId) hash ^= SubscriptionId.GetHashCode();
      hash ^= subscriptionScopes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSubscriptionId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SubscriptionId);
      }
      subscriptionScopes_.WriteTo(output, _repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSubscriptionId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SubscriptionId);
      }
      subscriptionScopes_.WriteTo(ref output, _repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSubscriptionId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SubscriptionId);
      }
      size += subscriptionScopes_.CalculateSize(_repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TradeSnapshotCompletion other) {
      if (other == null) {
        return;
      }
      if (other.HasSubscriptionId) {
        SubscriptionId = other.SubscriptionId;
      }
      subscriptionScopes_.Add(other.subscriptionScopes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SubscriptionId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(input, _repeated_subscriptionScopes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SubscriptionId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(ref input, _repeated_subscriptionScopes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// These rules are only applied for the snapshot.
  /// See order_2.OrderStatus.is_snapshot.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OrderSnapshotFilter : pb::IMessage<OrderSnapshotFilter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OrderSnapshotFilter> _parser = new pb::MessageParser<OrderSnapshotFilter>(() => new OrderSnapshotFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OrderSnapshotFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OrderSnapshotFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OrderSnapshotFilter(OrderSnapshotFilter other) : this() {
      orderStatuses_ = other.orderStatuses_.Clone();
      transactionStatusFilter_ = other.transactionStatusFilter_ != null ? other.transactionStatusFilter_.Clone() : null;
      orderTypes_ = other.orderTypes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OrderSnapshotFilter Clone() {
      return new OrderSnapshotFilter(this);
    }

    /// <summary>Field number for the "order_statuses" field.</summary>
    public const int OrderStatusesFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_orderStatuses_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> orderStatuses_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Order statuses with these values of OrderStatus.status field are included in a snapshot.
    /// This field is associated with shared_1.OrderStatus.Status enum type.
    /// If empty, there is no filtration by the field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> OrderStatuses {
      get { return orderStatuses_; }
    }

    /// <summary>Field number for the "transaction_status_filter" field.</summary>
    public const int TransactionStatusFilterFieldNumber = 2;
    private global::TradeRouting2.TransactionStatusFilter transactionStatusFilter_;
    /// <summary>
    /// Order statuses include transactions that match the filter.
    /// If empty, no filtration is done by the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TradeRouting2.TransactionStatusFilter TransactionStatusFilter {
      get { return transactionStatusFilter_; }
      set {
        transactionStatusFilter_ = value;
      }
    }

    /// <summary>Field number for the "order_types" field.</summary>
    public const int OrderTypesFieldNumber = 3;
    private static readonly pb::FieldCodec<uint> _repeated_orderTypes_codec
        = pb::FieldCodec.ForUInt32(24);
    private readonly pbc::RepeatedField<uint> orderTypes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Order statuses with these values of Order.order_type field are included in a snapshot.
    /// This field is associated with OrderType enum type.
    /// If empty, there is no filtration by the field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> OrderTypes {
      get { return orderTypes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OrderSnapshotFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OrderSnapshotFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!orderStatuses_.Equals(other.orderStatuses_)) return false;
      if (!object.Equals(TransactionStatusFilter, other.TransactionStatusFilter)) return false;
      if(!orderTypes_.Equals(other.orderTypes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= orderStatuses_.GetHashCode();
      if (transactionStatusFilter_ != null) hash ^= TransactionStatusFilter.GetHashCode();
      hash ^= orderTypes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      orderStatuses_.WriteTo(output, _repeated_orderStatuses_codec);
      if (transactionStatusFilter_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TransactionStatusFilter);
      }
      orderTypes_.WriteTo(output, _repeated_orderTypes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      orderStatuses_.WriteTo(ref output, _repeated_orderStatuses_codec);
      if (transactionStatusFilter_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TransactionStatusFilter);
      }
      orderTypes_.WriteTo(ref output, _repeated_orderTypes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += orderStatuses_.CalculateSize(_repeated_orderStatuses_codec);
      if (transactionStatusFilter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransactionStatusFilter);
      }
      size += orderTypes_.CalculateSize(_repeated_orderTypes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OrderSnapshotFilter other) {
      if (other == null) {
        return;
      }
      orderStatuses_.Add(other.orderStatuses_);
      if (other.transactionStatusFilter_ != null) {
        if (transactionStatusFilter_ == null) {
          TransactionStatusFilter = new global::TradeRouting2.TransactionStatusFilter();
        }
        TransactionStatusFilter.MergeFrom(other.TransactionStatusFilter);
      }
      orderTypes_.Add(other.orderTypes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            orderStatuses_.AddEntriesFrom(input, _repeated_orderStatuses_codec);
            break;
          }
          case 18: {
            if (transactionStatusFilter_ == null) {
              TransactionStatusFilter = new global::TradeRouting2.TransactionStatusFilter();
            }
            input.ReadMessage(TransactionStatusFilter);
            break;
          }
          case 26:
          case 24: {
            orderTypes_.AddEntriesFrom(input, _repeated_orderTypes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            orderStatuses_.AddEntriesFrom(ref input, _repeated_orderStatuses_codec);
            break;
          }
          case 18: {
            if (transactionStatusFilter_ == null) {
              TransactionStatusFilter = new global::TradeRouting2.TransactionStatusFilter();
            }
            input.ReadMessage(TransactionStatusFilter);
            break;
          }
          case 26:
          case 24: {
            orderTypes_.AddEntriesFrom(ref input, _repeated_orderTypes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransactionStatusFilter : pb::IMessage<TransactionStatusFilter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionStatusFilter> _parser = new pb::MessageParser<TransactionStatusFilter>(() => new TransactionStatusFilter());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransactionStatusFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionStatusFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionStatusFilter(TransactionStatusFilter other) : this() {
      _hasBits0 = other._hasBits0;
      skipTransactions_ = other.skipTransactions_;
      transactionStatuses_ = other.transactionStatuses_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionStatusFilter Clone() {
      return new TransactionStatusFilter(this);
    }

    /// <summary>Field number for the "skip_transactions" field.</summary>
    public const int SkipTransactionsFieldNumber = 1;
    private readonly static bool SkipTransactionsDefaultValue = false;

    private bool skipTransactions_;
    /// <summary>
    /// No transactions are sent.
    /// Request is rejected if skip_transactions is true and transaction_statuses field is not empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SkipTransactions {
      get { if ((_hasBits0 & 1) != 0) { return skipTransactions_; } else { return SkipTransactionsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        skipTransactions_ = value;
      }
    }
    /// <summary>Gets whether the "skip_transactions" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSkipTransactions {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "skip_transactions" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSkipTransactions() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "transaction_statuses" field.</summary>
    public const int TransactionStatusesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_transactionStatuses_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> transactionStatuses_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Transaction statuses with these values of TransactionStatus.status are sent.
    /// If empty, there is no filtration by the field.
    /// This field is associated with shared_1.TransactionStatus.Status enum type.  
    /// Request is rejected if skip_transactions is true and transaction_statuses field is not empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> TransactionStatuses {
      get { return transactionStatuses_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransactionStatusFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransactionStatusFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SkipTransactions != other.SkipTransactions) return false;
      if(!transactionStatuses_.Equals(other.transactionStatuses_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSkipTransactions) hash ^= SkipTransactions.GetHashCode();
      hash ^= transactionStatuses_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSkipTransactions) {
        output.WriteRawTag(8);
        output.WriteBool(SkipTransactions);
      }
      transactionStatuses_.WriteTo(output, _repeated_transactionStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSkipTransactions) {
        output.WriteRawTag(8);
        output.WriteBool(SkipTransactions);
      }
      transactionStatuses_.WriteTo(ref output, _repeated_transactionStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSkipTransactions) {
        size += 1 + 1;
      }
      size += transactionStatuses_.CalculateSize(_repeated_transactionStatuses_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransactionStatusFilter other) {
      if (other == null) {
        return;
      }
      if (other.HasSkipTransactions) {
        SkipTransactions = other.SkipTransactions;
      }
      transactionStatuses_.Add(other.transactionStatuses_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SkipTransactions = input.ReadBool();
            break;
          }
          case 18:
          case 16: {
            transactionStatuses_.AddEntriesFrom(input, _repeated_transactionStatuses_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SkipTransactions = input.ReadBool();
            break;
          }
          case 18:
          case 16: {
            transactionStatuses_.AddEntriesFrom(ref input, _repeated_transactionStatuses_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Status of a contract open positions and purchase and sales for a specific account for the current day
  /// (contractId and accountId are used as a key for updates).
  /// Contract position is deleted when all open positions and purchase and sales groups are deleted.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PositionStatus : pb::IMessage<PositionStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PositionStatus> _parser = new pb::MessageParser<PositionStatus>(() => new PositionStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PositionStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PositionStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PositionStatus(PositionStatus other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionIds_ = other.subscriptionIds_.Clone();
      isSnapshot_ = other.isSnapshot_;
      accountId_ = other.accountId_;
      contractId_ = other.contractId_;
      isShortOpenPosition_ = other.isShortOpenPosition_;
      openPositions_ = other.openPositions_.Clone();
      purchaseAndSalesGroups_ = other.purchaseAndSalesGroups_.Clone();
      contractMetadata_ = other.contractMetadata_ != null ? other.contractMetadata_.Clone() : null;
      todayFillCommissions_ = other.todayFillCommissions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PositionStatus Clone() {
      return new PositionStatus(this);
    }

    /// <summary>Field number for the "subscription_ids" field.</summary>
    public const int SubscriptionIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionIds_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> subscriptionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of trade subscription IDs this status is related to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> SubscriptionIds {
      get { return subscriptionIds_; }
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 2;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// True if this is a snapshot related message.
    /// Since snapshot might be sent in several messages (including none),
    /// client should use TradeSnapshotCompletion message as an indicator of complete snapshot delivery.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 1) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 3;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account this position belongs to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 4;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Contract ID assigned by server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ContractId {
      get { if ((_hasBits0 & 4) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContractId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContractId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "is_short_open_position" field.</summary>
    public const int IsShortOpenPositionFieldNumber = 5;
    private readonly static bool IsShortOpenPositionDefaultValue = false;

    private bool isShortOpenPosition_;
    /// <summary>
    /// True if open positions are short (result of sell operations), long otherwise.
    /// In case of separated long and short positions the value is true if the cumulative position is short or flat,
    /// the value is false if the cumulative position is long.
    /// The attribute is deprecated, refer to OpenPosition.is_short instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsShortOpenPosition {
      get { if ((_hasBits0 & 8) != 0) { return isShortOpenPosition_; } else { return IsShortOpenPositionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        isShortOpenPosition_ = value;
      }
    }
    /// <summary>Gets whether the "is_short_open_position" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsShortOpenPosition {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "is_short_open_position" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsShortOpenPosition() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "open_positions" field.</summary>
    public const int OpenPositionsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::TradeRouting2.OpenPosition> _repeated_openPositions_codec
        = pb::FieldCodec.ForMessage(50, global::TradeRouting2.OpenPosition.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.OpenPosition> openPositions_ = new pbc::RepeatedField<global::TradeRouting2.OpenPosition>();
    /// <summary>
    /// List of new/ updated or deleted open positions.
    /// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TradeRouting2.OpenPosition> OpenPositions {
      get { return openPositions_; }
    }

    /// <summary>Field number for the "purchase_and_sales_groups" field.</summary>
    public const int PurchaseAndSalesGroupsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::TradeRouting2.PurchaseAndSalesGroup> _repeated_purchaseAndSalesGroups_codec
        = pb::FieldCodec.ForMessage(58, global::TradeRouting2.PurchaseAndSalesGroup.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup> purchaseAndSalesGroups_ = new pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup>();
    /// <summary>
    /// List of purchase and sales groups. This group represent offset trades (usually one sell and one buy).
    /// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup> PurchaseAndSalesGroups {
      get { return purchaseAndSalesGroups_; }
    }

    /// <summary>Field number for the "contract_metadata" field.</summary>
    public const int ContractMetadataFieldNumber = 8;
    private global::Metadata2.ContractMetadata contractMetadata_;
    /// <summary>
    /// Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
    /// If the contract is unknown to the client before this ServerMsg,
    /// contract meta-data will be added in at least one of them.
    /// If in your code you process orders first and positions second then during processing orders you may
    /// encounter order with yet unknown contract_id.
    /// In this case you should look for matching contract metadata in positions.
    /// The opposite is also true: contract metadata for positions can be in order status messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Metadata2.ContractMetadata ContractMetadata {
      get { return contractMetadata_; }
      set {
        contractMetadata_ = value;
      }
    }

    /// <summary>Field number for the "today_fill_commissions" field.</summary>
    public const int TodayFillCommissionsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Order2.Commission> _repeated_todayFillCommissions_codec
        = pb::FieldCodec.ForMessage(74, global::Order2.Commission.Parser);
    private readonly pbc::RepeatedField<global::Order2.Commission> todayFillCommissions_ = new pbc::RepeatedField<global::Order2.Commission>();
    /// <summary>
    /// Sum of today fill commissions per currency for the contract.
    /// Aggregated value from TransactionStatus.fill_commission for current day orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Order2.Commission> TodayFillCommissions {
      get { return todayFillCommissions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PositionStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PositionStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!subscriptionIds_.Equals(other.subscriptionIds_)) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if (AccountId != other.AccountId) return false;
      if (ContractId != other.ContractId) return false;
      if (IsShortOpenPosition != other.IsShortOpenPosition) return false;
      if(!openPositions_.Equals(other.openPositions_)) return false;
      if(!purchaseAndSalesGroups_.Equals(other.purchaseAndSalesGroups_)) return false;
      if (!object.Equals(ContractMetadata, other.ContractMetadata)) return false;
      if(!todayFillCommissions_.Equals(other.todayFillCommissions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= subscriptionIds_.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasIsShortOpenPosition) hash ^= IsShortOpenPosition.GetHashCode();
      hash ^= openPositions_.GetHashCode();
      hash ^= purchaseAndSalesGroups_.GetHashCode();
      if (contractMetadata_ != null) hash ^= ContractMetadata.GetHashCode();
      hash ^= todayFillCommissions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      subscriptionIds_.WriteTo(output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (HasIsShortOpenPosition) {
        output.WriteRawTag(40);
        output.WriteBool(IsShortOpenPosition);
      }
      openPositions_.WriteTo(output, _repeated_openPositions_codec);
      purchaseAndSalesGroups_.WriteTo(output, _repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ContractMetadata);
      }
      todayFillCommissions_.WriteTo(output, _repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      subscriptionIds_.WriteTo(ref output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (HasIsShortOpenPosition) {
        output.WriteRawTag(40);
        output.WriteBool(IsShortOpenPosition);
      }
      openPositions_.WriteTo(ref output, _repeated_openPositions_codec);
      purchaseAndSalesGroups_.WriteTo(ref output, _repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ContractMetadata);
      }
      todayFillCommissions_.WriteTo(ref output, _repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += subscriptionIds_.CalculateSize(_repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasIsShortOpenPosition) {
        size += 1 + 1;
      }
      size += openPositions_.CalculateSize(_repeated_openPositions_codec);
      size += purchaseAndSalesGroups_.CalculateSize(_repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractMetadata);
      }
      size += todayFillCommissions_.CalculateSize(_repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PositionStatus other) {
      if (other == null) {
        return;
      }
      subscriptionIds_.Add(other.subscriptionIds_);
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasIsShortOpenPosition) {
        IsShortOpenPosition = other.IsShortOpenPosition;
      }
      openPositions_.Add(other.openPositions_);
      purchaseAndSalesGroups_.Add(other.purchaseAndSalesGroups_);
      if (other.contractMetadata_ != null) {
        if (contractMetadata_ == null) {
          ContractMetadata = new global::Metadata2.ContractMetadata();
        }
        ContractMetadata.MergeFrom(other.ContractMetadata);
      }
      todayFillCommissions_.Add(other.todayFillCommissions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 40: {
            IsShortOpenPosition = input.ReadBool();
            break;
          }
          case 50: {
            openPositions_.AddEntriesFrom(input, _repeated_openPositions_codec);
            break;
          }
          case 58: {
            purchaseAndSalesGroups_.AddEntriesFrom(input, _repeated_purchaseAndSalesGroups_codec);
            break;
          }
          case 66: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 74: {
            todayFillCommissions_.AddEntriesFrom(input, _repeated_todayFillCommissions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(ref input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 40: {
            IsShortOpenPosition = input.ReadBool();
            break;
          }
          case 50: {
            openPositions_.AddEntriesFrom(ref input, _repeated_openPositions_codec);
            break;
          }
          case 58: {
            purchaseAndSalesGroups_.AddEntriesFrom(ref input, _repeated_purchaseAndSalesGroups_codec);
            break;
          }
          case 66: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 74: {
            todayFillCommissions_.AddEntriesFrom(ref input, _repeated_todayFillCommissions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Account and contract open position.
  /// There could be more than one position per account and contract.
  /// (id is used as a key for updates).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OpenPosition : pb::IMessage<OpenPosition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpenPosition> _parser = new pb::MessageParser<OpenPosition>(() => new OpenPosition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OpenPosition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpenPosition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpenPosition(OpenPosition other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      uint32Qty_ = other.uint32Qty_;
      qty_ = other.qty_ != null ? other.qty_.Clone() : null;
      priceCorrect_ = other.priceCorrect_;
      tradeDate_ = other.tradeDate_;
      statementDate_ = other.statementDate_;
      tradeUtcTime_ = other.tradeUtcTime_;
      tradeUtcTimestamp_ = other.tradeUtcTimestamp_ != null ? other.tradeUtcTimestamp_.Clone() : null;
      isAggregated_ = other.isAggregated_;
      isShort_ = other.isShort_;
      isYesterday_ = other.isYesterday_;
      speculationType_ = other.speculationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OpenPosition Clone() {
      return new OpenPosition(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static int IdDefaultValue = 0;

    private int id_;
    /// <summary>
    /// Surrogate id as a key for updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_qty" field.</summary>
    public const int Uint32QtyFieldNumber = 2;
    private readonly static uint Uint32QtyDefaultValue = 0;

    private uint uint32Qty_;
    /// <summary>
    /// Note: use qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32Qty {
      get { if ((_hasBits0 & 2) != 0) { return uint32Qty_; } else { return Uint32QtyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32Qty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32Qty {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32Qty() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "qty" field.</summary>
    public const int QtyFieldNumber = 12;
    private global::Cqg.Decimal qty_;
    /// <summary>
    /// Position size, zero means that this position is deleted.
    /// Note: quantity can be safely compared to zero, because this is an integral number of
    /// ContractMetadata.volume_scale units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal Qty {
      get { return qty_; }
      set {
        qty_ = value;
      }
    }

    /// <summary>Field number for the "price_correct" field.</summary>
    public const int PriceCorrectFieldNumber = 3;
    private readonly static double PriceCorrectDefaultValue = 0D;

    private double priceCorrect_;
    /// <summary>
    /// Position average price.
    /// NOTE: Since it could be an aggregated position price is sent in correct format directly.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PriceCorrect {
      get { if ((_hasBits0 & 4) != 0) { return priceCorrect_; } else { return PriceCorrectDefaultValue; } }
      set {
        _hasBits0 |= 4;
        priceCorrect_ = value;
      }
    }
    /// <summary>Gets whether the "price_correct" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceCorrect {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price_correct" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceCorrect() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "trade_date" field.</summary>
    public const int TradeDateFieldNumber = 4;
    private readonly static long TradeDateDefaultValue = 0L;

    private long tradeDate_;
    /// <summary>
    /// Exchange specific trade date when the position was open or last changed (date only value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TradeDate {
      get { if ((_hasBits0 & 8) != 0) { return tradeDate_; } else { return TradeDateDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tradeDate_ = value;
      }
    }
    /// <summary>Gets whether the "trade_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTradeDate {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "trade_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTradeDate() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "statement_date" field.</summary>
    public const int StatementDateFieldNumber = 5;
    private readonly static long StatementDateDefaultValue = 0L;

    private long statementDate_;
    /// <summary>
    /// Statement date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StatementDate {
      get { if ((_hasBits0 & 16) != 0) { return statementDate_; } else { return StatementDateDefaultValue; } }
      set {
        _hasBits0 |= 16;
        statementDate_ = value;
      }
    }
    /// <summary>Gets whether the "statement_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatementDate {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "statement_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatementDate() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "trade_utc_time" field.</summary>
    public const int TradeUtcTimeFieldNumber = 6;
    private readonly static long TradeUtcTimeDefaultValue = 0L;

    private long tradeUtcTime_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// Note: use trade_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TradeUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return tradeUtcTime_; } else { return TradeUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tradeUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "trade_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTradeUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "trade_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTradeUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "trade_utc_timestamp" field.</summary>
    public const int TradeUtcTimestampFieldNumber = 8;
    private global::Google.Protobuf.Timestamp tradeUtcTimestamp_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp TradeUtcTimestamp {
      get { return tradeUtcTimestamp_; }
      set {
        tradeUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "is_aggregated" field.</summary>
    public const int IsAggregatedFieldNumber = 7;
    private readonly static bool IsAggregatedDefaultValue = false;

    private bool isAggregated_;
    /// <summary>
    /// True if the price is an aggregated position price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsAggregated {
      get { if ((_hasBits0 & 64) != 0) { return isAggregated_; } else { return IsAggregatedDefaultValue; } }
      set {
        _hasBits0 |= 64;
        isAggregated_ = value;
      }
    }
    /// <summary>Gets whether the "is_aggregated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsAggregated {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "is_aggregated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsAggregated() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "is_short" field.</summary>
    public const int IsShortFieldNumber = 9;
    private readonly static bool IsShortDefaultValue = false;

    private bool isShort_;
    /// <summary>
    /// True if the open position is short (result of a sell operation), long otherwise.
    /// Undefined for deleted position (qty is 0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsShort {
      get { if ((_hasBits0 & 128) != 0) { return isShort_; } else { return IsShortDefaultValue; } }
      set {
        _hasBits0 |= 128;
        isShort_ = value;
      }
    }
    /// <summary>Gets whether the "is_short" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsShort {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "is_short" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsShort() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "is_yesterday" field.</summary>
    public const int IsYesterdayFieldNumber = 10;
    private readonly static bool IsYesterdayDefaultValue = false;

    private bool isYesterday_;
    /// <summary>
    /// Whether it is a yesterday or a today position.
    /// NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
    /// position tracking and open/close instructions. It is not the same as previous day (associated
    /// with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
    /// with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
    /// position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
    /// that contract, and before the brokerage statement arrives reflecting it as a previous day position,
    /// the same open position or matched trade will contain is_yesterday=true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsYesterday {
      get { if ((_hasBits0 & 256) != 0) { return isYesterday_; } else { return IsYesterdayDefaultValue; } }
      set {
        _hasBits0 |= 256;
        isYesterday_ = value;
      }
    }
    /// <summary>Gets whether the "is_yesterday" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsYesterday {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "is_yesterday" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsYesterday() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "speculation_type" field.</summary>
    public const int SpeculationTypeFieldNumber = 11;
    private readonly static uint SpeculationTypeDefaultValue = 0;

    private uint speculationType_;
    /// <summary>
    /// Speculation type of the position. One of SpeculationType enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SpeculationType {
      get { if ((_hasBits0 & 512) != 0) { return speculationType_; } else { return SpeculationTypeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        speculationType_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSpeculationType {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSpeculationType() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OpenPosition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OpenPosition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Uint32Qty != other.Uint32Qty) return false;
      if (!object.Equals(Qty, other.Qty)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceCorrect, other.PriceCorrect)) return false;
      if (TradeDate != other.TradeDate) return false;
      if (StatementDate != other.StatementDate) return false;
      if (TradeUtcTime != other.TradeUtcTime) return false;
      if (!object.Equals(TradeUtcTimestamp, other.TradeUtcTimestamp)) return false;
      if (IsAggregated != other.IsAggregated) return false;
      if (IsShort != other.IsShort) return false;
      if (IsYesterday != other.IsYesterday) return false;
      if (SpeculationType != other.SpeculationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasUint32Qty) hash ^= Uint32Qty.GetHashCode();
      if (qty_ != null) hash ^= Qty.GetHashCode();
      if (HasPriceCorrect) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceCorrect);
      if (HasTradeDate) hash ^= TradeDate.GetHashCode();
      if (HasStatementDate) hash ^= StatementDate.GetHashCode();
      if (HasTradeUtcTime) hash ^= TradeUtcTime.GetHashCode();
      if (tradeUtcTimestamp_ != null) hash ^= TradeUtcTimestamp.GetHashCode();
      if (HasIsAggregated) hash ^= IsAggregated.GetHashCode();
      if (HasIsShort) hash ^= IsShort.GetHashCode();
      if (HasIsYesterday) hash ^= IsYesterday.GetHashCode();
      if (HasSpeculationType) hash ^= SpeculationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasUint32Qty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasPriceCorrect) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceCorrect);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsShort) {
        output.WriteRawTag(72);
        output.WriteBool(IsShort);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(80);
        output.WriteBool(IsYesterday);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasUint32Qty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasPriceCorrect) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceCorrect);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsShort) {
        output.WriteRawTag(72);
        output.WriteBool(IsShort);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(80);
        output.WriteBool(IsYesterday);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Id);
      }
      if (HasUint32Qty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32Qty);
      }
      if (qty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Qty);
      }
      if (HasPriceCorrect) {
        size += 1 + 8;
      }
      if (HasTradeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeDate);
      }
      if (HasStatementDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(StatementDate);
      }
      if (HasTradeUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeUtcTime);
      }
      if (tradeUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TradeUtcTimestamp);
      }
      if (HasIsAggregated) {
        size += 1 + 1;
      }
      if (HasIsShort) {
        size += 1 + 1;
      }
      if (HasIsYesterday) {
        size += 1 + 1;
      }
      if (HasSpeculationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpeculationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OpenPosition other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasUint32Qty) {
        Uint32Qty = other.Uint32Qty;
      }
      if (other.qty_ != null) {
        if (qty_ == null) {
          Qty = new global::Cqg.Decimal();
        }
        Qty.MergeFrom(other.Qty);
      }
      if (other.HasPriceCorrect) {
        PriceCorrect = other.PriceCorrect;
      }
      if (other.HasTradeDate) {
        TradeDate = other.TradeDate;
      }
      if (other.HasStatementDate) {
        StatementDate = other.StatementDate;
      }
      if (other.HasTradeUtcTime) {
        TradeUtcTime = other.TradeUtcTime;
      }
      if (other.tradeUtcTimestamp_ != null) {
        if (tradeUtcTimestamp_ == null) {
          TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        TradeUtcTimestamp.MergeFrom(other.TradeUtcTimestamp);
      }
      if (other.HasIsAggregated) {
        IsAggregated = other.IsAggregated;
      }
      if (other.HasIsShort) {
        IsShort = other.IsShort;
      }
      if (other.HasIsYesterday) {
        IsYesterday = other.IsYesterday;
      }
      if (other.HasSpeculationType) {
        SpeculationType = other.SpeculationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 25: {
            PriceCorrect = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsShort = input.ReadBool();
            break;
          }
          case 80: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 25: {
            PriceCorrect = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsShort = input.ReadBool();
            break;
          }
          case 80: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Purchase and sales group that represents offset trades (usually one sell and one buy trade).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PurchaseAndSalesGroup : pb::IMessage<PurchaseAndSalesGroup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PurchaseAndSalesGroup> _parser = new pb::MessageParser<PurchaseAndSalesGroup>(() => new PurchaseAndSalesGroup());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PurchaseAndSalesGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PurchaseAndSalesGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PurchaseAndSalesGroup(PurchaseAndSalesGroup other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      realizedProfitLoss_ = other.realizedProfitLoss_;
      matchedTrades_ = other.matchedTrades_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PurchaseAndSalesGroup Clone() {
      return new PurchaseAndSalesGroup(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static int IdDefaultValue = 0;

    private int id_;
    /// <summary>
    /// Surrogate id as a key for updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "realized_profit_loss" field.</summary>
    public const int RealizedProfitLossFieldNumber = 2;
    private readonly static double RealizedProfitLossDefaultValue = 0D;

    private double realizedProfitLoss_;
    /// <summary>
    /// Profit/ loss (in contract currency) of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double RealizedProfitLoss {
      get { if ((_hasBits0 & 2) != 0) { return realizedProfitLoss_; } else { return RealizedProfitLossDefaultValue; } }
      set {
        _hasBits0 |= 2;
        realizedProfitLoss_ = value;
      }
    }
    /// <summary>Gets whether the "realized_profit_loss" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRealizedProfitLoss {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "realized_profit_loss" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRealizedProfitLoss() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "matched_trades" field.</summary>
    public const int MatchedTradesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::TradeRouting2.MatchedTrade> _repeated_matchedTrades_codec
        = pb::FieldCodec.ForMessage(26, global::TradeRouting2.MatchedTrade.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.MatchedTrade> matchedTrades_ = new pbc::RepeatedField<global::TradeRouting2.MatchedTrade>();
    /// <summary>
    /// List of matched trades in a group.
    /// In case of group updates the whole list is sent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TradeRouting2.MatchedTrade> MatchedTrades {
      get { return matchedTrades_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PurchaseAndSalesGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PurchaseAndSalesGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RealizedProfitLoss, other.RealizedProfitLoss)) return false;
      if(!matchedTrades_.Equals(other.matchedTrades_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasRealizedProfitLoss) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RealizedProfitLoss);
      hash ^= matchedTrades_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasRealizedProfitLoss) {
        output.WriteRawTag(17);
        output.WriteDouble(RealizedProfitLoss);
      }
      matchedTrades_.WriteTo(output, _repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasRealizedProfitLoss) {
        output.WriteRawTag(17);
        output.WriteDouble(RealizedProfitLoss);
      }
      matchedTrades_.WriteTo(ref output, _repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Id);
      }
      if (HasRealizedProfitLoss) {
        size += 1 + 8;
      }
      size += matchedTrades_.CalculateSize(_repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PurchaseAndSalesGroup other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasRealizedProfitLoss) {
        RealizedProfitLoss = other.RealizedProfitLoss;
      }
      matchedTrades_.Add(other.matchedTrades_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 17: {
            RealizedProfitLoss = input.ReadDouble();
            break;
          }
          case 26: {
            matchedTrades_.AddEntriesFrom(input, _repeated_matchedTrades_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 17: {
            RealizedProfitLoss = input.ReadDouble();
            break;
          }
          case 26: {
            matchedTrades_.AddEntriesFrom(ref input, _repeated_matchedTrades_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specific trade or position that is a part of a purchase and sales group.
  /// (id is used as a key for updates).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class MatchedTrade : pb::IMessage<MatchedTrade>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MatchedTrade> _parser = new pb::MessageParser<MatchedTrade>(() => new MatchedTrade());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MatchedTrade> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MatchedTrade() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MatchedTrade(MatchedTrade other) : this() {
      _hasBits0 = other._hasBits0;
      uint32Qty_ = other.uint32Qty_;
      qty_ = other.qty_ != null ? other.qty_.Clone() : null;
      isShort_ = other.isShort_;
      price_ = other.price_;
      tradeDate_ = other.tradeDate_;
      statementDate_ = other.statementDate_;
      tradeUtcTime_ = other.tradeUtcTime_;
      tradeUtcTimestamp_ = other.tradeUtcTimestamp_ != null ? other.tradeUtcTimestamp_.Clone() : null;
      isAggregated_ = other.isAggregated_;
      isYesterday_ = other.isYesterday_;
      isClose_ = other.isClose_;
      speculationType_ = other.speculationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MatchedTrade Clone() {
      return new MatchedTrade(this);
    }

    /// <summary>Field number for the "uint32_qty" field.</summary>
    public const int Uint32QtyFieldNumber = 1;
    private readonly static uint Uint32QtyDefaultValue = 0;

    private uint uint32Qty_;
    /// <summary>
    /// Note: use qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32Qty {
      get { if ((_hasBits0 & 1) != 0) { return uint32Qty_; } else { return Uint32QtyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        uint32Qty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32Qty {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "uint32_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32Qty() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "qty" field.</summary>
    public const int QtyFieldNumber = 12;
    private global::Cqg.Decimal qty_;
    /// <summary>
    /// Matched size.
    /// Zero means matched trade is deleted.
    /// Note: quantity can be safely compared to zero, because this is an integral number of
    /// ContractMetadata.volume_scale units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal Qty {
      get { return qty_; }
      set {
        qty_ = value;
      }
    }

    /// <summary>Field number for the "is_short" field.</summary>
    public const int IsShortFieldNumber = 2;
    private readonly static bool IsShortDefaultValue = false;

    private bool isShort_;
    /// <summary>
    /// True if this is a short trade (e.g. result of sell operation), long otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsShort {
      get { if ((_hasBits0 & 2) != 0) { return isShort_; } else { return IsShortDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isShort_ = value;
      }
    }
    /// <summary>Gets whether the "is_short" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsShort {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_short" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsShort() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "price" field.</summary>
    public const int PriceFieldNumber = 3;
    private readonly static double PriceDefaultValue = 0D;

    private double price_;
    /// <summary>
    /// Trade or position average price.
    /// NOTE: Since it could be an aggregated position price is sent in correct format directly.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Price {
      get { if ((_hasBits0 & 4) != 0) { return price_; } else { return PriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        price_ = value;
      }
    }
    /// <summary>Gets whether the "price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrice() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "trade_date" field.</summary>
    public const int TradeDateFieldNumber = 4;
    private readonly static long TradeDateDefaultValue = 0L;

    private long tradeDate_;
    /// <summary>
    /// Trade date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TradeDate {
      get { if ((_hasBits0 & 8) != 0) { return tradeDate_; } else { return TradeDateDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tradeDate_ = value;
      }
    }
    /// <summary>Gets whether the "trade_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTradeDate {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "trade_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTradeDate() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "statement_date" field.</summary>
    public const int StatementDateFieldNumber = 5;
    private readonly static long StatementDateDefaultValue = 0L;

    private long statementDate_;
    /// <summary>
    /// Statement date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StatementDate {
      get { if ((_hasBits0 & 16) != 0) { return statementDate_; } else { return StatementDateDefaultValue; } }
      set {
        _hasBits0 |= 16;
        statementDate_ = value;
      }
    }
    /// <summary>Gets whether the "statement_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatementDate {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "statement_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatementDate() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "trade_utc_time" field.</summary>
    public const int TradeUtcTimeFieldNumber = 6;
    private readonly static long TradeUtcTimeDefaultValue = 0L;

    private long tradeUtcTime_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// Note: use trade_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TradeUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return tradeUtcTime_; } else { return TradeUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tradeUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "trade_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTradeUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "trade_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTradeUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "trade_utc_timestamp" field.</summary>
    public const int TradeUtcTimestampFieldNumber = 8;
    private global::Google.Protobuf.Timestamp tradeUtcTimestamp_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp TradeUtcTimestamp {
      get { return tradeUtcTimestamp_; }
      set {
        tradeUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "is_aggregated" field.</summary>
    public const int IsAggregatedFieldNumber = 7;
    private readonly static bool IsAggregatedDefaultValue = false;

    private bool isAggregated_;
    /// <summary>
    /// True if the price is an aggregated position price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsAggregated {
      get { if ((_hasBits0 & 64) != 0) { return isAggregated_; } else { return IsAggregatedDefaultValue; } }
      set {
        _hasBits0 |= 64;
        isAggregated_ = value;
      }
    }
    /// <summary>Gets whether the "is_aggregated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsAggregated {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "is_aggregated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsAggregated() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "is_yesterday" field.</summary>
    public const int IsYesterdayFieldNumber = 9;
    private readonly static bool IsYesterdayDefaultValue = false;

    private bool isYesterday_;
    /// <summary>
    /// Whether the trade is of a yesterday or a today position.
    /// NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
    /// position tracking and open/close instructions. It is not the same as previous day (associated
    /// with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
    /// with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
    /// position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
    /// that contract, and before the brokerage statement arrives reflecting it as a previous day position,
    /// the same open position or matched trade will contain is_yesterday=true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsYesterday {
      get { if ((_hasBits0 & 128) != 0) { return isYesterday_; } else { return IsYesterdayDefaultValue; } }
      set {
        _hasBits0 |= 128;
        isYesterday_ = value;
      }
    }
    /// <summary>Gets whether the "is_yesterday" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsYesterday {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "is_yesterday" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsYesterday() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "is_close" field.</summary>
    public const int IsCloseFieldNumber = 10;
    private readonly static bool IsCloseDefaultValue = false;

    private bool isClose_;
    /// <summary>
    /// Whether the trade closed a new position or opened a new one.
    /// Applicable only if ContractMetadata.position_tracking is not POSITION_TRACKING_TYPE_NET_POSITION.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsClose {
      get { if ((_hasBits0 & 256) != 0) { return isClose_; } else { return IsCloseDefaultValue; } }
      set {
        _hasBits0 |= 256;
        isClose_ = value;
      }
    }
    /// <summary>Gets whether the "is_close" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsClose {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "is_close" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsClose() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "speculation_type" field.</summary>
    public const int SpeculationTypeFieldNumber = 11;
    private readonly static uint SpeculationTypeDefaultValue = 0;

    private uint speculationType_;
    /// <summary>
    /// Speculation type of the trade. One of SpeculationType enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SpeculationType {
      get { if ((_hasBits0 & 512) != 0) { return speculationType_; } else { return SpeculationTypeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        speculationType_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSpeculationType {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSpeculationType() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MatchedTrade);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MatchedTrade other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uint32Qty != other.Uint32Qty) return false;
      if (!object.Equals(Qty, other.Qty)) return false;
      if (IsShort != other.IsShort) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Price, other.Price)) return false;
      if (TradeDate != other.TradeDate) return false;
      if (StatementDate != other.StatementDate) return false;
      if (TradeUtcTime != other.TradeUtcTime) return false;
      if (!object.Equals(TradeUtcTimestamp, other.TradeUtcTimestamp)) return false;
      if (IsAggregated != other.IsAggregated) return false;
      if (IsYesterday != other.IsYesterday) return false;
      if (IsClose != other.IsClose) return false;
      if (SpeculationType != other.SpeculationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUint32Qty) hash ^= Uint32Qty.GetHashCode();
      if (qty_ != null) hash ^= Qty.GetHashCode();
      if (HasIsShort) hash ^= IsShort.GetHashCode();
      if (HasPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Price);
      if (HasTradeDate) hash ^= TradeDate.GetHashCode();
      if (HasStatementDate) hash ^= StatementDate.GetHashCode();
      if (HasTradeUtcTime) hash ^= TradeUtcTime.GetHashCode();
      if (tradeUtcTimestamp_ != null) hash ^= TradeUtcTimestamp.GetHashCode();
      if (HasIsAggregated) hash ^= IsAggregated.GetHashCode();
      if (HasIsYesterday) hash ^= IsYesterday.GetHashCode();
      if (HasIsClose) hash ^= IsClose.GetHashCode();
      if (HasSpeculationType) hash ^= SpeculationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUint32Qty) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasIsShort) {
        output.WriteRawTag(16);
        output.WriteBool(IsShort);
      }
      if (HasPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(Price);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(72);
        output.WriteBool(IsYesterday);
      }
      if (HasIsClose) {
        output.WriteRawTag(80);
        output.WriteBool(IsClose);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUint32Qty) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasIsShort) {
        output.WriteRawTag(16);
        output.WriteBool(IsShort);
      }
      if (HasPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(Price);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(72);
        output.WriteBool(IsYesterday);
      }
      if (HasIsClose) {
        output.WriteRawTag(80);
        output.WriteBool(IsClose);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasUint32Qty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32Qty);
      }
      if (qty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Qty);
      }
      if (HasIsShort) {
        size += 1 + 1;
      }
      if (HasPrice) {
        size += 1 + 8;
      }
      if (HasTradeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeDate);
      }
      if (HasStatementDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(StatementDate);
      }
      if (HasTradeUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeUtcTime);
      }
      if (tradeUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TradeUtcTimestamp);
      }
      if (HasIsAggregated) {
        size += 1 + 1;
      }
      if (HasIsYesterday) {
        size += 1 + 1;
      }
      if (HasIsClose) {
        size += 1 + 1;
      }
      if (HasSpeculationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpeculationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MatchedTrade other) {
      if (other == null) {
        return;
      }
      if (other.HasUint32Qty) {
        Uint32Qty = other.Uint32Qty;
      }
      if (other.qty_ != null) {
        if (qty_ == null) {
          Qty = new global::Cqg.Decimal();
        }
        Qty.MergeFrom(other.Qty);
      }
      if (other.HasIsShort) {
        IsShort = other.IsShort;
      }
      if (other.HasPrice) {
        Price = other.Price;
      }
      if (other.HasTradeDate) {
        TradeDate = other.TradeDate;
      }
      if (other.HasStatementDate) {
        StatementDate = other.StatementDate;
      }
      if (other.HasTradeUtcTime) {
        TradeUtcTime = other.TradeUtcTime;
      }
      if (other.tradeUtcTimestamp_ != null) {
        if (tradeUtcTimestamp_ == null) {
          TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        TradeUtcTimestamp.MergeFrom(other.TradeUtcTimestamp);
      }
      if (other.HasIsAggregated) {
        IsAggregated = other.IsAggregated;
      }
      if (other.HasIsYesterday) {
        IsYesterday = other.IsYesterday;
      }
      if (other.HasIsClose) {
        IsClose = other.IsClose;
      }
      if (other.HasSpeculationType) {
        SpeculationType = other.SpeculationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 16: {
            IsShort = input.ReadBool();
            break;
          }
          case 25: {
            Price = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 80: {
            IsClose = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 16: {
            IsShort = input.ReadBool();
            break;
          }
          case 25: {
            Price = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 80: {
            IsClose = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Status of the collateral for a specific account.
  /// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CollateralStatus : pb::IMessage<CollateralStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CollateralStatus> _parser = new pb::MessageParser<CollateralStatus>(() => new CollateralStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CollateralStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CollateralStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CollateralStatus(CollateralStatus other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionIds_ = other.subscriptionIds_.Clone();
      isSnapshot_ = other.isSnapshot_;
      accountId_ = other.accountId_;
      currency_ = other.currency_;
      totalMargin_ = other.totalMargin_;
      positionMargin_ = other.positionMargin_;
      purchasingPower_ = other.purchasingPower_;
      ote_ = other.ote_;
      mvo_ = other.mvo_;
      mvf_ = other.mvf_;
      marginCredit_ = other.marginCredit_;
      statusUtcTimestamp_ = other.statusUtcTimestamp_ != null ? other.statusUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CollateralStatus Clone() {
      return new CollateralStatus(this);
    }

    /// <summary>Field number for the "subscription_ids" field.</summary>
    public const int SubscriptionIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionIds_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> subscriptionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of trade subscription IDs this status is related to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> SubscriptionIds {
      get { return subscriptionIds_; }
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 2;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// True if this is a snapshot related message.
    /// Since snapshot might be sent in several messages (including none),
    /// client should use TradeSnapshotCompletion message as
    /// an indicator of complete snapshot delivery for a particular subscription.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 1) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 3;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account id of this status.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 4;
    private readonly static string CurrencyDefaultValue = "";

    private string currency_;
    /// <summary>
    /// Currency code of margin and PP values (ISO 4217 based).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Currency {
      get { return currency_ ?? CurrencyDefaultValue; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "currency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCurrency {
      get { return currency_ != null; }
    }
    /// <summary>Clears the value of the "currency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCurrency() {
      currency_ = null;
    }

    /// <summary>Field number for the "total_margin" field.</summary>
    public const int TotalMarginFieldNumber = 5;
    private readonly static double TotalMarginDefaultValue = 0D;

    private double totalMargin_;
    /// <summary>
    /// Margin requirement calculated for worst-case based on open positions and working orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double TotalMargin {
      get { if ((_hasBits0 & 4) != 0) { return totalMargin_; } else { return TotalMarginDefaultValue; } }
      set {
        _hasBits0 |= 4;
        totalMargin_ = value;
      }
    }
    /// <summary>Gets whether the "total_margin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTotalMargin {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "total_margin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTotalMargin() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "position_margin" field.</summary>
    public const int PositionMarginFieldNumber = 11;
    private readonly static double PositionMarginDefaultValue = 0D;

    private double positionMargin_;
    /// <summary>
    /// Margin requirement based on current positions only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PositionMargin {
      get { if ((_hasBits0 & 256) != 0) { return positionMargin_; } else { return PositionMarginDefaultValue; } }
      set {
        _hasBits0 |= 256;
        positionMargin_ = value;
      }
    }
    /// <summary>Gets whether the "position_margin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPositionMargin {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "position_margin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPositionMargin() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "purchasing_power" field.</summary>
    public const int PurchasingPowerFieldNumber = 6;
    private readonly static double PurchasingPowerDefaultValue = 0D;

    private double purchasingPower_;
    /// <summary>
    /// Available account funds including balance, realized profit (or loss), collateral and credits.
    /// OTE and MVO are included regarding the account risk parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PurchasingPower {
      get { if ((_hasBits0 & 8) != 0) { return purchasingPower_; } else { return PurchasingPowerDefaultValue; } }
      set {
        _hasBits0 |= 8;
        purchasingPower_ = value;
      }
    }
    /// <summary>Gets whether the "purchasing_power" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPurchasingPower {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "purchasing_power" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPurchasingPower() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "ote" field.</summary>
    public const int OteFieldNumber = 7;
    private readonly static double OteDefaultValue = 0D;

    private double ote_;
    /// <summary>
    /// Open trade equity, or potential profit (or loss) from futures and future-style options positions
    /// based on opening price of the position and the current future trade/best bid/best ask
    /// (regarding to the risk account settings) or settlement price if trade is not available.
    /// Included if purchasing power depends on it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Ote {
      get { if ((_hasBits0 & 16) != 0) { return ote_; } else { return OteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        ote_ = value;
      }
    }
    /// <summary>Gets whether the "ote" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "ote" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "mvo" field.</summary>
    public const int MvoFieldNumber = 8;
    private readonly static double MvoDefaultValue = 0D;

    private double mvo_;
    /// <summary>
    /// Market value of options calculated as the current market trade/best bid/best ask of the option
    /// (regarding to the risk account settings) times the number of options
    /// (positive for long options and negative for short options) in the portfolio.
    /// Included if purchasing power depends on it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Mvo {
      get { if ((_hasBits0 & 32) != 0) { return mvo_; } else { return MvoDefaultValue; } }
      set {
        _hasBits0 |= 32;
        mvo_ = value;
      }
    }
    /// <summary>Gets whether the "mvo" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMvo {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "mvo" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMvo() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "mvf" field.</summary>
    public const int MvfFieldNumber = 10;
    private readonly static double MvfDefaultValue = 0D;

    private double mvf_;
    /// <summary>
    /// Market value of futures calculated as the current market trade/best bid/best ask
    /// (regarding to the risk account settings) times the number of futures
    /// (positive for long and negative for short) in the portfolio.
    /// Included if applicable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Mvf {
      get { if ((_hasBits0 & 128) != 0) { return mvf_; } else { return MvfDefaultValue; } }
      set {
        _hasBits0 |= 128;
        mvf_ = value;
      }
    }
    /// <summary>Gets whether the "mvf" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMvf {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "mvf" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMvf() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "margin_credit" field.</summary>
    public const int MarginCreditFieldNumber = 9;
    private readonly static double MarginCreditDefaultValue = 0D;

    private double marginCredit_;
    /// <summary>
    /// Allowable margin credit of the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double MarginCredit {
      get { if ((_hasBits0 & 64) != 0) { return marginCredit_; } else { return MarginCreditDefaultValue; } }
      set {
        _hasBits0 |= 64;
        marginCredit_ = value;
      }
    }
    /// <summary>Gets whether the "margin_credit" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMarginCredit {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "margin_credit" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMarginCredit() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "status_utc_timestamp" field.</summary>
    public const int StatusUtcTimestampFieldNumber = 12;
    private global::Google.Protobuf.Timestamp statusUtcTimestamp_;
    /// <summary>
    /// UTC server time (including date) when the status was formed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp StatusUtcTimestamp {
      get { return statusUtcTimestamp_; }
      set {
        statusUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CollateralStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CollateralStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!subscriptionIds_.Equals(other.subscriptionIds_)) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if (AccountId != other.AccountId) return false;
      if (Currency != other.Currency) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TotalMargin, other.TotalMargin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PositionMargin, other.PositionMargin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PurchasingPower, other.PurchasingPower)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Ote, other.Ote)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Mvo, other.Mvo)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Mvf, other.Mvf)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MarginCredit, other.MarginCredit)) return false;
      if (!object.Equals(StatusUtcTimestamp, other.StatusUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= subscriptionIds_.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasCurrency) hash ^= Currency.GetHashCode();
      if (HasTotalMargin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TotalMargin);
      if (HasPositionMargin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PositionMargin);
      if (HasPurchasingPower) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PurchasingPower);
      if (HasOte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Ote);
      if (HasMvo) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Mvo);
      if (HasMvf) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Mvf);
      if (HasMarginCredit) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MarginCredit);
      if (statusUtcTimestamp_ != null) hash ^= StatusUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      subscriptionIds_.WriteTo(output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasCurrency) {
        output.WriteRawTag(34);
        output.WriteString(Currency);
      }
      if (HasTotalMargin) {
        output.WriteRawTag(41);
        output.WriteDouble(TotalMargin);
      }
      if (HasPurchasingPower) {
        output.WriteRawTag(49);
        output.WriteDouble(PurchasingPower);
      }
      if (HasOte) {
        output.WriteRawTag(57);
        output.WriteDouble(Ote);
      }
      if (HasMvo) {
        output.WriteRawTag(65);
        output.WriteDouble(Mvo);
      }
      if (HasMarginCredit) {
        output.WriteRawTag(73);
        output.WriteDouble(MarginCredit);
      }
      if (HasMvf) {
        output.WriteRawTag(81);
        output.WriteDouble(Mvf);
      }
      if (HasPositionMargin) {
        output.WriteRawTag(89);
        output.WriteDouble(PositionMargin);
      }
      if (statusUtcTimestamp_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(StatusUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      subscriptionIds_.WriteTo(ref output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasCurrency) {
        output.WriteRawTag(34);
        output.WriteString(Currency);
      }
      if (HasTotalMargin) {
        output.WriteRawTag(41);
        output.WriteDouble(TotalMargin);
      }
      if (HasPurchasingPower) {
        output.WriteRawTag(49);
        output.WriteDouble(PurchasingPower);
      }
      if (HasOte) {
        output.WriteRawTag(57);
        output.WriteDouble(Ote);
      }
      if (HasMvo) {
        output.WriteRawTag(65);
        output.WriteDouble(Mvo);
      }
      if (HasMarginCredit) {
        output.WriteRawTag(73);
        output.WriteDouble(MarginCredit);
      }
      if (HasMvf) {
        output.WriteRawTag(81);
        output.WriteDouble(Mvf);
      }
      if (HasPositionMargin) {
        output.WriteRawTag(89);
        output.WriteDouble(PositionMargin);
      }
      if (statusUtcTimestamp_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(StatusUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += subscriptionIds_.CalculateSize(_repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasCurrency) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (HasTotalMargin) {
        size += 1 + 8;
      }
      if (HasPositionMargin) {
        size += 1 + 8;
      }
      if (HasPurchasingPower) {
        size += 1 + 8;
      }
      if (HasOte) {
        size += 1 + 8;
      }
      if (HasMvo) {
        size += 1 + 8;
      }
      if (HasMvf) {
        size += 1 + 8;
      }
      if (HasMarginCredit) {
        size += 1 + 8;
      }
      if (statusUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StatusUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CollateralStatus other) {
      if (other == null) {
        return;
      }
      subscriptionIds_.Add(other.subscriptionIds_);
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasCurrency) {
        Currency = other.Currency;
      }
      if (other.HasTotalMargin) {
        TotalMargin = other.TotalMargin;
      }
      if (other.HasPositionMargin) {
        PositionMargin = other.PositionMargin;
      }
      if (other.HasPurchasingPower) {
        PurchasingPower = other.PurchasingPower;
      }
      if (other.HasOte) {
        Ote = other.Ote;
      }
      if (other.HasMvo) {
        Mvo = other.Mvo;
      }
      if (other.HasMvf) {
        Mvf = other.Mvf;
      }
      if (other.HasMarginCredit) {
        MarginCredit = other.MarginCredit;
      }
      if (other.statusUtcTimestamp_ != null) {
        if (statusUtcTimestamp_ == null) {
          StatusUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        StatusUtcTimestamp.MergeFrom(other.StatusUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 34: {
            Currency = input.ReadString();
            break;
          }
          case 41: {
            TotalMargin = input.ReadDouble();
            break;
          }
          case 49: {
            PurchasingPower = input.ReadDouble();
            break;
          }
          case 57: {
            Ote = input.ReadDouble();
            break;
          }
          case 65: {
            Mvo = input.ReadDouble();
            break;
          }
          case 73: {
            MarginCredit = input.ReadDouble();
            break;
          }
          case 81: {
            Mvf = input.ReadDouble();
            break;
          }
          case 89: {
            PositionMargin = input.ReadDouble();
            break;
          }
          case 98: {
            if (statusUtcTimestamp_ == null) {
              StatusUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(StatusUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(ref input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 34: {
            Currency = input.ReadString();
            break;
          }
          case 41: {
            TotalMargin = input.ReadDouble();
            break;
          }
          case 49: {
            PurchasingPower = input.ReadDouble();
            break;
          }
          case 57: {
            Ote = input.ReadDouble();
            break;
          }
          case 65: {
            Mvo = input.ReadDouble();
            break;
          }
          case 73: {
            MarginCredit = input.ReadDouble();
            break;
          }
          case 81: {
            Mvf = input.ReadDouble();
            break;
          }
          case 89: {
            PositionMargin = input.ReadDouble();
            break;
          }
          case 98: {
            if (statusUtcTimestamp_ == null) {
              StatusUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(StatusUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Historical orders request.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HistoricalOrdersRequest : pb::IMessage<HistoricalOrdersRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HistoricalOrdersRequest> _parser = new pb::MessageParser<HistoricalOrdersRequest>(() => new HistoricalOrdersRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HistoricalOrdersRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersRequest(HistoricalOrdersRequest other) : this() {
      _hasBits0 = other._hasBits0;
      fromDate_ = other.fromDate_;
      toDate_ = other.toDate_;
      accountIds_ = other.accountIds_.Clone();
      includeCrossOrders_ = other.includeCrossOrders_;
      orderSnapshotFilter_ = other.orderSnapshotFilter_ != null ? other.orderSnapshotFilter_.Clone() : null;
      maxOrderStatusCount_ = other.maxOrderStatusCount_;
      maxTransactionStatusCount_ = other.maxTransactionStatusCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersRequest Clone() {
      return new HistoricalOrdersRequest(this);
    }

    /// <summary>Field number for the "from_date" field.</summary>
    public const int FromDateFieldNumber = 1;
    private readonly static long FromDateDefaultValue = 0L;

    private long fromDate_;
    /// <summary>
    /// Only orders from specified business date (inclusively) is to be returned (date only value in time format).
    /// Note: Starting date must not be more than 30 days back from now.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long FromDate {
      get { if ((_hasBits0 & 1) != 0) { return fromDate_; } else { return FromDateDefaultValue; } }
      set {
        _hasBits0 |= 1;
        fromDate_ = value;
      }
    }
    /// <summary>Gets whether the "from_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFromDate {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "from_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFromDate() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "to_date" field.</summary>
    public const int ToDateFieldNumber = 2;
    private readonly static long ToDateDefaultValue = 0L;

    private long toDate_;
    /// <summary>
    /// Only orders till specified business date (inclusively) is to be returned (date only value in time format).
    /// Current business day if the field is omitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ToDate {
      get { if ((_hasBits0 & 2) != 0) { return toDate_; } else { return ToDateDefaultValue; } }
      set {
        _hasBits0 |= 2;
        toDate_ = value;
      }
    }
    /// <summary>Gets whether the "to_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasToDate {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "to_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearToDate() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "account_ids" field.</summary>
    public const int AccountIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_accountIds_codec
        = pb::FieldCodec.ForSInt32(24);
    private readonly pbc::RepeatedField<int> accountIds_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Filter orders by account. It is required to leave account_ids list empty to select all accounts of the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> AccountIds {
      get { return accountIds_; }
    }

    /// <summary>Field number for the "include_cross_orders" field.</summary>
    public const int IncludeCrossOrdersFieldNumber = 4;
    private readonly static bool IncludeCrossOrdersDefaultValue = false;

    private bool includeCrossOrders_;
    /// <summary>
    /// If this field set to true, statuses on orders with ORDER_TYPE_CROSS type will be
    /// included into responses. See CrossOrderParameters message.
    /// Note that order statuses with cross order type are excluded only if 
    /// include_cross_orders set to false (or empty) and ORDER_TYPE_CROSS type is not included 
    /// into order_snapshot_filter.order_types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeCrossOrders {
      get { if ((_hasBits0 & 4) != 0) { return includeCrossOrders_; } else { return IncludeCrossOrdersDefaultValue; } }
      set {
        _hasBits0 |= 4;
        includeCrossOrders_ = value;
      }
    }
    /// <summary>Gets whether the "include_cross_orders" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIncludeCrossOrders {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "include_cross_orders" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIncludeCrossOrders() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "order_snapshot_filter" field.</summary>
    public const int OrderSnapshotFilterFieldNumber = 5;
    private global::TradeRouting2.OrderSnapshotFilter orderSnapshotFilter_;
    /// <summary>
    /// Only order statuses, transaction statuses that match the filter are included in a report.
    /// By default no filtration is done by the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TradeRouting2.OrderSnapshotFilter OrderSnapshotFilter {
      get { return orderSnapshotFilter_; }
      set {
        orderSnapshotFilter_ = value;
      }
    }

    /// <summary>Field number for the "max_order_status_count" field.</summary>
    public const int MaxOrderStatusCountFieldNumber = 6;
    private readonly static uint MaxOrderStatusCountDefaultValue = 0;

    private uint maxOrderStatusCount_;
    /// <summary>
    /// No more than specified number of order statuses will be returned.
    /// Zero or omitted means no limit.
    /// If there are more order statuses than specified, HistoricalOrdersReport.order_status_limit_reached is set in true
    /// in last report for the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxOrderStatusCount {
      get { if ((_hasBits0 & 8) != 0) { return maxOrderStatusCount_; } else { return MaxOrderStatusCountDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxOrderStatusCount_ = value;
      }
    }
    /// <summary>Gets whether the "max_order_status_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxOrderStatusCount {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_order_status_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxOrderStatusCount() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "max_transaction_status_count" field.</summary>
    public const int MaxTransactionStatusCountFieldNumber = 7;
    private readonly static uint MaxTransactionStatusCountDefaultValue = 0;

    private uint maxTransactionStatusCount_;
    /// <summary>
    /// No more than specified number of transaction statuses within all order statuses will be returned.
    /// Zero or omitted means no limit.
    /// If there are more transaction statuses than specified, HistoricalOrdersReport.transaction_status_limit_reached
    /// is set in true in last report for the request.
    /// Note: Limitation is aligned on order status. So, if next order status transaction count leads to limit violation
    /// whole order status is not included into the report.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxTransactionStatusCount {
      get { if ((_hasBits0 & 16) != 0) { return maxTransactionStatusCount_; } else { return MaxTransactionStatusCountDefaultValue; } }
      set {
        _hasBits0 |= 16;
        maxTransactionStatusCount_ = value;
      }
    }
    /// <summary>Gets whether the "max_transaction_status_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxTransactionStatusCount {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "max_transaction_status_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxTransactionStatusCount() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HistoricalOrdersRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HistoricalOrdersRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FromDate != other.FromDate) return false;
      if (ToDate != other.ToDate) return false;
      if(!accountIds_.Equals(other.accountIds_)) return false;
      if (IncludeCrossOrders != other.IncludeCrossOrders) return false;
      if (!object.Equals(OrderSnapshotFilter, other.OrderSnapshotFilter)) return false;
      if (MaxOrderStatusCount != other.MaxOrderStatusCount) return false;
      if (MaxTransactionStatusCount != other.MaxTransactionStatusCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasFromDate) hash ^= FromDate.GetHashCode();
      if (HasToDate) hash ^= ToDate.GetHashCode();
      hash ^= accountIds_.GetHashCode();
      if (HasIncludeCrossOrders) hash ^= IncludeCrossOrders.GetHashCode();
      if (orderSnapshotFilter_ != null) hash ^= OrderSnapshotFilter.GetHashCode();
      if (HasMaxOrderStatusCount) hash ^= MaxOrderStatusCount.GetHashCode();
      if (HasMaxTransactionStatusCount) hash ^= MaxTransactionStatusCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasFromDate) {
        output.WriteRawTag(8);
        output.WriteSInt64(FromDate);
      }
      if (HasToDate) {
        output.WriteRawTag(16);
        output.WriteSInt64(ToDate);
      }
      accountIds_.WriteTo(output, _repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(32);
        output.WriteBool(IncludeCrossOrders);
      }
      if (orderSnapshotFilter_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(OrderSnapshotFilter);
      }
      if (HasMaxOrderStatusCount) {
        output.WriteRawTag(48);
        output.WriteUInt32(MaxOrderStatusCount);
      }
      if (HasMaxTransactionStatusCount) {
        output.WriteRawTag(56);
        output.WriteUInt32(MaxTransactionStatusCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasFromDate) {
        output.WriteRawTag(8);
        output.WriteSInt64(FromDate);
      }
      if (HasToDate) {
        output.WriteRawTag(16);
        output.WriteSInt64(ToDate);
      }
      accountIds_.WriteTo(ref output, _repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(32);
        output.WriteBool(IncludeCrossOrders);
      }
      if (orderSnapshotFilter_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(OrderSnapshotFilter);
      }
      if (HasMaxOrderStatusCount) {
        output.WriteRawTag(48);
        output.WriteUInt32(MaxOrderStatusCount);
      }
      if (HasMaxTransactionStatusCount) {
        output.WriteRawTag(56);
        output.WriteUInt32(MaxTransactionStatusCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasFromDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(FromDate);
      }
      if (HasToDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(ToDate);
      }
      size += accountIds_.CalculateSize(_repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        size += 1 + 1;
      }
      if (orderSnapshotFilter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrderSnapshotFilter);
      }
      if (HasMaxOrderStatusCount) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxOrderStatusCount);
      }
      if (HasMaxTransactionStatusCount) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxTransactionStatusCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HistoricalOrdersRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasFromDate) {
        FromDate = other.FromDate;
      }
      if (other.HasToDate) {
        ToDate = other.ToDate;
      }
      accountIds_.Add(other.accountIds_);
      if (other.HasIncludeCrossOrders) {
        IncludeCrossOrders = other.IncludeCrossOrders;
      }
      if (other.orderSnapshotFilter_ != null) {
        if (orderSnapshotFilter_ == null) {
          OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
        }
        OrderSnapshotFilter.MergeFrom(other.OrderSnapshotFilter);
      }
      if (other.HasMaxOrderStatusCount) {
        MaxOrderStatusCount = other.MaxOrderStatusCount;
      }
      if (other.HasMaxTransactionStatusCount) {
        MaxTransactionStatusCount = other.MaxTransactionStatusCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            FromDate = input.ReadSInt64();
            break;
          }
          case 16: {
            ToDate = input.ReadSInt64();
            break;
          }
          case 26:
          case 24: {
            accountIds_.AddEntriesFrom(input, _repeated_accountIds_codec);
            break;
          }
          case 32: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
          case 42: {
            if (orderSnapshotFilter_ == null) {
              OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
            }
            input.ReadMessage(OrderSnapshotFilter);
            break;
          }
          case 48: {
            MaxOrderStatusCount = input.ReadUInt32();
            break;
          }
          case 56: {
            MaxTransactionStatusCount = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            FromDate = input.ReadSInt64();
            break;
          }
          case 16: {
            ToDate = input.ReadSInt64();
            break;
          }
          case 26:
          case 24: {
            accountIds_.AddEntriesFrom(ref input, _repeated_accountIds_codec);
            break;
          }
          case 32: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
          case 42: {
            if (orderSnapshotFilter_ == null) {
              OrderSnapshotFilter = new global::TradeRouting2.OrderSnapshotFilter();
            }
            input.ReadMessage(OrderSnapshotFilter);
            break;
          }
          case 48: {
            MaxOrderStatusCount = input.ReadUInt32();
            break;
          }
          case 56: {
            MaxTransactionStatusCount = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Response for historical orders request.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HistoricalOrdersReport : pb::IMessage<HistoricalOrdersReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HistoricalOrdersReport> _parser = new pb::MessageParser<HistoricalOrdersReport>(() => new HistoricalOrdersReport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HistoricalOrdersReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersReport(HistoricalOrdersReport other) : this() {
      _hasBits0 = other._hasBits0;
      orderStatuses_ = other.orderStatuses_.Clone();
      orderStatusLimitReached_ = other.orderStatusLimitReached_;
      transactionStatusLimitReached_ = other.transactionStatusLimitReached_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistoricalOrdersReport Clone() {
      return new HistoricalOrdersReport(this);
    }

    /// <summary>Field number for the "order_statuses" field.</summary>
    public const int OrderStatusesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Order2.OrderStatus> _repeated_orderStatuses_codec
        = pb::FieldCodec.ForMessage(10, global::Order2.OrderStatus.Parser);
    private readonly pbc::RepeatedField<global::Order2.OrderStatus> orderStatuses_ = new pbc::RepeatedField<global::Order2.OrderStatus>();
    /// <summary>
    /// List of order statuses matching historical order filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Order2.OrderStatus> OrderStatuses {
      get { return orderStatuses_; }
    }

    /// <summary>Field number for the "order_status_limit_reached" field.</summary>
    public const int OrderStatusLimitReachedFieldNumber = 2;
    private readonly static bool OrderStatusLimitReachedDefaultValue = false;

    private bool orderStatusLimitReached_;
    /// <summary>
    /// Indicator that not all order statuses are returned. 
    /// Limit by HistoricalOrdersRequest.max_order_status_count is reached.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OrderStatusLimitReached {
      get { if ((_hasBits0 & 1) != 0) { return orderStatusLimitReached_; } else { return OrderStatusLimitReachedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        orderStatusLimitReached_ = value;
      }
    }
    /// <summary>Gets whether the "order_status_limit_reached" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderStatusLimitReached {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "order_status_limit_reached" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderStatusLimitReached() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "transaction_status_limit_reached" field.</summary>
    public const int TransactionStatusLimitReachedFieldNumber = 3;
    private readonly static bool TransactionStatusLimitReachedDefaultValue = false;

    private bool transactionStatusLimitReached_;
    /// <summary>
    /// Indicator that not all order statuses are returned. 
    /// Limit by HistoricalOrdersRequest.max_transaction_status_count is reached.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TransactionStatusLimitReached {
      get { if ((_hasBits0 & 2) != 0) { return transactionStatusLimitReached_; } else { return TransactionStatusLimitReachedDefaultValue; } }
      set {
        _hasBits0 |= 2;
        transactionStatusLimitReached_ = value;
      }
    }
    /// <summary>Gets whether the "transaction_status_limit_reached" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTransactionStatusLimitReached {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "transaction_status_limit_reached" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTransactionStatusLimitReached() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HistoricalOrdersReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HistoricalOrdersReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!orderStatuses_.Equals(other.orderStatuses_)) return false;
      if (OrderStatusLimitReached != other.OrderStatusLimitReached) return false;
      if (TransactionStatusLimitReached != other.TransactionStatusLimitReached) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= orderStatuses_.GetHashCode();
      if (HasOrderStatusLimitReached) hash ^= OrderStatusLimitReached.GetHashCode();
      if (HasTransactionStatusLimitReached) hash ^= TransactionStatusLimitReached.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      orderStatuses_.WriteTo(output, _repeated_orderStatuses_codec);
      if (HasOrderStatusLimitReached) {
        output.WriteRawTag(16);
        output.WriteBool(OrderStatusLimitReached);
      }
      if (HasTransactionStatusLimitReached) {
        output.WriteRawTag(24);
        output.WriteBool(TransactionStatusLimitReached);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      orderStatuses_.WriteTo(ref output, _repeated_orderStatuses_codec);
      if (HasOrderStatusLimitReached) {
        output.WriteRawTag(16);
        output.WriteBool(OrderStatusLimitReached);
      }
      if (HasTransactionStatusLimitReached) {
        output.WriteRawTag(24);
        output.WriteBool(TransactionStatusLimitReached);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += orderStatuses_.CalculateSize(_repeated_orderStatuses_codec);
      if (HasOrderStatusLimitReached) {
        size += 1 + 1;
      }
      if (HasTransactionStatusLimitReached) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HistoricalOrdersReport other) {
      if (other == null) {
        return;
      }
      orderStatuses_.Add(other.orderStatuses_);
      if (other.HasOrderStatusLimitReached) {
        OrderStatusLimitReached = other.OrderStatusLimitReached;
      }
      if (other.HasTransactionStatusLimitReached) {
        TransactionStatusLimitReached = other.TransactionStatusLimitReached;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            orderStatuses_.AddEntriesFrom(input, _repeated_orderStatuses_codec);
            break;
          }
          case 16: {
            OrderStatusLimitReached = input.ReadBool();
            break;
          }
          case 24: {
            TransactionStatusLimitReached = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            orderStatuses_.AddEntriesFrom(ref input, _repeated_orderStatuses_codec);
            break;
          }
          case 16: {
            OrderStatusLimitReached = input.ReadBool();
            break;
          }
          case 24: {
            TransactionStatusLimitReached = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request for trading feature entitlements.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BrokerageTradingFeatureEntitlementRequest : pb::IMessage<BrokerageTradingFeatureEntitlementRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BrokerageTradingFeatureEntitlementRequest> _parser = new pb::MessageParser<BrokerageTradingFeatureEntitlementRequest>(() => new BrokerageTradingFeatureEntitlementRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BrokerageTradingFeatureEntitlementRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementRequest(BrokerageTradingFeatureEntitlementRequest other) : this() {
      accountIds_ = other.accountIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementRequest Clone() {
      return new BrokerageTradingFeatureEntitlementRequest(this);
    }

    /// <summary>Field number for the "account_ids" field.</summary>
    public const int AccountIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_accountIds_codec
        = pb::FieldCodec.ForSInt32(8);
    private readonly pbc::RepeatedField<int> accountIds_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Account ID in CQG trade routing system.
    /// If no account supplied, data is returned for ALL accounts trader is authorized on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> AccountIds {
      get { return accountIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BrokerageTradingFeatureEntitlementRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BrokerageTradingFeatureEntitlementRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!accountIds_.Equals(other.accountIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= accountIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      accountIds_.WriteTo(output, _repeated_accountIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      accountIds_.WriteTo(ref output, _repeated_accountIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += accountIds_.CalculateSize(_repeated_accountIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BrokerageTradingFeatureEntitlementRequest other) {
      if (other == null) {
        return;
      }
      accountIds_.Add(other.accountIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            accountIds_.AddEntriesFrom(input, _repeated_accountIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            accountIds_.AddEntriesFrom(ref input, _repeated_accountIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Report with trading feature entitlements.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BrokerageTradingFeatureEntitlementReport : pb::IMessage<BrokerageTradingFeatureEntitlementReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BrokerageTradingFeatureEntitlementReport> _parser = new pb::MessageParser<BrokerageTradingFeatureEntitlementReport>(() => new BrokerageTradingFeatureEntitlementReport());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BrokerageTradingFeatureEntitlementReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementReport(BrokerageTradingFeatureEntitlementReport other) : this() {
      tradingFeatureEntitlements_ = other.tradingFeatureEntitlements_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BrokerageTradingFeatureEntitlementReport Clone() {
      return new BrokerageTradingFeatureEntitlementReport(this);
    }

    /// <summary>Field number for the "trading_feature_entitlements" field.</summary>
    public const int TradingFeatureEntitlementsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TradeRouting2.TradingFeatureEntitlementEntry> _repeated_tradingFeatureEntitlements_codec
        = pb::FieldCodec.ForMessage(10, global::TradeRouting2.TradingFeatureEntitlementEntry.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.TradingFeatureEntitlementEntry> tradingFeatureEntitlements_ = new pbc::RepeatedField<global::TradeRouting2.TradingFeatureEntitlementEntry>();
    /// <summary>
    /// Set of trading feature entitlements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TradeRouting2.TradingFeatureEntitlementEntry> TradingFeatureEntitlements {
      get { return tradingFeatureEntitlements_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BrokerageTradingFeatureEntitlementReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BrokerageTradingFeatureEntitlementReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!tradingFeatureEntitlements_.Equals(other.tradingFeatureEntitlements_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= tradingFeatureEntitlements_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      tradingFeatureEntitlements_.WriteTo(output, _repeated_tradingFeatureEntitlements_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      tradingFeatureEntitlements_.WriteTo(ref output, _repeated_tradingFeatureEntitlements_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += tradingFeatureEntitlements_.CalculateSize(_repeated_tradingFeatureEntitlements_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BrokerageTradingFeatureEntitlementReport other) {
      if (other == null) {
        return;
      }
      tradingFeatureEntitlements_.Add(other.tradingFeatureEntitlements_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            tradingFeatureEntitlements_.AddEntriesFrom(input, _repeated_tradingFeatureEntitlements_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            tradingFeatureEntitlements_.AddEntriesFrom(ref input, _repeated_tradingFeatureEntitlements_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Account/brokerage-specific trading feature entitlement.
  /// For future compatibility unknown entitlements should be ignored.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TradingFeatureEntitlementEntry : pb::IMessage<TradingFeatureEntitlementEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradingFeatureEntitlementEntry> _parser = new pb::MessageParser<TradingFeatureEntitlementEntry>(() => new TradingFeatureEntitlementEntry());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TradingFeatureEntitlementEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradingFeatureEntitlementEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradingFeatureEntitlementEntry(TradingFeatureEntitlementEntry other) : this() {
      _hasBits0 = other._hasBits0;
      accountId_ = other.accountId_;
      entitlement_ = other.entitlement_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TradingFeatureEntitlementEntry Clone() {
      return new TradingFeatureEntitlementEntry(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account ID in CQG trade routing system that corresponds to trading feature entitlement.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 1) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "entitlement" field.</summary>
    public const int EntitlementFieldNumber = 2;
    private readonly static uint EntitlementDefaultValue = 0;

    private uint entitlement_;
    /// <summary>
    /// Trading feature entitlement.
    /// This field is associated with TradingFeatureEntitlement enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Entitlement {
      get { if ((_hasBits0 & 2) != 0) { return entitlement_; } else { return EntitlementDefaultValue; } }
      set {
        _hasBits0 |= 2;
        entitlement_ = value;
      }
    }
    /// <summary>Gets whether the "entitlement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEntitlement {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "entitlement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEntitlement() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TradingFeatureEntitlementEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TradingFeatureEntitlementEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccountId != other.AccountId) return false;
      if (Entitlement != other.Entitlement) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasEntitlement) hash ^= Entitlement.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasEntitlement) {
        output.WriteRawTag(16);
        output.WriteUInt32(Entitlement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasEntitlement) {
        output.WriteRawTag(16);
        output.WriteUInt32(Entitlement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasEntitlement) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Entitlement);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TradingFeatureEntitlementEntry other) {
      if (other == null) {
        return;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasEntitlement) {
        Entitlement = other.Entitlement;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 16: {
            Entitlement = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 16: {
            Entitlement = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
