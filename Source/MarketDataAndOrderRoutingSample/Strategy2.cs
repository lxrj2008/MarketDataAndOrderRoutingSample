// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/strategy_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Strategy2 {

  /// <summary>Holder for reflection information generated from WebAPI/strategy_2.proto</summary>
  public static partial class Strategy2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/strategy_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static Strategy2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdXZWJBUEkvc3RyYXRlZ3lfMi5wcm90bxIKc3RyYXRlZ3lfMhoXV2ViQVBJ",
            "L21ldGFkYXRhXzIucHJvdG8aIldlYkFQSS9zdHJhdGVneV9kZWZpbml0aW9u",
            "XzIucHJvdG8aFGNvbW1vbi9kZWNpbWFsLnByb3RvGh9nb29nbGUvcHJvdG9i",
            "dWYvdGltZXN0YW1wLnByb3RvIjgKHUFsZ29TdHJhdGVneURlZmluaXRpb25S",
            "ZXF1ZXN0EhcKD2FsZ29fc3RyYXRlZ2llcxgBIAMoCSJwChxBbGdvU3RyYXRl",
            "Z3lEZWZpbml0aW9uUmVwb3J0ElAKGWFsZ29fc3RyYXRlZ3lfZGVmaW5pdGlv",
            "bnMYASADKAsyLS5zdHJhdGVneV9kZWZpbml0aW9uXzIuQWxnb1N0cmF0ZWd5",
            "RGVmaW5pdGlvbiJ3ChlTdHJhdGVneURlZmluaXRpb25SZXF1ZXN0EkYKE3N0",
            "cmF0ZWd5X2RlZmluaXRpb24YASACKAsyKS5zdHJhdGVneV9kZWZpbml0aW9u",
            "XzIuU3RyYXRlZ3lEZWZpbml0aW9uEhIKCmFjY291bnRfaWQYAiABKBEiUwoY",
            "U3RyYXRlZ3lEZWZpbml0aW9uUmVwb3J0EjcKEWNvbnRyYWN0X21ldGFkYXRh",
            "GAEgAigLMhwubWV0YWRhdGFfMi5Db250cmFjdE1ldGFkYXRhIk4KD1N0cmF0",
            "ZWd5TGVnRmlsbBIUCgxsZWdfb3JkZXJfaWQYASACKAkSGAoQbGVnX2V4ZWN1",
            "dGlvbl9pZBgCIAIoCRILCgNxdHkYAyACKAEicAoNU3ludGhldGljSGFuZxIP",
            "CgdoYW5nX2lkGAEgAigREhsKD3VpbnQzMl9odW5nX3F0eRgCIAEoDUICGAES",
            "HgoIaHVuZ19xdHkYBCABKAsyDC5jcWcuRGVjaW1hbBIRCglvcmRlcl9pZHMY",
            "AyADKAkirQEKG1N5bnRoZXRpY1N0cmF0ZWd5UHJvcGVydGllcxJKChtzdHJh",
            "dGVneV90cmFkaW5nX3BhcmFtZXRlcnMYASABKAsyJS5zdHJhdGVneV8yLlN0",
            "cmF0ZWd5VHJhZGluZ1BhcmFtZXRlcnMSFwoPb3JpZ2luX29yZGVyX2lkGAIg",
            "ASgJEhUKDXJvb3Rfb3JkZXJfaWQYAyABKAkSEgoKbm9kZV9pbmRleBgEIAEo",
            "DSKEAwoZU3RyYXRlZ3lUcmFkaW5nUGFyYW1ldGVycxJKChdtYXJrZXRfb3Jk",
            "ZXJfcGFyYW1ldGVycxgBIAMoCzIpLnN0cmF0ZWd5XzIuU3RyYXRlZ3lNYXJr",
            "ZXRPcmRlclBhcmFtZXRlcnMSSAoWbGltaXRfb3JkZXJfcGFyYW1ldGVycxgC",
            "IAMoCzIoLnN0cmF0ZWd5XzIuU3RyYXRlZ3lMaW1pdE9yZGVyUGFyYW1ldGVy",
            "cxJGChVzdG9wX29yZGVyX3BhcmFtZXRlcnMYAyADKAsyJy5zdHJhdGVneV8y",
            "LlN0cmF0ZWd5U3RvcE9yZGVyUGFyYW1ldGVycxJJChZhZ2dyZWdhdGlvbl9w",
            "YXJhbWV0ZXJzGAQgAygLMikuc3RyYXRlZ3lfMi5TdHJhdGVneUFnZ3JlZ2F0",
            "aW9uUGFyYW1ldGVycxI+Cg5sZWdfcGFyYW1ldGVycxgFIAMoCzImLnN0cmF0",
            "ZWd5XzIuU3RyYXRlZ3lPcmRlckxlZ1BhcmFtZXRlcnMifgoaU3RyYXRlZ3lP",
            "cmRlckxlZ1BhcmFtZXRlcnMSEgoKbm9kZV9pbmRleBgBIAIoDRISCgphY2Nv",
            "dW50X2lkGAIgASgREh4KFm9wZW5fY2xvc2VfaW5zdHJ1Y3Rpb24YAyABKA0S",
            "GAoQc3BlY3VsYXRpb25fdHlwZRgEIAEoDSJWCh1TdHJhdGVneU1hcmtldE9y",
            "ZGVyUGFyYW1ldGVycxISCgpub2RlX2luZGV4GAEgAigNEiEKGXJlcGxlbmlz",
            "aF9vbl9wcmltYXJ5X2ZpbGwYAiABKAgi8AQKHFN0cmF0ZWd5TGltaXRPcmRl",
            "clBhcmFtZXRlcnMSEgoKbm9kZV9pbmRleBgBIAIoDRIhChlyZXBsZW5pc2hf",
            "b25fcHJpbWFyeV9maWxsGAIgASgIEhUKDW92ZXJmaWxsX21vZGUYAyABKA0S",
            "HgoWYWxpZ25fdG9fc3RyYXRlZ3lfbG90cxgEIAEoDRIWCg5wcmljaW5nX21l",
            "dGhvZBgFIAEoDRIxCg5wcmljZV9zaGlmdGluZxgGIAEoCzIZLnN0cmF0ZWd5",
            "XzIuUHJpY2VTaGlmdGluZxI+ChBsZWdfZGVzY3JpcHRpb25zGAcgAygLMiQu",
            "c3RyYXRlZ3lfMi5MaW1pdE9yZGVyTGVnRGVzY3JpcHRpb24icAoMT3ZlcmZp",
            "bGxNb2RlEhgKFE9WRVJGSUxMX01PREVfTUFOVUFMEAESIwofT1ZFUkZJTExf",
            "TU9ERV9BVVRPTUFUSUNfSEVER0lORxACEiEKHU9WRVJGSUxMX01PREVfQVZP",
            "SURfT1ZFUkZJTExTEAMigQEKE0FsaWduVG9TdHJhdGVneUxvdHMSHwobQUxJ",
            "R05fVE9fU1RSQVRFR1lfTE9UU19OT05FEAESKQolQUxJR05fVE9fU1RSQVRF",
            "R1lfTE9UU19TRUNPTkRBUllfT05MWRACEh4KGkFMSUdOX1RPX1NUUkFURUdZ",
            "X0xPVFNfQUxMEAMiYQoNUHJpY2luZ01ldGhvZBIoCiRQUklDSU5HX01FVEhP",
            "RF9JTkRFUEVOREVOVF9MT1RfUFJJQ0UQARImCiJQUklDSU5HX01FVEhPRF9B",
            "VkVSQUdFX09SREVSX1BSSUNFEAIimQEKG1N0cmF0ZWd5U3RvcE9yZGVyUGFy",
            "YW1ldGVycxISCgpub2RlX2luZGV4GAEgAigNEhEKCXN0b3Bfc2lkZRgCIAIo",
            "DRIhChlyZXBsZW5pc2hfb25fcHJpbWFyeV9maWxsGAMgASgIIjAKCFN0b3BT",
            "aWRlEhEKDVNUT1BfU0lERV9CSUQQARIRCg1TVE9QX1NJREVfQVNLEAIizwIK",
            "HVN0cmF0ZWd5QWdncmVnYXRpb25QYXJhbWV0ZXJzEhIKCm5vZGVfaW5kZXgY",
            "ASACKA0SFQoNb3ZlcmZpbGxfbW9kZRgCIAIoDRIxCg5wcmljZV9zaGlmdGlu",
            "ZxgDIAEoCzIZLnN0cmF0ZWd5XzIuUHJpY2VTaGlmdGluZxI7CgxwYXR0ZXJu",
            "X2xlZ3MYBCADKAsyJS5zdHJhdGVneV8yLkFnZ3JlZ2F0aW9uTGVnRGVzY3Jp",
            "cHRpb24ikgEKEEFnZ3JPdmVyZmlsbE1vZGUSJgoiQUdHUl9PVkVSRklMTF9N",
            "T0RFX0FWT0lEX09WRVJGSUxMUxABEiYKIkFHR1JfT1ZFUkZJTExfTU9ERV9B",
            "Q0NFUFRfT1ZFUkZJTEwQAhIuCipBR0dSX09WRVJGSUxMX01PREVfUFJFU0VS",
            "VkVfUVVFVUVfUE9TSVRJT04QAyKKAgoZQWdncmVnYXRpb25MZWdEZXNjcmlw",
            "dGlvbhISCgpub2RlX2luZGV4GAEgAigNEiQKGHVpbnQzMl93b3JraW5nX3Ro",
            "cmVzaG9sZBgCIAEoDUICGAESJwoRd29ya2luZ190aHJlc2hvbGQYBSABKAsy",
            "DC5jcWcuRGVjaW1hbBJEChhtYXJrZXRfdGFraW5nX3BhcmFtZXRlcnMYAyAC",
            "KAsyIi5zdHJhdGVneV8yLk1hcmtldFRha2luZ1BhcmFtZXRlcnMSRAoYbWFy",
            "a2V0X21ha2luZ19wYXJhbWV0ZXJzGAQgAigLMiIuc3RyYXRlZ3lfMi5NYXJr",
            "ZXRNYWtpbmdQYXJhbWV0ZXJzInAKDVByaWNlU2hpZnRpbmcSEgoKcHJpY2Vf",
            "c3RlcBgBIAIoBRIjChd1aW50MzJfZmlsbGVkX3F0eV9kZWx0YRgCIAEoDUIC",
            "GAESJgoQZmlsbGVkX3F0eV9kZWx0YRgDIAEoCzIMLmNxZy5EZWNpbWFsIsQE",
            "ChhMaW1pdE9yZGVyTGVnRGVzY3JpcHRpb24SEgoKbm9kZV9pbmRleBgBIAIo",
            "DRI7ChNwcmltYXJ5X29yZGVyX2xpbWl0GAIgASgLMh4uc3RyYXRlZ3lfMi5Q",
            "cmltYXJ5T3JkZXJzTGltaXQSPQoUcHJpbWFyeV9vcmRlcl9zbmlwZXIYAyAB",
            "KAsyHy5zdHJhdGVneV8yLlByaW1hcnlPcmRlcnNTbmlwZXISQAoWc2Vjb25k",
            "YXJ5X29yZGVyc19saW1pdBgEIAEoCzIgLnN0cmF0ZWd5XzIuU2Vjb25kYXJ5",
            "T3JkZXJzTGltaXQSQgoXc2Vjb25kYXJ5X29yZGVyc19tYXJrZXQYBSABKAsy",
            "IS5zdHJhdGVneV8yLlNlY29uZGFyeU9yZGVyc01hcmtldBJAChZzZWNvbmRh",
            "cnlfb3JkZXJzX3BheXVwGAYgASgLMiAuc3RyYXRlZ3lfMi5TZWNvbmRhcnlP",
            "cmRlcnNQYXlVcBJGChlzZWNvbmRhcnlfb3JkZXJzX3RyYWlsaW5nGAcgASgL",
            "MiMuc3RyYXRlZ3lfMi5TZWNvbmRhcnlPcmRlcnNUcmFpbGluZxIkChxwcm9w",
            "b3J0aW9uYWxfZXhlY3V0aW9uX3JhdGlvGAggASgBEhkKEXZvbHVtZV9tdWx0",
            "aXBsaWVyGAkgASgBEiEKFXVpbnQzMl93b3JrX3RocmVzaG9sZBgKIAEoDUIC",
            "GAESJAoOd29ya190aHJlc2hvbGQYCyABKAsyDC5jcWcuRGVjaW1hbCLEBwoS",
            "UHJpbWFyeU9yZGVyc0xpbWl0EiQKGHVpbnQzMl9taW5fcXR5X2luY3JlbWVu",
            "dBgBIAEoDUICGAESJwoRbWluX3F0eV9pbmNyZW1lbnQYEiABKAsyDC5jcWcu",
            "RGVjaW1hbBIeChZxdWV1ZV9ob2xkZXJzX21pbl9zaXplGAIgASgNEh4KFnF1",
            "ZXVlX2hvbGRlcnNfbWF4X3NpemUYAyABKA0SHgoWcXVldWVfaG9sZGVyc19k",
            "aXN0YW5jZRgEIAEoDRIkChxvcmRlcl9zaXplX3Jlc3RvcmVfdGhyZXNob2xk",
            "GAUgASgNEh4KEnVpbnQzMl92aXNpYmxlX3F0eRgGIAEoDUICGAESIQoLdmlz",
            "aWJsZV9xdHkYEyABKAsyDC5jcWcuRGVjaW1hbBIiChZ1aW50MzJfbWluX3Zp",
            "c2libGVfcXR5GAcgASgNQgIYARIlCg9taW5fdmlzaWJsZV9xdHkYFCABKAsy",
            "DC5jcWcuRGVjaW1hbBIiChp3b3JraW5nX29yZGVyc19wcmljZV9yYW5nZRgI",
            "IAEoDRIYChBtaW5fcHJpY2VfY2hhbmdlGAkgASgNEiYKHnByaW1hcnlfb3Jk",
            "ZXJzX2ZpZm9fcXVldWVfc2l6ZRgKIAEoDRIbChNmb3JjZV91cGRhdGVfcGVy",
            "aW9kGAsgASgNEh8KF2lnbm9yZV9vYnNlcnZlZF9tYXJrZXRzGAwgASgIEhMK",
            "C21heF9kaW1taW5nGA0gASgNEhwKFGZhcl9mcm9tX21hcmtldF9tb2RlGA4g",
            "ASgNEhoKEnRpY2tzX2F3YXlfdG9fd29yaxgPIAEoBRIRCglkb21fdXNhZ2UY",
            "ECABKA0SGgoSZG9tX211bHRpbGV2ZWxfcXR5GBEgASgNIoQBChFGYXJGcm9t",
            "TWFya2V0TW9kZRIiCh5GQVJfRlJPTV9NQVJLRVRfTU9ERV9OT19PUkRFUlMQ",
            "ARInCiNGQVJfRlJPTV9NQVJLRVRfTU9ERV9NT1ZFX0FXQVlfT05MWRACEiIK",
            "HkZBUl9GUk9NX01BUktFVF9NT0RFX0RPTlRfTU9WRRADIqEBCgxET01Vc2Fn",
            "ZU1vZGUSGwoXRE9NX1VTQUdFX01PREVfVE9QX09OTFkQARIeChpET01fVVNB",
            "R0VfTU9ERV9NVUxUSUxFVkVMUxACEigKJERPTV9VU0FHRV9NT0RFX0ZVTExf",
            "U0laRV9XT1JTVF9QUklDRRADEioKJkRPTV9VU0FHRV9NT0RFX0ZVTExfU0la",
            "RV9BVkVSQUdFX1BSSUNFEAQifAoTUHJpbWFyeU9yZGVyc1NuaXBlchIUCgxs",
            "ZWdfZHVyYXRpb24YASACKA0iTwoLTGVnRHVyYXRpb24SFAoQTEVHX0RVUkFU",
            "SU9OX0RBWRABEhQKEExFR19EVVJBVElPTl9GQUsQAhIUChBMRUdfRFVSQVRJ",
            "T05fRk9LEAMiLgoUU2Vjb25kYXJ5T3JkZXJzTGltaXQSFgoOaW5pdGlhbF9v",
            "ZmZzZXQYASABKAEiFwoVU2Vjb25kYXJ5T3JkZXJzTWFya2V0IoUCChRTZWNv",
            "bmRhcnlPcmRlcnNQYXlVcBIOCgZvZmZzZXQYASACKAESFgoOaW5pdGlhbF9v",
            "ZmZzZXQYAiABKAESGQoRY29uZGl0aW9uX3RpbWVvdXQYAyABKA0SLAogdWlu",
            "dDMyX2NvbmRpdGlvbl9hYnNvbHV0ZV92b2x1bWUYBCABKA1CAhgBEi8KGWNv",
            "bmRpdGlvbl9hYnNvbHV0ZV92b2x1bWUYByABKAsyDC5jcWcuRGVjaW1hbBIn",
            "Ch9jb25kaXRpb25fb3Bwb3NpdGVfdm9sdW1lX3JhdGlvGAUgASgBEiIKGmNv",
            "bmRpdGlvbl9iYmFfdm9sdW1lX3JhdGlvGAYgASgBIp8CChdTZWNvbmRhcnlP",
            "cmRlcnNUcmFpbGluZxIXCg90cmFpbGluZ19vZmZzZXQYASACKAESFAoMdHJh",
            "aWxpbmdfcGVnGAIgAigNEhYKDmluaXRpYWxfb2Zmc2V0GAMgASgBEhEKCW1h",
            "eF90cmFpbBgEIAEoARIsCiB1aW50MzJfY29uZGl0aW9uX2Fic29sdXRlX3Zv",
            "bHVtZRgFIAEoDUICGAESLwoZY29uZGl0aW9uX2Fic29sdXRlX3ZvbHVtZRgI",
            "IAEoCzIMLmNxZy5EZWNpbWFsEicKH2NvbmRpdGlvbl9vcHBvc2l0ZV92b2x1",
            "bWVfcmF0aW8YBiABKAESIgoaY29uZGl0aW9uX2JiYV92b2x1bWVfcmF0aW8Y",
            "ByABKAEizwEKFk1hcmtldFRha2luZ1BhcmFtZXRlcnMSGgoSYWxsb2NhdGlv",
            "bl9wZXJjZW50GAEgAigBEhcKD3dvcmtpbmdfdGltZW91dBgCIAIoDRISCgpv",
            "cmRlcl90eXBlGAMgAigNImwKGk1hcmtldFRha2luZ0xpbWl0T3JkZXJUeXBl",
            "EiYKIk1BUktFVF9UQUtJTkdfTElNSVRfT1JERVJfVFlQRV9MTVQQARImCiJN",
            "QVJLRVRfVEFLSU5HX0xJTUlUX09SREVSX1RZUEVfTUtUEAIikwIKFk1hcmtl",
            "dE1ha2luZ1BhcmFtZXRlcnMSGgoSYWxsb2NhdGlvbl9wZXJjZW50GAEgASgB",
            "Eh4KEnVpbnQzMl92aXNpYmxlX3F0eRgCIAEoDUICGAESIgoWdWludDMyX21p",
            "bl92aXNpYmxlX3F0eRgDIAEoDUICGAESJQoZdWludDMyX25hdGl2ZV92aXNp",
            "YmxlX3F0eRgEIAEoDUICGAESIQoLdmlzaWJsZV9xdHkYBSABKAsyDC5jcWcu",
            "RGVjaW1hbBIlCg9taW5fdmlzaWJsZV9xdHkYBiABKAsyDC5jcWcuRGVjaW1h",
            "bBIoChJuYXRpdmVfdmlzaWJsZV9xdHkYByABKAsyDC5jcWcuRGVjaW1hbCKe",
            "AQoSU3ludGhldGljTGlxdWlkYXRlEhIKCmFjY291bnRfaWQYASACKBESEAoI",
            "b3JkZXJfaWQYAiACKAkSDwoHaGFuZ19pZBgDIAIoERIZCg13aGVuX3V0Y190",
            "aW1lGAQgASgSQgIYARI2ChJ3aGVuX3V0Y190aW1lc3RhbXAYBSABKAsyGi5n",
            "b29nbGUucHJvdG9idWYuVGltZXN0YW1wIpwBChBTeW50aGV0aWNTY3JhdGNo",
            "EhIKCmFjY291bnRfaWQYASACKBESEAoIb3JkZXJfaWQYAiACKAkSDwoHaGFu",
            "Z19pZBgDIAIoERIZCg13aGVuX3V0Y190aW1lGAQgASgSQgIYARI2ChJ3aGVu",
            "X3V0Y190aW1lc3RhbXAYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0",
            "YW1wIpQBCghHb01hcmtldBISCgphY2NvdW50X2lkGAEgAigREhAKCG9yZGVy",
            "X2lkGAIgAigJEg8KB2hhbmdfaWQYAyABKBESGQoNd2hlbl91dGNfdGltZRgE",
            "IAEoEkICGAESNgoSd2hlbl91dGNfdGltZXN0YW1wGAUgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLlRpbWVzdGFtcA=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Metadata2.Metadata2Reflection.Descriptor, global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor, global::Cqg.DecimalReflection.Descriptor, global::Google.Protobuf.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.AlgoStrategyDefinitionRequest), global::Strategy2.AlgoStrategyDefinitionRequest.Parser, new[]{ "AlgoStrategies" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.AlgoStrategyDefinitionReport), global::Strategy2.AlgoStrategyDefinitionReport.Parser, new[]{ "AlgoStrategyDefinitions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyDefinitionRequest), global::Strategy2.StrategyDefinitionRequest.Parser, new[]{ "StrategyDefinition", "AccountId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyDefinitionReport), global::Strategy2.StrategyDefinitionReport.Parser, new[]{ "ContractMetadata" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyLegFill), global::Strategy2.StrategyLegFill.Parser, new[]{ "LegOrderId", "LegExecutionId", "Qty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SyntheticHang), global::Strategy2.SyntheticHang.Parser, new[]{ "HangId", "Uint32HungQty", "HungQty", "OrderIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SyntheticStrategyProperties), global::Strategy2.SyntheticStrategyProperties.Parser, new[]{ "StrategyTradingParameters", "OriginOrderId", "RootOrderId", "NodeIndex" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyTradingParameters), global::Strategy2.StrategyTradingParameters.Parser, new[]{ "MarketOrderParameters", "LimitOrderParameters", "StopOrderParameters", "AggregationParameters", "LegParameters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyOrderLegParameters), global::Strategy2.StrategyOrderLegParameters.Parser, new[]{ "NodeIndex", "AccountId", "OpenCloseInstruction", "SpeculationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyMarketOrderParameters), global::Strategy2.StrategyMarketOrderParameters.Parser, new[]{ "NodeIndex", "ReplenishOnPrimaryFill" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyLimitOrderParameters), global::Strategy2.StrategyLimitOrderParameters.Parser, new[]{ "NodeIndex", "ReplenishOnPrimaryFill", "OverfillMode", "AlignToStrategyLots", "PricingMethod", "PriceShifting", "LegDescriptions" }, null, new[]{ typeof(global::Strategy2.StrategyLimitOrderParameters.Types.OverfillMode), typeof(global::Strategy2.StrategyLimitOrderParameters.Types.AlignToStrategyLots), typeof(global::Strategy2.StrategyLimitOrderParameters.Types.PricingMethod) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyStopOrderParameters), global::Strategy2.StrategyStopOrderParameters.Parser, new[]{ "NodeIndex", "StopSide", "ReplenishOnPrimaryFill" }, null, new[]{ typeof(global::Strategy2.StrategyStopOrderParameters.Types.StopSide) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.StrategyAggregationParameters), global::Strategy2.StrategyAggregationParameters.Parser, new[]{ "NodeIndex", "OverfillMode", "PriceShifting", "PatternLegs" }, null, new[]{ typeof(global::Strategy2.StrategyAggregationParameters.Types.AggrOverfillMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.AggregationLegDescription), global::Strategy2.AggregationLegDescription.Parser, new[]{ "NodeIndex", "Uint32WorkingThreshold", "WorkingThreshold", "MarketTakingParameters", "MarketMakingParameters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.PriceShifting), global::Strategy2.PriceShifting.Parser, new[]{ "PriceStep", "Uint32FilledQtyDelta", "FilledQtyDelta" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.LimitOrderLegDescription), global::Strategy2.LimitOrderLegDescription.Parser, new[]{ "NodeIndex", "PrimaryOrderLimit", "PrimaryOrderSniper", "SecondaryOrdersLimit", "SecondaryOrdersMarket", "SecondaryOrdersPayup", "SecondaryOrdersTrailing", "ProportionalExecutionRatio", "VolumeMultiplier", "Uint32WorkThreshold", "WorkThreshold" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.PrimaryOrdersLimit), global::Strategy2.PrimaryOrdersLimit.Parser, new[]{ "Uint32MinQtyIncrement", "MinQtyIncrement", "QueueHoldersMinSize", "QueueHoldersMaxSize", "QueueHoldersDistance", "OrderSizeRestoreThreshold", "Uint32VisibleQty", "VisibleQty", "Uint32MinVisibleQty", "MinVisibleQty", "WorkingOrdersPriceRange", "MinPriceChange", "PrimaryOrdersFifoQueueSize", "ForceUpdatePeriod", "IgnoreObservedMarkets", "MaxDimming", "FarFromMarketMode", "TicksAwayToWork", "DomUsage", "DomMultilevelQty" }, null, new[]{ typeof(global::Strategy2.PrimaryOrdersLimit.Types.FarFromMarketMode), typeof(global::Strategy2.PrimaryOrdersLimit.Types.DOMUsageMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.PrimaryOrdersSniper), global::Strategy2.PrimaryOrdersSniper.Parser, new[]{ "LegDuration" }, null, new[]{ typeof(global::Strategy2.PrimaryOrdersSniper.Types.LegDuration) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SecondaryOrdersLimit), global::Strategy2.SecondaryOrdersLimit.Parser, new[]{ "InitialOffset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SecondaryOrdersMarket), global::Strategy2.SecondaryOrdersMarket.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SecondaryOrdersPayUp), global::Strategy2.SecondaryOrdersPayUp.Parser, new[]{ "Offset", "InitialOffset", "ConditionTimeout", "Uint32ConditionAbsoluteVolume", "ConditionAbsoluteVolume", "ConditionOppositeVolumeRatio", "ConditionBbaVolumeRatio" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SecondaryOrdersTrailing), global::Strategy2.SecondaryOrdersTrailing.Parser, new[]{ "TrailingOffset", "TrailingPeg", "InitialOffset", "MaxTrail", "Uint32ConditionAbsoluteVolume", "ConditionAbsoluteVolume", "ConditionOppositeVolumeRatio", "ConditionBbaVolumeRatio" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.MarketTakingParameters), global::Strategy2.MarketTakingParameters.Parser, new[]{ "AllocationPercent", "WorkingTimeout", "OrderType" }, null, new[]{ typeof(global::Strategy2.MarketTakingParameters.Types.MarketTakingLimitOrderType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.MarketMakingParameters), global::Strategy2.MarketMakingParameters.Parser, new[]{ "AllocationPercent", "Uint32VisibleQty", "Uint32MinVisibleQty", "Uint32NativeVisibleQty", "VisibleQty", "MinVisibleQty", "NativeVisibleQty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SyntheticLiquidate), global::Strategy2.SyntheticLiquidate.Parser, new[]{ "AccountId", "OrderId", "HangId", "WhenUtcTime", "WhenUtcTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.SyntheticScratch), global::Strategy2.SyntheticScratch.Parser, new[]{ "AccountId", "OrderId", "HangId", "WhenUtcTime", "WhenUtcTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Strategy2.GoMarket), global::Strategy2.GoMarket.Parser, new[]{ "AccountId", "OrderId", "HangId", "WhenUtcTime", "WhenUtcTimestamp" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Request for algo strategies definitions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AlgoStrategyDefinitionRequest : pb::IMessage<AlgoStrategyDefinitionRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AlgoStrategyDefinitionRequest> _parser = new pb::MessageParser<AlgoStrategyDefinitionRequest>(() => new AlgoStrategyDefinitionRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AlgoStrategyDefinitionRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionRequest(AlgoStrategyDefinitionRequest other) : this() {
      algoStrategies_ = other.algoStrategies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionRequest Clone() {
      return new AlgoStrategyDefinitionRequest(this);
    }

    /// <summary>Field number for the "algo_strategies" field.</summary>
    public const int AlgoStrategiesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_algoStrategies_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> algoStrategies_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of algo strategies to request definitions (abbreviations).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> AlgoStrategies {
      get { return algoStrategies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AlgoStrategyDefinitionRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AlgoStrategyDefinitionRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!algoStrategies_.Equals(other.algoStrategies_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= algoStrategies_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      algoStrategies_.WriteTo(output, _repeated_algoStrategies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      algoStrategies_.WriteTo(ref output, _repeated_algoStrategies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += algoStrategies_.CalculateSize(_repeated_algoStrategies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AlgoStrategyDefinitionRequest other) {
      if (other == null) {
        return;
      }
      algoStrategies_.Add(other.algoStrategies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            algoStrategies_.AddEntriesFrom(input, _repeated_algoStrategies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            algoStrategies_.AddEntriesFrom(ref input, _repeated_algoStrategies_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Report with algo strategies definitions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AlgoStrategyDefinitionReport : pb::IMessage<AlgoStrategyDefinitionReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AlgoStrategyDefinitionReport> _parser = new pb::MessageParser<AlgoStrategyDefinitionReport>(() => new AlgoStrategyDefinitionReport());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AlgoStrategyDefinitionReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionReport(AlgoStrategyDefinitionReport other) : this() {
      algoStrategyDefinitions_ = other.algoStrategyDefinitions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinitionReport Clone() {
      return new AlgoStrategyDefinitionReport(this);
    }

    /// <summary>Field number for the "algo_strategy_definitions" field.</summary>
    public const int AlgoStrategyDefinitionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::StrategyDefinition2.AlgoStrategyDefinition> _repeated_algoStrategyDefinitions_codec
        = pb::FieldCodec.ForMessage(10, global::StrategyDefinition2.AlgoStrategyDefinition.Parser);
    private readonly pbc::RepeatedField<global::StrategyDefinition2.AlgoStrategyDefinition> algoStrategyDefinitions_ = new pbc::RepeatedField<global::StrategyDefinition2.AlgoStrategyDefinition>();
    /// <summary>
    /// List of algo strategy definitions for given abbreviations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::StrategyDefinition2.AlgoStrategyDefinition> AlgoStrategyDefinitions {
      get { return algoStrategyDefinitions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AlgoStrategyDefinitionReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AlgoStrategyDefinitionReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!algoStrategyDefinitions_.Equals(other.algoStrategyDefinitions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= algoStrategyDefinitions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      algoStrategyDefinitions_.WriteTo(output, _repeated_algoStrategyDefinitions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      algoStrategyDefinitions_.WriteTo(ref output, _repeated_algoStrategyDefinitions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += algoStrategyDefinitions_.CalculateSize(_repeated_algoStrategyDefinitions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AlgoStrategyDefinitionReport other) {
      if (other == null) {
        return;
      }
      algoStrategyDefinitions_.Add(other.algoStrategyDefinitions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            algoStrategyDefinitions_.AddEntriesFrom(input, _repeated_algoStrategyDefinitions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            algoStrategyDefinitions_.AddEntriesFrom(ref input, _repeated_algoStrategyDefinitions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request to define a strategy as a contract.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyDefinitionRequest : pb::IMessage<StrategyDefinitionRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyDefinitionRequest> _parser = new pb::MessageParser<StrategyDefinitionRequest>(() => new StrategyDefinitionRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyDefinitionRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionRequest(StrategyDefinitionRequest other) : this() {
      _hasBits0 = other._hasBits0;
      strategyDefinition_ = other.strategyDefinition_ != null ? other.strategyDefinition_.Clone() : null;
      accountId_ = other.accountId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionRequest Clone() {
      return new StrategyDefinitionRequest(this);
    }

    /// <summary>Field number for the "strategy_definition" field.</summary>
    public const int StrategyDefinitionFieldNumber = 1;
    private global::StrategyDefinition2.StrategyDefinition strategyDefinition_;
    /// <summary>
    /// Strategy to define.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::StrategyDefinition2.StrategyDefinition StrategyDefinition {
      get { return strategyDefinition_; }
      set {
        strategyDefinition_ = value;
      }
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 2;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account ID in CQG trade routing system.
    /// Some exchanges require an account ID in the process of defining a UDS. For those exchanges this is a
    /// required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 1) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyDefinitionRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyDefinitionRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StrategyDefinition, other.StrategyDefinition)) return false;
      if (AccountId != other.AccountId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (strategyDefinition_ != null) hash ^= StrategyDefinition.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (strategyDefinition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StrategyDefinition);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (strategyDefinition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StrategyDefinition);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (strategyDefinition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StrategyDefinition);
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyDefinitionRequest other) {
      if (other == null) {
        return;
      }
      if (other.strategyDefinition_ != null) {
        if (strategyDefinition_ == null) {
          StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
        }
        StrategyDefinition.MergeFrom(other.StrategyDefinition);
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (strategyDefinition_ == null) {
              StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(StrategyDefinition);
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (strategyDefinition_ == null) {
              StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(StrategyDefinition);
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Report of the contract metadata assigned to the strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyDefinitionReport : pb::IMessage<StrategyDefinitionReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyDefinitionReport> _parser = new pb::MessageParser<StrategyDefinitionReport>(() => new StrategyDefinitionReport());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyDefinitionReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionReport(StrategyDefinitionReport other) : this() {
      contractMetadata_ = other.contractMetadata_ != null ? other.contractMetadata_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinitionReport Clone() {
      return new StrategyDefinitionReport(this);
    }

    /// <summary>Field number for the "contract_metadata" field.</summary>
    public const int ContractMetadataFieldNumber = 1;
    private global::Metadata2.ContractMetadata contractMetadata_;
    /// <summary>
    /// Assigned strategy metadata.
    /// Note: In case of exchange strategies field 'strategy_definition' in contract_metadata always matches the definition
    /// received from the exchange, therefore it can be slightly different than field 'strategy_definition' in
    /// StrategyDefinitionRequest.
    /// Example: user wants to define UDS(A + B - C), but similar UDS(A - C + B) already exists on exchange.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Metadata2.ContractMetadata ContractMetadata {
      get { return contractMetadata_; }
      set {
        contractMetadata_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyDefinitionReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyDefinitionReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ContractMetadata, other.ContractMetadata)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (contractMetadata_ != null) hash ^= ContractMetadata.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (contractMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractMetadata);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyDefinitionReport other) {
      if (other == null) {
        return;
      }
      if (other.contractMetadata_ != null) {
        if (contractMetadata_ == null) {
          ContractMetadata = new global::Metadata2.ContractMetadata();
        }
        ContractMetadata.MergeFrom(other.ContractMetadata);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a leg order fill that contributes to a synthetic strategy order fill.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyLegFill : pb::IMessage<StrategyLegFill>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyLegFill> _parser = new pb::MessageParser<StrategyLegFill>(() => new StrategyLegFill());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyLegFill> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLegFill() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLegFill(StrategyLegFill other) : this() {
      _hasBits0 = other._hasBits0;
      legOrderId_ = other.legOrderId_;
      legExecutionId_ = other.legExecutionId_;
      qty_ = other.qty_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLegFill Clone() {
      return new StrategyLegFill(this);
    }

    /// <summary>Field number for the "leg_order_id" field.</summary>
    public const int LegOrderIdFieldNumber = 1;
    private readonly static string LegOrderIdDefaultValue = "";

    private string legOrderId_;
    /// <summary>
    /// Order id for the leg order (the original OrderStatus.order_id)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LegOrderId {
      get { return legOrderId_ ?? LegOrderIdDefaultValue; }
      set {
        legOrderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "leg_order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLegOrderId {
      get { return legOrderId_ != null; }
    }
    /// <summary>Clears the value of the "leg_order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLegOrderId() {
      legOrderId_ = null;
    }

    /// <summary>Field number for the "leg_execution_id" field.</summary>
    public const int LegExecutionIdFieldNumber = 2;
    private readonly static string LegExecutionIdDefaultValue = "";

    private string legExecutionId_;
    /// <summary>
    /// Leg_execution_id of the corresponding Trade message for the leg order fill.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LegExecutionId {
      get { return legExecutionId_ ?? LegExecutionIdDefaultValue; }
      set {
        legExecutionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "leg_execution_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLegExecutionId {
      get { return legExecutionId_ != null; }
    }
    /// <summary>Clears the value of the "leg_execution_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLegExecutionId() {
      legExecutionId_ = null;
    }

    /// <summary>Field number for the "qty" field.</summary>
    public const int QtyFieldNumber = 3;
    private readonly static double QtyDefaultValue = 0D;

    private double qty_;
    /// <summary>
    /// Quantity of the leg order fill used for this synthetic strategy order fill,
    /// decimal (fractional quantities are possible for legs with non-integer quantity ratio).
    /// This is correct quantity (ContractMetadata.volume_scale must not be applied).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Qty {
      get { if ((_hasBits0 & 1) != 0) { return qty_; } else { return QtyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        qty_ = value;
      }
    }
    /// <summary>Gets whether the "qty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQty {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "qty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQty() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyLegFill);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyLegFill other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LegOrderId != other.LegOrderId) return false;
      if (LegExecutionId != other.LegExecutionId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Qty, other.Qty)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLegOrderId) hash ^= LegOrderId.GetHashCode();
      if (HasLegExecutionId) hash ^= LegExecutionId.GetHashCode();
      if (HasQty) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Qty);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLegOrderId) {
        output.WriteRawTag(10);
        output.WriteString(LegOrderId);
      }
      if (HasLegExecutionId) {
        output.WriteRawTag(18);
        output.WriteString(LegExecutionId);
      }
      if (HasQty) {
        output.WriteRawTag(25);
        output.WriteDouble(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLegOrderId) {
        output.WriteRawTag(10);
        output.WriteString(LegOrderId);
      }
      if (HasLegExecutionId) {
        output.WriteRawTag(18);
        output.WriteString(LegExecutionId);
      }
      if (HasQty) {
        output.WriteRawTag(25);
        output.WriteDouble(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLegOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LegOrderId);
      }
      if (HasLegExecutionId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LegExecutionId);
      }
      if (HasQty) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyLegFill other) {
      if (other == null) {
        return;
      }
      if (other.HasLegOrderId) {
        LegOrderId = other.LegOrderId;
      }
      if (other.HasLegExecutionId) {
        LegExecutionId = other.LegExecutionId;
      }
      if (other.HasQty) {
        Qty = other.Qty;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LegOrderId = input.ReadString();
            break;
          }
          case 18: {
            LegExecutionId = input.ReadString();
            break;
          }
          case 25: {
            Qty = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            LegOrderId = input.ReadString();
            break;
          }
          case 18: {
            LegExecutionId = input.ReadString();
            break;
          }
          case 25: {
            Qty = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Details of hung quantity on a synthetic strategy order or existing hang resolution.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SyntheticHang : pb::IMessage<SyntheticHang>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SyntheticHang> _parser = new pb::MessageParser<SyntheticHang>(() => new SyntheticHang());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SyntheticHang> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticHang() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticHang(SyntheticHang other) : this() {
      _hasBits0 = other._hasBits0;
      hangId_ = other.hangId_;
      uint32HungQty_ = other.uint32HungQty_;
      hungQty_ = other.hungQty_ != null ? other.hungQty_.Clone() : null;
      orderIds_ = other.orderIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticHang Clone() {
      return new SyntheticHang(this);
    }

    /// <summary>Field number for the "hang_id" field.</summary>
    public const int HangIdFieldNumber = 1;
    private readonly static int HangIdDefaultValue = 0;

    private int hangId_;
    /// <summary>
    /// Unique hang identifier supplied by server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HangId {
      get { if ((_hasBits0 & 1) != 0) { return hangId_; } else { return HangIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        hangId_ = value;
      }
    }
    /// <summary>Gets whether the "hang_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHangId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "hang_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHangId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_hung_qty" field.</summary>
    public const int Uint32HungQtyFieldNumber = 2;
    private readonly static uint Uint32HungQtyDefaultValue = 0;

    private uint uint32HungQty_;
    /// <summary>
    /// Note: use hung_qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32HungQty {
      get { if ((_hasBits0 & 2) != 0) { return uint32HungQty_; } else { return Uint32HungQtyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32HungQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_hung_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32HungQty {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_hung_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32HungQty() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "hung_qty" field.</summary>
    public const int HungQtyFieldNumber = 4;
    private global::Cqg.Decimal hungQty_;
    /// <summary>
    /// Quantity (of the synthetic strategy order) hung, 0 indicates that hang is resolved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal HungQty {
      get { return hungQty_; }
      set {
        hungQty_ = value;
      }
    }

    /// <summary>Field number for the "order_ids" field.</summary>
    public const int OrderIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_orderIds_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> orderIds_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Orders participating in a synthetic strategy order hang.
    /// Note: this is the original OrderStatus.order_id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OrderIds {
      get { return orderIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SyntheticHang);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SyntheticHang other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HangId != other.HangId) return false;
      if (Uint32HungQty != other.Uint32HungQty) return false;
      if (!object.Equals(HungQty, other.HungQty)) return false;
      if(!orderIds_.Equals(other.orderIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHangId) hash ^= HangId.GetHashCode();
      if (HasUint32HungQty) hash ^= Uint32HungQty.GetHashCode();
      if (hungQty_ != null) hash ^= HungQty.GetHashCode();
      hash ^= orderIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasHangId) {
        output.WriteRawTag(8);
        output.WriteSInt32(HangId);
      }
      if (HasUint32HungQty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32HungQty);
      }
      orderIds_.WriteTo(output, _repeated_orderIds_codec);
      if (hungQty_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HungQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasHangId) {
        output.WriteRawTag(8);
        output.WriteSInt32(HangId);
      }
      if (HasUint32HungQty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32HungQty);
      }
      orderIds_.WriteTo(ref output, _repeated_orderIds_codec);
      if (hungQty_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HungQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasHangId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(HangId);
      }
      if (HasUint32HungQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32HungQty);
      }
      if (hungQty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HungQty);
      }
      size += orderIds_.CalculateSize(_repeated_orderIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SyntheticHang other) {
      if (other == null) {
        return;
      }
      if (other.HasHangId) {
        HangId = other.HangId;
      }
      if (other.HasUint32HungQty) {
        Uint32HungQty = other.Uint32HungQty;
      }
      if (other.hungQty_ != null) {
        if (hungQty_ == null) {
          HungQty = new global::Cqg.Decimal();
        }
        HungQty.MergeFrom(other.HungQty);
      }
      orderIds_.Add(other.orderIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            HangId = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32HungQty = input.ReadUInt32();
            break;
          }
          case 26: {
            orderIds_.AddEntriesFrom(input, _repeated_orderIds_codec);
            break;
          }
          case 34: {
            if (hungQty_ == null) {
              HungQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(HungQty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            HangId = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32HungQty = input.ReadUInt32();
            break;
          }
          case 26: {
            orderIds_.AddEntriesFrom(ref input, _repeated_orderIds_codec);
            break;
          }
          case 34: {
            if (hungQty_ == null) {
              HungQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(HungQty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Synthetic strategy order's outright properties.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SyntheticStrategyProperties : pb::IMessage<SyntheticStrategyProperties>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SyntheticStrategyProperties> _parser = new pb::MessageParser<SyntheticStrategyProperties>(() => new SyntheticStrategyProperties());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SyntheticStrategyProperties> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticStrategyProperties() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticStrategyProperties(SyntheticStrategyProperties other) : this() {
      _hasBits0 = other._hasBits0;
      strategyTradingParameters_ = other.strategyTradingParameters_ != null ? other.strategyTradingParameters_.Clone() : null;
      originOrderId_ = other.originOrderId_;
      rootOrderId_ = other.rootOrderId_;
      nodeIndex_ = other.nodeIndex_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticStrategyProperties Clone() {
      return new SyntheticStrategyProperties(this);
    }

    /// <summary>Field number for the "strategy_trading_parameters" field.</summary>
    public const int StrategyTradingParametersFieldNumber = 1;
    private global::Strategy2.StrategyTradingParameters strategyTradingParameters_;
    /// <summary>
    /// Synthetic strategy trading parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.StrategyTradingParameters StrategyTradingParameters {
      get { return strategyTradingParameters_; }
      set {
        strategyTradingParameters_ = value;
      }
    }

    /// <summary>Field number for the "origin_order_id" field.</summary>
    public const int OriginOrderIdFieldNumber = 2;
    private readonly static string OriginOrderIdDefaultValue = "";

    private string originOrderId_;
    /// <summary>
    /// Parent synthetic order id that led to this order's (automatic) placement;
    /// allows client to show the link to user.
    /// Note: this is the original synthetic order's ID (OrderStatus.order_id), not affected by any modifications.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OriginOrderId {
      get { return originOrderId_ ?? OriginOrderIdDefaultValue; }
      set {
        originOrderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "origin_order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOriginOrderId {
      get { return originOrderId_ != null; }
    }
    /// <summary>Clears the value of the "origin_order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOriginOrderId() {
      originOrderId_ = null;
    }

    /// <summary>Field number for the "root_order_id" field.</summary>
    public const int RootOrderIdFieldNumber = 3;
    private readonly static string RootOrderIdDefaultValue = "";

    private string rootOrderId_;
    /// <summary>
    /// Id of the originally placed by trader root synthetic strategy order
    /// (The same as origin_order_id for the root immediate legs).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RootOrderId {
      get { return rootOrderId_ ?? RootOrderIdDefaultValue; }
      set {
        rootOrderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "root_order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRootOrderId {
      get { return rootOrderId_ != null; }
    }
    /// <summary>Clears the value of the "root_order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRootOrderId() {
      rootOrderId_ = null;
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 4;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index of the synthetic order (specified by root_order_id);
    /// allows client to associate this order with a particular node of the synthetic strategy
    /// (either a leg or a nested strategy).
    /// LegDefinition.node_index or StrategyDefinition.node_index value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SyntheticStrategyProperties);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SyntheticStrategyProperties other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StrategyTradingParameters, other.StrategyTradingParameters)) return false;
      if (OriginOrderId != other.OriginOrderId) return false;
      if (RootOrderId != other.RootOrderId) return false;
      if (NodeIndex != other.NodeIndex) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (strategyTradingParameters_ != null) hash ^= StrategyTradingParameters.GetHashCode();
      if (HasOriginOrderId) hash ^= OriginOrderId.GetHashCode();
      if (HasRootOrderId) hash ^= RootOrderId.GetHashCode();
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (strategyTradingParameters_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StrategyTradingParameters);
      }
      if (HasOriginOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OriginOrderId);
      }
      if (HasRootOrderId) {
        output.WriteRawTag(26);
        output.WriteString(RootOrderId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(32);
        output.WriteUInt32(NodeIndex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (strategyTradingParameters_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StrategyTradingParameters);
      }
      if (HasOriginOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OriginOrderId);
      }
      if (HasRootOrderId) {
        output.WriteRawTag(26);
        output.WriteString(RootOrderId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(32);
        output.WriteUInt32(NodeIndex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (strategyTradingParameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StrategyTradingParameters);
      }
      if (HasOriginOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OriginOrderId);
      }
      if (HasRootOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RootOrderId);
      }
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SyntheticStrategyProperties other) {
      if (other == null) {
        return;
      }
      if (other.strategyTradingParameters_ != null) {
        if (strategyTradingParameters_ == null) {
          StrategyTradingParameters = new global::Strategy2.StrategyTradingParameters();
        }
        StrategyTradingParameters.MergeFrom(other.StrategyTradingParameters);
      }
      if (other.HasOriginOrderId) {
        OriginOrderId = other.OriginOrderId;
      }
      if (other.HasRootOrderId) {
        RootOrderId = other.RootOrderId;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (strategyTradingParameters_ == null) {
              StrategyTradingParameters = new global::Strategy2.StrategyTradingParameters();
            }
            input.ReadMessage(StrategyTradingParameters);
            break;
          }
          case 18: {
            OriginOrderId = input.ReadString();
            break;
          }
          case 26: {
            RootOrderId = input.ReadString();
            break;
          }
          case 32: {
            NodeIndex = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (strategyTradingParameters_ == null) {
              StrategyTradingParameters = new global::Strategy2.StrategyTradingParameters();
            }
            input.ReadMessage(StrategyTradingParameters);
            break;
          }
          case 18: {
            OriginOrderId = input.ReadString();
            break;
          }
          case 26: {
            RootOrderId = input.ReadString();
            break;
          }
          case 32: {
            NodeIndex = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines how a placed synthetic strategy order will be executed.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyTradingParameters : pb::IMessage<StrategyTradingParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyTradingParameters> _parser = new pb::MessageParser<StrategyTradingParameters>(() => new StrategyTradingParameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyTradingParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyTradingParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyTradingParameters(StrategyTradingParameters other) : this() {
      marketOrderParameters_ = other.marketOrderParameters_.Clone();
      limitOrderParameters_ = other.limitOrderParameters_.Clone();
      stopOrderParameters_ = other.stopOrderParameters_.Clone();
      aggregationParameters_ = other.aggregationParameters_.Clone();
      legParameters_ = other.legParameters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyTradingParameters Clone() {
      return new StrategyTradingParameters(this);
    }

    /// <summary>Field number for the "market_order_parameters" field.</summary>
    public const int MarketOrderParametersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Strategy2.StrategyMarketOrderParameters> _repeated_marketOrderParameters_codec
        = pb::FieldCodec.ForMessage(10, global::Strategy2.StrategyMarketOrderParameters.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.StrategyMarketOrderParameters> marketOrderParameters_ = new pbc::RepeatedField<global::Strategy2.StrategyMarketOrderParameters>();
    /// <summary>
    /// Parameters applied only to a MKT order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.StrategyMarketOrderParameters> MarketOrderParameters {
      get { return marketOrderParameters_; }
    }

    /// <summary>Field number for the "limit_order_parameters" field.</summary>
    public const int LimitOrderParametersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Strategy2.StrategyLimitOrderParameters> _repeated_limitOrderParameters_codec
        = pb::FieldCodec.ForMessage(18, global::Strategy2.StrategyLimitOrderParameters.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.StrategyLimitOrderParameters> limitOrderParameters_ = new pbc::RepeatedField<global::Strategy2.StrategyLimitOrderParameters>();
    /// <summary>
    /// Parameters applied only to a LMT order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.StrategyLimitOrderParameters> LimitOrderParameters {
      get { return limitOrderParameters_; }
    }

    /// <summary>Field number for the "stop_order_parameters" field.</summary>
    public const int StopOrderParametersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Strategy2.StrategyStopOrderParameters> _repeated_stopOrderParameters_codec
        = pb::FieldCodec.ForMessage(26, global::Strategy2.StrategyStopOrderParameters.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.StrategyStopOrderParameters> stopOrderParameters_ = new pbc::RepeatedField<global::Strategy2.StrategyStopOrderParameters>();
    /// <summary>
    /// Parameters applied only to a STP order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.StrategyStopOrderParameters> StopOrderParameters {
      get { return stopOrderParameters_; }
    }

    /// <summary>Field number for the "aggregation_parameters" field.</summary>
    public const int AggregationParametersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Strategy2.StrategyAggregationParameters> _repeated_aggregationParameters_codec
        = pb::FieldCodec.ForMessage(34, global::Strategy2.StrategyAggregationParameters.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.StrategyAggregationParameters> aggregationParameters_ = new pbc::RepeatedField<global::Strategy2.StrategyAggregationParameters>();
    /// <summary>
    /// Parameters applied only to an aggregation strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.StrategyAggregationParameters> AggregationParameters {
      get { return aggregationParameters_; }
    }

    /// <summary>Field number for the "leg_parameters" field.</summary>
    public const int LegParametersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Strategy2.StrategyOrderLegParameters> _repeated_legParameters_codec
        = pb::FieldCodec.ForMessage(42, global::Strategy2.StrategyOrderLegParameters.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.StrategyOrderLegParameters> legParameters_ = new pbc::RepeatedField<global::Strategy2.StrategyOrderLegParameters>();
    /// <summary>
    /// Individual strategy leg parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.StrategyOrderLegParameters> LegParameters {
      get { return legParameters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyTradingParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyTradingParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!marketOrderParameters_.Equals(other.marketOrderParameters_)) return false;
      if(!limitOrderParameters_.Equals(other.limitOrderParameters_)) return false;
      if(!stopOrderParameters_.Equals(other.stopOrderParameters_)) return false;
      if(!aggregationParameters_.Equals(other.aggregationParameters_)) return false;
      if(!legParameters_.Equals(other.legParameters_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= marketOrderParameters_.GetHashCode();
      hash ^= limitOrderParameters_.GetHashCode();
      hash ^= stopOrderParameters_.GetHashCode();
      hash ^= aggregationParameters_.GetHashCode();
      hash ^= legParameters_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      marketOrderParameters_.WriteTo(output, _repeated_marketOrderParameters_codec);
      limitOrderParameters_.WriteTo(output, _repeated_limitOrderParameters_codec);
      stopOrderParameters_.WriteTo(output, _repeated_stopOrderParameters_codec);
      aggregationParameters_.WriteTo(output, _repeated_aggregationParameters_codec);
      legParameters_.WriteTo(output, _repeated_legParameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      marketOrderParameters_.WriteTo(ref output, _repeated_marketOrderParameters_codec);
      limitOrderParameters_.WriteTo(ref output, _repeated_limitOrderParameters_codec);
      stopOrderParameters_.WriteTo(ref output, _repeated_stopOrderParameters_codec);
      aggregationParameters_.WriteTo(ref output, _repeated_aggregationParameters_codec);
      legParameters_.WriteTo(ref output, _repeated_legParameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += marketOrderParameters_.CalculateSize(_repeated_marketOrderParameters_codec);
      size += limitOrderParameters_.CalculateSize(_repeated_limitOrderParameters_codec);
      size += stopOrderParameters_.CalculateSize(_repeated_stopOrderParameters_codec);
      size += aggregationParameters_.CalculateSize(_repeated_aggregationParameters_codec);
      size += legParameters_.CalculateSize(_repeated_legParameters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyTradingParameters other) {
      if (other == null) {
        return;
      }
      marketOrderParameters_.Add(other.marketOrderParameters_);
      limitOrderParameters_.Add(other.limitOrderParameters_);
      stopOrderParameters_.Add(other.stopOrderParameters_);
      aggregationParameters_.Add(other.aggregationParameters_);
      legParameters_.Add(other.legParameters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            marketOrderParameters_.AddEntriesFrom(input, _repeated_marketOrderParameters_codec);
            break;
          }
          case 18: {
            limitOrderParameters_.AddEntriesFrom(input, _repeated_limitOrderParameters_codec);
            break;
          }
          case 26: {
            stopOrderParameters_.AddEntriesFrom(input, _repeated_stopOrderParameters_codec);
            break;
          }
          case 34: {
            aggregationParameters_.AddEntriesFrom(input, _repeated_aggregationParameters_codec);
            break;
          }
          case 42: {
            legParameters_.AddEntriesFrom(input, _repeated_legParameters_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            marketOrderParameters_.AddEntriesFrom(ref input, _repeated_marketOrderParameters_codec);
            break;
          }
          case 18: {
            limitOrderParameters_.AddEntriesFrom(ref input, _repeated_limitOrderParameters_codec);
            break;
          }
          case 26: {
            stopOrderParameters_.AddEntriesFrom(ref input, _repeated_stopOrderParameters_codec);
            break;
          }
          case 34: {
            aggregationParameters_.AddEntriesFrom(ref input, _repeated_aggregationParameters_codec);
            break;
          }
          case 42: {
            legParameters_.AddEntriesFrom(ref input, _repeated_legParameters_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Parameters associated with a concrete leg.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyOrderLegParameters : pb::IMessage<StrategyOrderLegParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyOrderLegParameters> _parser = new pb::MessageParser<StrategyOrderLegParameters>(() => new StrategyOrderLegParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyOrderLegParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyOrderLegParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyOrderLegParameters(StrategyOrderLegParameters other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      accountId_ = other.accountId_;
      openCloseInstruction_ = other.openCloseInstruction_;
      speculationType_ = other.speculationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyOrderLegParameters Clone() {
      return new StrategyOrderLegParameters(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to
    ///(StrategyDefinition.node_index or LegDefinition.node_index value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 2;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account id to place an order on the leg. If not set, the account id of the order used instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "open_close_instruction" field.</summary>
    public const int OpenCloseInstructionFieldNumber = 3;
    private readonly static uint OpenCloseInstructionDefaultValue = 0;

    private uint openCloseInstruction_;
    /// <summary>
    /// Specifies what the order is intended to do: open or close (reduce) a position. One of OpenCloseInstruction enum.
    /// Applicable only if ContractMetadata.position_tracking
    /// is either LONG_SHORT_WITH_IMPLIED_CLOSE or LONG_SHORT_WITH_EXPLICIT_CLOSE.
    /// If not set, the open/close instruction of the order used instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OpenCloseInstruction {
      get { if ((_hasBits0 & 4) != 0) { return openCloseInstruction_; } else { return OpenCloseInstructionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        openCloseInstruction_ = value;
      }
    }
    /// <summary>Gets whether the "open_close_instruction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOpenCloseInstruction {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "open_close_instruction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOpenCloseInstruction() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "speculation_type" field.</summary>
    public const int SpeculationTypeFieldNumber = 4;
    private readonly static uint SpeculationTypeDefaultValue = 0;

    private uint speculationType_;
    /// <summary>
    /// Speculation type of the leg order. One of SpeculationType enum.
    /// If not set, the speculation type of the order used instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SpeculationType {
      get { if ((_hasBits0 & 8) != 0) { return speculationType_; } else { return SpeculationTypeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        speculationType_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSpeculationType {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSpeculationType() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyOrderLegParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyOrderLegParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (AccountId != other.AccountId) return false;
      if (OpenCloseInstruction != other.OpenCloseInstruction) return false;
      if (SpeculationType != other.SpeculationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasOpenCloseInstruction) hash ^= OpenCloseInstruction.GetHashCode();
      if (HasSpeculationType) hash ^= SpeculationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (HasOpenCloseInstruction) {
        output.WriteRawTag(24);
        output.WriteUInt32(OpenCloseInstruction);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(32);
        output.WriteUInt32(SpeculationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (HasOpenCloseInstruction) {
        output.WriteRawTag(24);
        output.WriteUInt32(OpenCloseInstruction);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(32);
        output.WriteUInt32(SpeculationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasOpenCloseInstruction) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OpenCloseInstruction);
      }
      if (HasSpeculationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpeculationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyOrderLegParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasOpenCloseInstruction) {
        OpenCloseInstruction = other.OpenCloseInstruction;
      }
      if (other.HasSpeculationType) {
        SpeculationType = other.SpeculationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 24: {
            OpenCloseInstruction = input.ReadUInt32();
            break;
          }
          case 32: {
            SpeculationType = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 24: {
            OpenCloseInstruction = input.ReadUInt32();
            break;
          }
          case 32: {
            SpeculationType = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Synthetic strategy MKT order parameters
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyMarketOrderParameters : pb::IMessage<StrategyMarketOrderParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyMarketOrderParameters> _parser = new pb::MessageParser<StrategyMarketOrderParameters>(() => new StrategyMarketOrderParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyMarketOrderParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyMarketOrderParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyMarketOrderParameters(StrategyMarketOrderParameters other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      replenishOnPrimaryFill_ = other.replenishOnPrimaryFill_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyMarketOrderParameters Clone() {
      return new StrategyMarketOrderParameters(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "replenish_on_primary_fill" field.</summary>
    public const int ReplenishOnPrimaryFillFieldNumber = 2;
    private readonly static bool ReplenishOnPrimaryFillDefaultValue = false;

    private bool replenishOnPrimaryFill_;
    /// <summary>
    /// For Iceberg orders:
    /// 'true' means replenish qty on the filled leg immediately upon receiving primary fill;
    /// 'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
    ///         is filled or its qty changes for some other reason, e.g. replace request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReplenishOnPrimaryFill {
      get { if ((_hasBits0 & 2) != 0) { return replenishOnPrimaryFill_; } else { return ReplenishOnPrimaryFillDefaultValue; } }
      set {
        _hasBits0 |= 2;
        replenishOnPrimaryFill_ = value;
      }
    }
    /// <summary>Gets whether the "replenish_on_primary_fill" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReplenishOnPrimaryFill {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "replenish_on_primary_fill" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReplenishOnPrimaryFill() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyMarketOrderParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyMarketOrderParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (ReplenishOnPrimaryFill != other.ReplenishOnPrimaryFill) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasReplenishOnPrimaryFill) hash ^= ReplenishOnPrimaryFill.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(16);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(16);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyMarketOrderParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasReplenishOnPrimaryFill) {
        ReplenishOnPrimaryFill = other.ReplenishOnPrimaryFill;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LMT order parameters of the root or a nested strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyLimitOrderParameters : pb::IMessage<StrategyLimitOrderParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyLimitOrderParameters> _parser = new pb::MessageParser<StrategyLimitOrderParameters>(() => new StrategyLimitOrderParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyLimitOrderParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLimitOrderParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLimitOrderParameters(StrategyLimitOrderParameters other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      replenishOnPrimaryFill_ = other.replenishOnPrimaryFill_;
      overfillMode_ = other.overfillMode_;
      alignToStrategyLots_ = other.alignToStrategyLots_;
      pricingMethod_ = other.pricingMethod_;
      priceShifting_ = other.priceShifting_ != null ? other.priceShifting_.Clone() : null;
      legDescriptions_ = other.legDescriptions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyLimitOrderParameters Clone() {
      return new StrategyLimitOrderParameters(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "replenish_on_primary_fill" field.</summary>
    public const int ReplenishOnPrimaryFillFieldNumber = 2;
    private readonly static bool ReplenishOnPrimaryFillDefaultValue = false;

    private bool replenishOnPrimaryFill_;
    /// <summary>
    /// Defines whether replenish quantity on primary fill or not.
    /// For Iceberg orders:
    ///  'true' means replenish quantity on the filled leg immediately upon receiving primary fill;
    ///  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
    ///          is filled or its quantity changes for some other reason, e.g. replace request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReplenishOnPrimaryFill {
      get { if ((_hasBits0 & 2) != 0) { return replenishOnPrimaryFill_; } else { return ReplenishOnPrimaryFillDefaultValue; } }
      set {
        _hasBits0 |= 2;
        replenishOnPrimaryFill_ = value;
      }
    }
    /// <summary>Gets whether the "replenish_on_primary_fill" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReplenishOnPrimaryFill {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "replenish_on_primary_fill" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReplenishOnPrimaryFill() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "overfill_mode" field.</summary>
    public const int OverfillModeFieldNumber = 3;
    private readonly static uint OverfillModeDefaultValue = 0;

    private uint overfillMode_;
    /// <summary>
    /// Defines mode of overfill handling for this limit SS order. One of OverfillMode enums.
    /// AUTOMATIC_HEDGING is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OverfillMode {
      get { if ((_hasBits0 & 4) != 0) { return overfillMode_; } else { return OverfillModeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        overfillMode_ = value;
      }
    }
    /// <summary>Gets whether the "overfill_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverfillMode {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "overfill_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverfillMode() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "align_to_strategy_lots" field.</summary>
    public const int AlignToStrategyLotsFieldNumber = 4;
    private readonly static uint AlignToStrategyLotsDefaultValue = 0;

    private uint alignToStrategyLots_;
    /// <summary>
    /// Defines sizes of what leg orders must be aligned to strategy lots.One of AlignToStrategyLots enums.
    /// NONE is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint AlignToStrategyLots {
      get { if ((_hasBits0 & 8) != 0) { return alignToStrategyLots_; } else { return AlignToStrategyLotsDefaultValue; } }
      set {
        _hasBits0 |= 8;
        alignToStrategyLots_ = value;
      }
    }
    /// <summary>Gets whether the "align_to_strategy_lots" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlignToStrategyLots {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "align_to_strategy_lots" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlignToStrategyLots() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "pricing_method" field.</summary>
    public const int PricingMethodFieldNumber = 5;
    private readonly static uint PricingMethodDefaultValue = 0;

    private uint pricingMethod_;
    /// <summary>
    /// The way prices for secondary leg orders are calculated. One of PricingMethod enums.
    /// PRICING_METHOD_AVERAGE_ORDER_PRICE is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PricingMethod {
      get { if ((_hasBits0 & 16) != 0) { return pricingMethod_; } else { return PricingMethodDefaultValue; } }
      set {
        _hasBits0 |= 16;
        pricingMethod_ = value;
      }
    }
    /// <summary>Gets whether the "pricing_method" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPricingMethod {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "pricing_method" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPricingMethod() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "price_shifting" field.</summary>
    public const int PriceShiftingFieldNumber = 6;
    private global::Strategy2.PriceShifting priceShifting_;
    /// <summary>
    /// Price shifting parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.PriceShifting PriceShifting {
      get { return priceShifting_; }
      set {
        priceShifting_ = value;
      }
    }

    /// <summary>Field number for the "leg_descriptions" field.</summary>
    public const int LegDescriptionsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Strategy2.LimitOrderLegDescription> _repeated_legDescriptions_codec
        = pb::FieldCodec.ForMessage(58, global::Strategy2.LimitOrderLegDescription.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.LimitOrderLegDescription> legDescriptions_ = new pbc::RepeatedField<global::Strategy2.LimitOrderLegDescription>();
    /// <summary>
    /// Parameters for strategy legs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.LimitOrderLegDescription> LegDescriptions {
      get { return legDescriptions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyLimitOrderParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyLimitOrderParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (ReplenishOnPrimaryFill != other.ReplenishOnPrimaryFill) return false;
      if (OverfillMode != other.OverfillMode) return false;
      if (AlignToStrategyLots != other.AlignToStrategyLots) return false;
      if (PricingMethod != other.PricingMethod) return false;
      if (!object.Equals(PriceShifting, other.PriceShifting)) return false;
      if(!legDescriptions_.Equals(other.legDescriptions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasReplenishOnPrimaryFill) hash ^= ReplenishOnPrimaryFill.GetHashCode();
      if (HasOverfillMode) hash ^= OverfillMode.GetHashCode();
      if (HasAlignToStrategyLots) hash ^= AlignToStrategyLots.GetHashCode();
      if (HasPricingMethod) hash ^= PricingMethod.GetHashCode();
      if (priceShifting_ != null) hash ^= PriceShifting.GetHashCode();
      hash ^= legDescriptions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(16);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (HasOverfillMode) {
        output.WriteRawTag(24);
        output.WriteUInt32(OverfillMode);
      }
      if (HasAlignToStrategyLots) {
        output.WriteRawTag(32);
        output.WriteUInt32(AlignToStrategyLots);
      }
      if (HasPricingMethod) {
        output.WriteRawTag(40);
        output.WriteUInt32(PricingMethod);
      }
      if (priceShifting_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PriceShifting);
      }
      legDescriptions_.WriteTo(output, _repeated_legDescriptions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(16);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (HasOverfillMode) {
        output.WriteRawTag(24);
        output.WriteUInt32(OverfillMode);
      }
      if (HasAlignToStrategyLots) {
        output.WriteRawTag(32);
        output.WriteUInt32(AlignToStrategyLots);
      }
      if (HasPricingMethod) {
        output.WriteRawTag(40);
        output.WriteUInt32(PricingMethod);
      }
      if (priceShifting_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PriceShifting);
      }
      legDescriptions_.WriteTo(ref output, _repeated_legDescriptions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasReplenishOnPrimaryFill) {
        size += 1 + 1;
      }
      if (HasOverfillMode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OverfillMode);
      }
      if (HasAlignToStrategyLots) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AlignToStrategyLots);
      }
      if (HasPricingMethod) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PricingMethod);
      }
      if (priceShifting_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PriceShifting);
      }
      size += legDescriptions_.CalculateSize(_repeated_legDescriptions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyLimitOrderParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasReplenishOnPrimaryFill) {
        ReplenishOnPrimaryFill = other.ReplenishOnPrimaryFill;
      }
      if (other.HasOverfillMode) {
        OverfillMode = other.OverfillMode;
      }
      if (other.HasAlignToStrategyLots) {
        AlignToStrategyLots = other.AlignToStrategyLots;
      }
      if (other.HasPricingMethod) {
        PricingMethod = other.PricingMethod;
      }
      if (other.priceShifting_ != null) {
        if (priceShifting_ == null) {
          PriceShifting = new global::Strategy2.PriceShifting();
        }
        PriceShifting.MergeFrom(other.PriceShifting);
      }
      legDescriptions_.Add(other.legDescriptions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
          case 24: {
            OverfillMode = input.ReadUInt32();
            break;
          }
          case 32: {
            AlignToStrategyLots = input.ReadUInt32();
            break;
          }
          case 40: {
            PricingMethod = input.ReadUInt32();
            break;
          }
          case 50: {
            if (priceShifting_ == null) {
              PriceShifting = new global::Strategy2.PriceShifting();
            }
            input.ReadMessage(PriceShifting);
            break;
          }
          case 58: {
            legDescriptions_.AddEntriesFrom(input, _repeated_legDescriptions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
          case 24: {
            OverfillMode = input.ReadUInt32();
            break;
          }
          case 32: {
            AlignToStrategyLots = input.ReadUInt32();
            break;
          }
          case 40: {
            PricingMethod = input.ReadUInt32();
            break;
          }
          case 50: {
            if (priceShifting_ == null) {
              PriceShifting = new global::Strategy2.PriceShifting();
            }
            input.ReadMessage(PriceShifting);
            break;
          }
          case 58: {
            legDescriptions_.AddEntriesFrom(ref input, _repeated_legDescriptions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyLimitOrderParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Mode of overfill handling.
      /// </summary>
      public enum OverfillMode {
        /// <summary>
        /// Overfills are allowed and managed by trader.
        /// </summary>
        [pbr::OriginalName("OVERFILL_MODE_MANUAL")] Manual = 1,
        /// <summary>
        /// Overfills are allowed and must be hedged by the server according to strategy quantity ratios.
        /// </summary>
        [pbr::OriginalName("OVERFILL_MODE_AUTOMATIC_HEDGING")] AutomaticHedging = 2,
        /// <summary>
        /// Minimize probability of overfills.
        /// </summary>
        [pbr::OriginalName("OVERFILL_MODE_AVOID_OVERFILLS")] AvoidOverfills = 3,
      }

      /// <summary>
      /// Defines sizes of what leg orders must be aligned to strategy lots (opposite to work proportionally).
      /// </summary>
      public enum AlignToStrategyLots {
        /// <summary>
        /// Both primary and secondary leg orders could work its sizes proportionally (without aligning it to strategy lot).
        /// </summary>
        [pbr::OriginalName("ALIGN_TO_STRATEGY_LOTS_NONE")] None = 1,
        /// <summary>
        /// Secondary leg orders must align its size to strategy lots.
        /// </summary>
        [pbr::OriginalName("ALIGN_TO_STRATEGY_LOTS_SECONDARY_ONLY")] SecondaryOnly = 2,
        /// <summary>
        /// Both primary and secondary leg orders align its sizes to strategy lots.
        /// </summary>
        [pbr::OriginalName("ALIGN_TO_STRATEGY_LOTS_ALL")] All = 3,
      }

      /// <summary>
      /// The way prices for secondary orders are calculated.
      /// </summary>
      public enum PricingMethod {
        /// <summary>
        /// Respect each strategy lot price independently.
        /// </summary>
        [pbr::OriginalName("PRICING_METHOD_INDEPENDENT_LOT_PRICE")] IndependentLotPrice = 1,
        /// <summary>
        /// Respect average strategy order price.
        /// </summary>
        [pbr::OriginalName("PRICING_METHOD_AVERAGE_ORDER_PRICE")] AverageOrderPrice = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// STP order parameters of the root or a nested strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyStopOrderParameters : pb::IMessage<StrategyStopOrderParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyStopOrderParameters> _parser = new pb::MessageParser<StrategyStopOrderParameters>(() => new StrategyStopOrderParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyStopOrderParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyStopOrderParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyStopOrderParameters(StrategyStopOrderParameters other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      stopSide_ = other.stopSide_;
      replenishOnPrimaryFill_ = other.replenishOnPrimaryFill_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyStopOrderParameters Clone() {
      return new StrategyStopOrderParameters(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stop_side" field.</summary>
    public const int StopSideFieldNumber = 2;
    private readonly static uint StopSideDefaultValue = 0;

    private uint stopSide_;
    /// <summary>
    /// The side of strategy price that STP orders watch for. One of StopSide enums.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint StopSide {
      get { if ((_hasBits0 & 2) != 0) { return stopSide_; } else { return StopSideDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stopSide_ = value;
      }
    }
    /// <summary>Gets whether the "stop_side" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStopSide {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stop_side" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStopSide() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "replenish_on_primary_fill" field.</summary>
    public const int ReplenishOnPrimaryFillFieldNumber = 3;
    private readonly static bool ReplenishOnPrimaryFillDefaultValue = false;

    private bool replenishOnPrimaryFill_;
    /// <summary>
    /// For Iceberg orders:
    ///  'true' means replenish qty on the filled leg immediately upon receiving primary fill;
    ///  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
    ///          is filled or its qty changes for some other reason, e.g. replace request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReplenishOnPrimaryFill {
      get { if ((_hasBits0 & 4) != 0) { return replenishOnPrimaryFill_; } else { return ReplenishOnPrimaryFillDefaultValue; } }
      set {
        _hasBits0 |= 4;
        replenishOnPrimaryFill_ = value;
      }
    }
    /// <summary>Gets whether the "replenish_on_primary_fill" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReplenishOnPrimaryFill {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "replenish_on_primary_fill" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReplenishOnPrimaryFill() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyStopOrderParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyStopOrderParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (StopSide != other.StopSide) return false;
      if (ReplenishOnPrimaryFill != other.ReplenishOnPrimaryFill) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasStopSide) hash ^= StopSide.GetHashCode();
      if (HasReplenishOnPrimaryFill) hash ^= ReplenishOnPrimaryFill.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasStopSide) {
        output.WriteRawTag(16);
        output.WriteUInt32(StopSide);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(24);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasStopSide) {
        output.WriteRawTag(16);
        output.WriteUInt32(StopSide);
      }
      if (HasReplenishOnPrimaryFill) {
        output.WriteRawTag(24);
        output.WriteBool(ReplenishOnPrimaryFill);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasStopSide) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopSide);
      }
      if (HasReplenishOnPrimaryFill) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyStopOrderParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasStopSide) {
        StopSide = other.StopSide;
      }
      if (other.HasReplenishOnPrimaryFill) {
        ReplenishOnPrimaryFill = other.ReplenishOnPrimaryFill;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            StopSide = input.ReadUInt32();
            break;
          }
          case 24: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            StopSide = input.ReadUInt32();
            break;
          }
          case 24: {
            ReplenishOnPrimaryFill = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyStopOrderParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Enumeration of sides of strategy price that STP orders watch for.
      /// </summary>
      public enum StopSide {
        /// <summary>
        /// Bid price of strategy must be matched against STP price.
        /// </summary>
        [pbr::OriginalName("STOP_SIDE_BID")] Bid = 1,
        /// <summary>
        /// Ask price of strategy must be matched against STP price.
        /// </summary>
        [pbr::OriginalName("STOP_SIDE_ASK")] Ask = 2,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyAggregationParameters : pb::IMessage<StrategyAggregationParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyAggregationParameters> _parser = new pb::MessageParser<StrategyAggregationParameters>(() => new StrategyAggregationParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyAggregationParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyAggregationParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyAggregationParameters(StrategyAggregationParameters other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      overfillMode_ = other.overfillMode_;
      priceShifting_ = other.priceShifting_ != null ? other.priceShifting_.Clone() : null;
      patternLegs_ = other.patternLegs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyAggregationParameters Clone() {
      return new StrategyAggregationParameters(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "overfill_mode" field.</summary>
    public const int OverfillModeFieldNumber = 2;
    private readonly static uint OverfillModeDefaultValue = 0;

    private uint overfillMode_;
    /// <summary>
    /// Mode of overfill handling. One of AggrOverfillMode enums.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OverfillMode {
      get { if ((_hasBits0 & 2) != 0) { return overfillMode_; } else { return OverfillModeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        overfillMode_ = value;
      }
    }
    /// <summary>Gets whether the "overfill_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverfillMode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "overfill_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverfillMode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "price_shifting" field.</summary>
    public const int PriceShiftingFieldNumber = 3;
    private global::Strategy2.PriceShifting priceShifting_;
    /// <summary>
    /// Price shifting parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.PriceShifting PriceShifting {
      get { return priceShifting_; }
      set {
        priceShifting_ = value;
      }
    }

    /// <summary>Field number for the "pattern_legs" field.</summary>
    public const int PatternLegsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Strategy2.AggregationLegDescription> _repeated_patternLegs_codec
        = pb::FieldCodec.ForMessage(34, global::Strategy2.AggregationLegDescription.Parser);
    private readonly pbc::RepeatedField<global::Strategy2.AggregationLegDescription> patternLegs_ = new pbc::RepeatedField<global::Strategy2.AggregationLegDescription>();
    /// <summary>
    /// Aggregation legs parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Strategy2.AggregationLegDescription> PatternLegs {
      get { return patternLegs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyAggregationParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyAggregationParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (OverfillMode != other.OverfillMode) return false;
      if (!object.Equals(PriceShifting, other.PriceShifting)) return false;
      if(!patternLegs_.Equals(other.patternLegs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasOverfillMode) hash ^= OverfillMode.GetHashCode();
      if (priceShifting_ != null) hash ^= PriceShifting.GetHashCode();
      hash ^= patternLegs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasOverfillMode) {
        output.WriteRawTag(16);
        output.WriteUInt32(OverfillMode);
      }
      if (priceShifting_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PriceShifting);
      }
      patternLegs_.WriteTo(output, _repeated_patternLegs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasOverfillMode) {
        output.WriteRawTag(16);
        output.WriteUInt32(OverfillMode);
      }
      if (priceShifting_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PriceShifting);
      }
      patternLegs_.WriteTo(ref output, _repeated_patternLegs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasOverfillMode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OverfillMode);
      }
      if (priceShifting_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PriceShifting);
      }
      size += patternLegs_.CalculateSize(_repeated_patternLegs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyAggregationParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasOverfillMode) {
        OverfillMode = other.OverfillMode;
      }
      if (other.priceShifting_ != null) {
        if (priceShifting_ == null) {
          PriceShifting = new global::Strategy2.PriceShifting();
        }
        PriceShifting.MergeFrom(other.PriceShifting);
      }
      patternLegs_.Add(other.patternLegs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            OverfillMode = input.ReadUInt32();
            break;
          }
          case 26: {
            if (priceShifting_ == null) {
              PriceShifting = new global::Strategy2.PriceShifting();
            }
            input.ReadMessage(PriceShifting);
            break;
          }
          case 34: {
            patternLegs_.AddEntriesFrom(input, _repeated_patternLegs_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            OverfillMode = input.ReadUInt32();
            break;
          }
          case 26: {
            if (priceShifting_ == null) {
              PriceShifting = new global::Strategy2.PriceShifting();
            }
            input.ReadMessage(PriceShifting);
            break;
          }
          case 34: {
            patternLegs_.AddEntriesFrom(ref input, _repeated_patternLegs_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyAggregationParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Mode of overfill handling.
      /// </summary>
      public enum AggrOverfillMode {
        /// <summary>
        /// Minimize probability of overfills: don't place market taking LMT
        /// until existing market making LMT on other legs have quantity reduction acknowledge.
        /// </summary>
        [pbr::OriginalName("AGGR_OVERFILL_MODE_AVOID_OVERFILLS")] AvoidOverfills = 1,
        /// <summary>
        /// Place market taking LMTs and then attempt to reduce market making LMT quantity on other legs.
        /// There is a window of time where leg orders may be working that total more than the strategy order quantity.
        /// </summary>
        [pbr::OriginalName("AGGR_OVERFILL_MODE_ACCEPT_OVERFILL")] AcceptOverfill = 2,
        /// <summary>
        /// Place market taking LMT and wait to reduce market making LMT qty on other legs until
        /// the market taking LMT are filled (or cancelled after timeout).
        /// There is a much larger window of time where leg orders
        /// may be working that total more than the strategy order qty,
        /// but market making LMT don't lose their place in queue.
        /// </summary>
        [pbr::OriginalName("AGGR_OVERFILL_MODE_PRESERVE_QUEUE_POSITION")] PreserveQueuePosition = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Description of aggregation strategy legs.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AggregationLegDescription : pb::IMessage<AggregationLegDescription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AggregationLegDescription> _parser = new pb::MessageParser<AggregationLegDescription>(() => new AggregationLegDescription());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AggregationLegDescription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregationLegDescription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregationLegDescription(AggregationLegDescription other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      uint32WorkingThreshold_ = other.uint32WorkingThreshold_;
      workingThreshold_ = other.workingThreshold_ != null ? other.workingThreshold_.Clone() : null;
      marketTakingParameters_ = other.marketTakingParameters_ != null ? other.marketTakingParameters_.Clone() : null;
      marketMakingParameters_ = other.marketMakingParameters_ != null ? other.marketMakingParameters_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregationLegDescription Clone() {
      return new AggregationLegDescription(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to (LegDefinition.node_index value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_working_threshold" field.</summary>
    public const int Uint32WorkingThresholdFieldNumber = 2;
    private readonly static uint Uint32WorkingThresholdDefaultValue = 0;

    private uint uint32WorkingThreshold_;
    /// <summary>
    /// Note: use working_threshold instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32WorkingThreshold {
      get { if ((_hasBits0 & 2) != 0) { return uint32WorkingThreshold_; } else { return Uint32WorkingThresholdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32WorkingThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_working_threshold" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32WorkingThreshold {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_working_threshold" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32WorkingThreshold() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "working_threshold" field.</summary>
    public const int WorkingThresholdFieldNumber = 5;
    private global::Cqg.Decimal workingThreshold_;
    /// <summary>
    /// Threshold value for available quotes quantity to be considered
    /// (the quantities under this value are ignored).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal WorkingThreshold {
      get { return workingThreshold_; }
      set {
        workingThreshold_ = value;
      }
    }

    /// <summary>Field number for the "market_taking_parameters" field.</summary>
    public const int MarketTakingParametersFieldNumber = 3;
    private global::Strategy2.MarketTakingParameters marketTakingParameters_;
    /// <summary>
    /// The leg is executed in market taking mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.MarketTakingParameters MarketTakingParameters {
      get { return marketTakingParameters_; }
      set {
        marketTakingParameters_ = value;
      }
    }

    /// <summary>Field number for the "market_making_parameters" field.</summary>
    public const int MarketMakingParametersFieldNumber = 4;
    private global::Strategy2.MarketMakingParameters marketMakingParameters_;
    /// <summary>
    /// The leg is executed in market making mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.MarketMakingParameters MarketMakingParameters {
      get { return marketMakingParameters_; }
      set {
        marketMakingParameters_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AggregationLegDescription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AggregationLegDescription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (Uint32WorkingThreshold != other.Uint32WorkingThreshold) return false;
      if (!object.Equals(WorkingThreshold, other.WorkingThreshold)) return false;
      if (!object.Equals(MarketTakingParameters, other.MarketTakingParameters)) return false;
      if (!object.Equals(MarketMakingParameters, other.MarketMakingParameters)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasUint32WorkingThreshold) hash ^= Uint32WorkingThreshold.GetHashCode();
      if (workingThreshold_ != null) hash ^= WorkingThreshold.GetHashCode();
      if (marketTakingParameters_ != null) hash ^= MarketTakingParameters.GetHashCode();
      if (marketMakingParameters_ != null) hash ^= MarketMakingParameters.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasUint32WorkingThreshold) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32WorkingThreshold);
      }
      if (marketTakingParameters_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MarketTakingParameters);
      }
      if (marketMakingParameters_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MarketMakingParameters);
      }
      if (workingThreshold_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WorkingThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (HasUint32WorkingThreshold) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32WorkingThreshold);
      }
      if (marketTakingParameters_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MarketTakingParameters);
      }
      if (marketMakingParameters_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MarketMakingParameters);
      }
      if (workingThreshold_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WorkingThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasUint32WorkingThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32WorkingThreshold);
      }
      if (workingThreshold_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WorkingThreshold);
      }
      if (marketTakingParameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MarketTakingParameters);
      }
      if (marketMakingParameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MarketMakingParameters);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AggregationLegDescription other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasUint32WorkingThreshold) {
        Uint32WorkingThreshold = other.Uint32WorkingThreshold;
      }
      if (other.workingThreshold_ != null) {
        if (workingThreshold_ == null) {
          WorkingThreshold = new global::Cqg.Decimal();
        }
        WorkingThreshold.MergeFrom(other.WorkingThreshold);
      }
      if (other.marketTakingParameters_ != null) {
        if (marketTakingParameters_ == null) {
          MarketTakingParameters = new global::Strategy2.MarketTakingParameters();
        }
        MarketTakingParameters.MergeFrom(other.MarketTakingParameters);
      }
      if (other.marketMakingParameters_ != null) {
        if (marketMakingParameters_ == null) {
          MarketMakingParameters = new global::Strategy2.MarketMakingParameters();
        }
        MarketMakingParameters.MergeFrom(other.MarketMakingParameters);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            Uint32WorkingThreshold = input.ReadUInt32();
            break;
          }
          case 26: {
            if (marketTakingParameters_ == null) {
              MarketTakingParameters = new global::Strategy2.MarketTakingParameters();
            }
            input.ReadMessage(MarketTakingParameters);
            break;
          }
          case 34: {
            if (marketMakingParameters_ == null) {
              MarketMakingParameters = new global::Strategy2.MarketMakingParameters();
            }
            input.ReadMessage(MarketMakingParameters);
            break;
          }
          case 42: {
            if (workingThreshold_ == null) {
              WorkingThreshold = new global::Cqg.Decimal();
            }
            input.ReadMessage(WorkingThreshold);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            Uint32WorkingThreshold = input.ReadUInt32();
            break;
          }
          case 26: {
            if (marketTakingParameters_ == null) {
              MarketTakingParameters = new global::Strategy2.MarketTakingParameters();
            }
            input.ReadMessage(MarketTakingParameters);
            break;
          }
          case 34: {
            if (marketMakingParameters_ == null) {
              MarketMakingParameters = new global::Strategy2.MarketMakingParameters();
            }
            input.ReadMessage(MarketMakingParameters);
            break;
          }
          case 42: {
            if (workingThreshold_ == null) {
              WorkingThreshold = new global::Cqg.Decimal();
            }
            input.ReadMessage(WorkingThreshold);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Parameters for strategy price change depending on filled strategy size.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PriceShifting : pb::IMessage<PriceShifting>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PriceShifting> _parser = new pb::MessageParser<PriceShifting>(() => new PriceShifting());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PriceShifting> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceShifting() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceShifting(PriceShifting other) : this() {
      _hasBits0 = other._hasBits0;
      priceStep_ = other.priceStep_;
      uint32FilledQtyDelta_ = other.uint32FilledQtyDelta_;
      filledQtyDelta_ = other.filledQtyDelta_ != null ? other.filledQtyDelta_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceShifting Clone() {
      return new PriceShifting(this);
    }

    /// <summary>Field number for the "price_step" field.</summary>
    public const int PriceStepFieldNumber = 1;
    private readonly static int PriceStepDefaultValue = 0;

    private int priceStep_;
    /// <summary>
    /// step (in ticks) of each price change.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PriceStep {
      get { if ((_hasBits0 & 1) != 0) { return priceStep_; } else { return PriceStepDefaultValue; } }
      set {
        _hasBits0 |= 1;
        priceStep_ = value;
      }
    }
    /// <summary>Gets whether the "price_step" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceStep {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "price_step" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceStep() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_filled_qty_delta" field.</summary>
    public const int Uint32FilledQtyDeltaFieldNumber = 2;
    private readonly static uint Uint32FilledQtyDeltaDefaultValue = 0;

    private uint uint32FilledQtyDelta_;
    /// <summary>
    /// Note: use filled_qty_delta instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32FilledQtyDelta {
      get { if ((_hasBits0 & 2) != 0) { return uint32FilledQtyDelta_; } else { return Uint32FilledQtyDeltaDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32FilledQtyDelta_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_filled_qty_delta" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32FilledQtyDelta {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_filled_qty_delta" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32FilledQtyDelta() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "filled_qty_delta" field.</summary>
    public const int FilledQtyDeltaFieldNumber = 3;
    private global::Cqg.Decimal filledQtyDelta_;
    /// <summary>
    /// Size of strategy order that must be filled to perform next change of strategy order price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal FilledQtyDelta {
      get { return filledQtyDelta_; }
      set {
        filledQtyDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PriceShifting);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PriceShifting other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PriceStep != other.PriceStep) return false;
      if (Uint32FilledQtyDelta != other.Uint32FilledQtyDelta) return false;
      if (!object.Equals(FilledQtyDelta, other.FilledQtyDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPriceStep) hash ^= PriceStep.GetHashCode();
      if (HasUint32FilledQtyDelta) hash ^= Uint32FilledQtyDelta.GetHashCode();
      if (filledQtyDelta_ != null) hash ^= FilledQtyDelta.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPriceStep) {
        output.WriteRawTag(8);
        output.WriteInt32(PriceStep);
      }
      if (HasUint32FilledQtyDelta) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32FilledQtyDelta);
      }
      if (filledQtyDelta_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FilledQtyDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPriceStep) {
        output.WriteRawTag(8);
        output.WriteInt32(PriceStep);
      }
      if (HasUint32FilledQtyDelta) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32FilledQtyDelta);
      }
      if (filledQtyDelta_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FilledQtyDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPriceStep) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PriceStep);
      }
      if (HasUint32FilledQtyDelta) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32FilledQtyDelta);
      }
      if (filledQtyDelta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilledQtyDelta);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PriceShifting other) {
      if (other == null) {
        return;
      }
      if (other.HasPriceStep) {
        PriceStep = other.PriceStep;
      }
      if (other.HasUint32FilledQtyDelta) {
        Uint32FilledQtyDelta = other.Uint32FilledQtyDelta;
      }
      if (other.filledQtyDelta_ != null) {
        if (filledQtyDelta_ == null) {
          FilledQtyDelta = new global::Cqg.Decimal();
        }
        FilledQtyDelta.MergeFrom(other.FilledQtyDelta);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            PriceStep = input.ReadInt32();
            break;
          }
          case 16: {
            Uint32FilledQtyDelta = input.ReadUInt32();
            break;
          }
          case 26: {
            if (filledQtyDelta_ == null) {
              FilledQtyDelta = new global::Cqg.Decimal();
            }
            input.ReadMessage(FilledQtyDelta);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            PriceStep = input.ReadInt32();
            break;
          }
          case 16: {
            Uint32FilledQtyDelta = input.ReadUInt32();
            break;
          }
          case 26: {
            if (filledQtyDelta_ == null) {
              FilledQtyDelta = new global::Cqg.Decimal();
            }
            input.ReadMessage(FilledQtyDelta);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LMT order parameters for a leg.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LimitOrderLegDescription : pb::IMessage<LimitOrderLegDescription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LimitOrderLegDescription> _parser = new pb::MessageParser<LimitOrderLegDescription>(() => new LimitOrderLegDescription());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LimitOrderLegDescription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitOrderLegDescription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitOrderLegDescription(LimitOrderLegDescription other) : this() {
      _hasBits0 = other._hasBits0;
      nodeIndex_ = other.nodeIndex_;
      primaryOrderLimit_ = other.primaryOrderLimit_ != null ? other.primaryOrderLimit_.Clone() : null;
      primaryOrderSniper_ = other.primaryOrderSniper_ != null ? other.primaryOrderSniper_.Clone() : null;
      secondaryOrdersLimit_ = other.secondaryOrdersLimit_ != null ? other.secondaryOrdersLimit_.Clone() : null;
      secondaryOrdersMarket_ = other.secondaryOrdersMarket_ != null ? other.secondaryOrdersMarket_.Clone() : null;
      secondaryOrdersPayup_ = other.secondaryOrdersPayup_ != null ? other.secondaryOrdersPayup_.Clone() : null;
      secondaryOrdersTrailing_ = other.secondaryOrdersTrailing_ != null ? other.secondaryOrdersTrailing_.Clone() : null;
      proportionalExecutionRatio_ = other.proportionalExecutionRatio_;
      volumeMultiplier_ = other.volumeMultiplier_;
      uint32WorkThreshold_ = other.uint32WorkThreshold_;
      workThreshold_ = other.workThreshold_ != null ? other.workThreshold_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitOrderLegDescription Clone() {
      return new LimitOrderLegDescription(this);
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 1;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Node index in the strategy definition the parameters are related to
    /// (StrategyDefinition.node_index or LegDefinition.node_index value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 1) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "primary_order_limit" field.</summary>
    public const int PrimaryOrderLimitFieldNumber = 2;
    private global::Strategy2.PrimaryOrdersLimit primaryOrderLimit_;
    /// <summary>
    /// All the attributes below are mutually exclusive.
    /// Sets the leg as working and place LMT orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.PrimaryOrdersLimit PrimaryOrderLimit {
      get { return primaryOrderLimit_; }
      set {
        primaryOrderLimit_ = value;
      }
    }

    /// <summary>Field number for the "primary_order_sniper" field.</summary>
    public const int PrimaryOrderSniperFieldNumber = 3;
    private global::Strategy2.PrimaryOrdersSniper primaryOrderSniper_;
    /// <summary>
    /// Sets the leg as working and place sniper orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.PrimaryOrdersSniper PrimaryOrderSniper {
      get { return primaryOrderSniper_; }
      set {
        primaryOrderSniper_ = value;
      }
    }

    /// <summary>Field number for the "secondary_orders_limit" field.</summary>
    public const int SecondaryOrdersLimitFieldNumber = 4;
    private global::Strategy2.SecondaryOrdersLimit secondaryOrdersLimit_;
    /// <summary>
    /// Sets the leg as not working and place LMT orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.SecondaryOrdersLimit SecondaryOrdersLimit {
      get { return secondaryOrdersLimit_; }
      set {
        secondaryOrdersLimit_ = value;
      }
    }

    /// <summary>Field number for the "secondary_orders_market" field.</summary>
    public const int SecondaryOrdersMarketFieldNumber = 5;
    private global::Strategy2.SecondaryOrdersMarket secondaryOrdersMarket_;
    /// <summary>
    /// Sets the leg as not working and place MKT orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.SecondaryOrdersMarket SecondaryOrdersMarket {
      get { return secondaryOrdersMarket_; }
      set {
        secondaryOrdersMarket_ = value;
      }
    }

    /// <summary>Field number for the "secondary_orders_payup" field.</summary>
    public const int SecondaryOrdersPayupFieldNumber = 6;
    private global::Strategy2.SecondaryOrdersPayUp secondaryOrdersPayup_;
    /// <summary>
    /// Sets the leg as not working and place payup orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.SecondaryOrdersPayUp SecondaryOrdersPayup {
      get { return secondaryOrdersPayup_; }
      set {
        secondaryOrdersPayup_ = value;
      }
    }

    /// <summary>Field number for the "secondary_orders_trailing" field.</summary>
    public const int SecondaryOrdersTrailingFieldNumber = 7;
    private global::Strategy2.SecondaryOrdersTrailing secondaryOrdersTrailing_;
    /// <summary>
    /// Sets the leg as not working and place trailing orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Strategy2.SecondaryOrdersTrailing SecondaryOrdersTrailing {
      get { return secondaryOrdersTrailing_; }
      set {
        secondaryOrdersTrailing_ = value;
      }
    }

    /// <summary>Field number for the "proportional_execution_ratio" field.</summary>
    public const int ProportionalExecutionRatioFieldNumber = 8;
    private readonly static double ProportionalExecutionRatioDefaultValue = 0D;

    private double proportionalExecutionRatio_;
    /// <summary>
    /// Indicates how many lots (in fractions) should be filled before the second leg order is placed.
    /// Allowed range 0-1.
    /// Default is off, the secondary leg placed after all lots are filled on the primary leg.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ProportionalExecutionRatio {
      get { if ((_hasBits0 & 2) != 0) { return proportionalExecutionRatio_; } else { return ProportionalExecutionRatioDefaultValue; } }
      set {
        _hasBits0 |= 2;
        proportionalExecutionRatio_ = value;
      }
    }
    /// <summary>Gets whether the "proportional_execution_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProportionalExecutionRatio {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "proportional_execution_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProportionalExecutionRatio() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "volume_multiplier" field.</summary>
    public const int VolumeMultiplierFieldNumber = 9;
    private readonly static double VolumeMultiplierDefaultValue = 0D;

    private double volumeMultiplier_;
    /// <summary>
    /// Determines the size of working orders based on a percentage of the resting volume
    /// available in the queue of the monitored leg.
    /// Allowed range 0-1000.
    /// Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double VolumeMultiplier {
      get { if ((_hasBits0 & 4) != 0) { return volumeMultiplier_; } else { return VolumeMultiplierDefaultValue; } }
      set {
        _hasBits0 |= 4;
        volumeMultiplier_ = value;
      }
    }
    /// <summary>Gets whether the "volume_multiplier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeMultiplier {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "volume_multiplier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeMultiplier() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "uint32_work_threshold" field.</summary>
    public const int Uint32WorkThresholdFieldNumber = 10;
    private readonly static uint Uint32WorkThresholdDefaultValue = 0;

    private uint uint32WorkThreshold_;
    /// <summary>
    /// Note: use work_threshold field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32WorkThreshold {
      get { if ((_hasBits0 & 8) != 0) { return uint32WorkThreshold_; } else { return Uint32WorkThresholdDefaultValue; } }
      set {
        _hasBits0 |= 8;
        uint32WorkThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_work_threshold" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32WorkThreshold {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "uint32_work_threshold" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32WorkThreshold() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "work_threshold" field.</summary>
    public const int WorkThresholdFieldNumber = 11;
    private global::Cqg.Decimal workThreshold_;
    /// <summary>
    /// Tells the system to work the order if and only if
    /// the available quantity in the monitored leg is and remains greater than this value.
    /// Default is 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal WorkThreshold {
      get { return workThreshold_; }
      set {
        workThreshold_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LimitOrderLegDescription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LimitOrderLegDescription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeIndex != other.NodeIndex) return false;
      if (!object.Equals(PrimaryOrderLimit, other.PrimaryOrderLimit)) return false;
      if (!object.Equals(PrimaryOrderSniper, other.PrimaryOrderSniper)) return false;
      if (!object.Equals(SecondaryOrdersLimit, other.SecondaryOrdersLimit)) return false;
      if (!object.Equals(SecondaryOrdersMarket, other.SecondaryOrdersMarket)) return false;
      if (!object.Equals(SecondaryOrdersPayup, other.SecondaryOrdersPayup)) return false;
      if (!object.Equals(SecondaryOrdersTrailing, other.SecondaryOrdersTrailing)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ProportionalExecutionRatio, other.ProportionalExecutionRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(VolumeMultiplier, other.VolumeMultiplier)) return false;
      if (Uint32WorkThreshold != other.Uint32WorkThreshold) return false;
      if (!object.Equals(WorkThreshold, other.WorkThreshold)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (primaryOrderLimit_ != null) hash ^= PrimaryOrderLimit.GetHashCode();
      if (primaryOrderSniper_ != null) hash ^= PrimaryOrderSniper.GetHashCode();
      if (secondaryOrdersLimit_ != null) hash ^= SecondaryOrdersLimit.GetHashCode();
      if (secondaryOrdersMarket_ != null) hash ^= SecondaryOrdersMarket.GetHashCode();
      if (secondaryOrdersPayup_ != null) hash ^= SecondaryOrdersPayup.GetHashCode();
      if (secondaryOrdersTrailing_ != null) hash ^= SecondaryOrdersTrailing.GetHashCode();
      if (HasProportionalExecutionRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ProportionalExecutionRatio);
      if (HasVolumeMultiplier) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(VolumeMultiplier);
      if (HasUint32WorkThreshold) hash ^= Uint32WorkThreshold.GetHashCode();
      if (workThreshold_ != null) hash ^= WorkThreshold.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (primaryOrderLimit_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrimaryOrderLimit);
      }
      if (primaryOrderSniper_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PrimaryOrderSniper);
      }
      if (secondaryOrdersLimit_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecondaryOrdersLimit);
      }
      if (secondaryOrdersMarket_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecondaryOrdersMarket);
      }
      if (secondaryOrdersPayup_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SecondaryOrdersPayup);
      }
      if (secondaryOrdersTrailing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecondaryOrdersTrailing);
      }
      if (HasProportionalExecutionRatio) {
        output.WriteRawTag(65);
        output.WriteDouble(ProportionalExecutionRatio);
      }
      if (HasVolumeMultiplier) {
        output.WriteRawTag(73);
        output.WriteDouble(VolumeMultiplier);
      }
      if (HasUint32WorkThreshold) {
        output.WriteRawTag(80);
        output.WriteUInt32(Uint32WorkThreshold);
      }
      if (workThreshold_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(WorkThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(NodeIndex);
      }
      if (primaryOrderLimit_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrimaryOrderLimit);
      }
      if (primaryOrderSniper_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PrimaryOrderSniper);
      }
      if (secondaryOrdersLimit_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecondaryOrdersLimit);
      }
      if (secondaryOrdersMarket_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecondaryOrdersMarket);
      }
      if (secondaryOrdersPayup_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SecondaryOrdersPayup);
      }
      if (secondaryOrdersTrailing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecondaryOrdersTrailing);
      }
      if (HasProportionalExecutionRatio) {
        output.WriteRawTag(65);
        output.WriteDouble(ProportionalExecutionRatio);
      }
      if (HasVolumeMultiplier) {
        output.WriteRawTag(73);
        output.WriteDouble(VolumeMultiplier);
      }
      if (HasUint32WorkThreshold) {
        output.WriteRawTag(80);
        output.WriteUInt32(Uint32WorkThreshold);
      }
      if (workThreshold_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(WorkThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (primaryOrderLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrimaryOrderLimit);
      }
      if (primaryOrderSniper_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrimaryOrderSniper);
      }
      if (secondaryOrdersLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecondaryOrdersLimit);
      }
      if (secondaryOrdersMarket_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecondaryOrdersMarket);
      }
      if (secondaryOrdersPayup_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecondaryOrdersPayup);
      }
      if (secondaryOrdersTrailing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecondaryOrdersTrailing);
      }
      if (HasProportionalExecutionRatio) {
        size += 1 + 8;
      }
      if (HasVolumeMultiplier) {
        size += 1 + 8;
      }
      if (HasUint32WorkThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32WorkThreshold);
      }
      if (workThreshold_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WorkThreshold);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LimitOrderLegDescription other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.primaryOrderLimit_ != null) {
        if (primaryOrderLimit_ == null) {
          PrimaryOrderLimit = new global::Strategy2.PrimaryOrdersLimit();
        }
        PrimaryOrderLimit.MergeFrom(other.PrimaryOrderLimit);
      }
      if (other.primaryOrderSniper_ != null) {
        if (primaryOrderSniper_ == null) {
          PrimaryOrderSniper = new global::Strategy2.PrimaryOrdersSniper();
        }
        PrimaryOrderSniper.MergeFrom(other.PrimaryOrderSniper);
      }
      if (other.secondaryOrdersLimit_ != null) {
        if (secondaryOrdersLimit_ == null) {
          SecondaryOrdersLimit = new global::Strategy2.SecondaryOrdersLimit();
        }
        SecondaryOrdersLimit.MergeFrom(other.SecondaryOrdersLimit);
      }
      if (other.secondaryOrdersMarket_ != null) {
        if (secondaryOrdersMarket_ == null) {
          SecondaryOrdersMarket = new global::Strategy2.SecondaryOrdersMarket();
        }
        SecondaryOrdersMarket.MergeFrom(other.SecondaryOrdersMarket);
      }
      if (other.secondaryOrdersPayup_ != null) {
        if (secondaryOrdersPayup_ == null) {
          SecondaryOrdersPayup = new global::Strategy2.SecondaryOrdersPayUp();
        }
        SecondaryOrdersPayup.MergeFrom(other.SecondaryOrdersPayup);
      }
      if (other.secondaryOrdersTrailing_ != null) {
        if (secondaryOrdersTrailing_ == null) {
          SecondaryOrdersTrailing = new global::Strategy2.SecondaryOrdersTrailing();
        }
        SecondaryOrdersTrailing.MergeFrom(other.SecondaryOrdersTrailing);
      }
      if (other.HasProportionalExecutionRatio) {
        ProportionalExecutionRatio = other.ProportionalExecutionRatio;
      }
      if (other.HasVolumeMultiplier) {
        VolumeMultiplier = other.VolumeMultiplier;
      }
      if (other.HasUint32WorkThreshold) {
        Uint32WorkThreshold = other.Uint32WorkThreshold;
      }
      if (other.workThreshold_ != null) {
        if (workThreshold_ == null) {
          WorkThreshold = new global::Cqg.Decimal();
        }
        WorkThreshold.MergeFrom(other.WorkThreshold);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 18: {
            if (primaryOrderLimit_ == null) {
              PrimaryOrderLimit = new global::Strategy2.PrimaryOrdersLimit();
            }
            input.ReadMessage(PrimaryOrderLimit);
            break;
          }
          case 26: {
            if (primaryOrderSniper_ == null) {
              PrimaryOrderSniper = new global::Strategy2.PrimaryOrdersSniper();
            }
            input.ReadMessage(PrimaryOrderSniper);
            break;
          }
          case 34: {
            if (secondaryOrdersLimit_ == null) {
              SecondaryOrdersLimit = new global::Strategy2.SecondaryOrdersLimit();
            }
            input.ReadMessage(SecondaryOrdersLimit);
            break;
          }
          case 42: {
            if (secondaryOrdersMarket_ == null) {
              SecondaryOrdersMarket = new global::Strategy2.SecondaryOrdersMarket();
            }
            input.ReadMessage(SecondaryOrdersMarket);
            break;
          }
          case 50: {
            if (secondaryOrdersPayup_ == null) {
              SecondaryOrdersPayup = new global::Strategy2.SecondaryOrdersPayUp();
            }
            input.ReadMessage(SecondaryOrdersPayup);
            break;
          }
          case 58: {
            if (secondaryOrdersTrailing_ == null) {
              SecondaryOrdersTrailing = new global::Strategy2.SecondaryOrdersTrailing();
            }
            input.ReadMessage(SecondaryOrdersTrailing);
            break;
          }
          case 65: {
            ProportionalExecutionRatio = input.ReadDouble();
            break;
          }
          case 73: {
            VolumeMultiplier = input.ReadDouble();
            break;
          }
          case 80: {
            Uint32WorkThreshold = input.ReadUInt32();
            break;
          }
          case 90: {
            if (workThreshold_ == null) {
              WorkThreshold = new global::Cqg.Decimal();
            }
            input.ReadMessage(WorkThreshold);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 18: {
            if (primaryOrderLimit_ == null) {
              PrimaryOrderLimit = new global::Strategy2.PrimaryOrdersLimit();
            }
            input.ReadMessage(PrimaryOrderLimit);
            break;
          }
          case 26: {
            if (primaryOrderSniper_ == null) {
              PrimaryOrderSniper = new global::Strategy2.PrimaryOrdersSniper();
            }
            input.ReadMessage(PrimaryOrderSniper);
            break;
          }
          case 34: {
            if (secondaryOrdersLimit_ == null) {
              SecondaryOrdersLimit = new global::Strategy2.SecondaryOrdersLimit();
            }
            input.ReadMessage(SecondaryOrdersLimit);
            break;
          }
          case 42: {
            if (secondaryOrdersMarket_ == null) {
              SecondaryOrdersMarket = new global::Strategy2.SecondaryOrdersMarket();
            }
            input.ReadMessage(SecondaryOrdersMarket);
            break;
          }
          case 50: {
            if (secondaryOrdersPayup_ == null) {
              SecondaryOrdersPayup = new global::Strategy2.SecondaryOrdersPayUp();
            }
            input.ReadMessage(SecondaryOrdersPayup);
            break;
          }
          case 58: {
            if (secondaryOrdersTrailing_ == null) {
              SecondaryOrdersTrailing = new global::Strategy2.SecondaryOrdersTrailing();
            }
            input.ReadMessage(SecondaryOrdersTrailing);
            break;
          }
          case 65: {
            ProportionalExecutionRatio = input.ReadDouble();
            break;
          }
          case 73: {
            VolumeMultiplier = input.ReadDouble();
            break;
          }
          case 80: {
            Uint32WorkThreshold = input.ReadUInt32();
            break;
          }
          case 90: {
            if (workThreshold_ == null) {
              WorkThreshold = new global::Cqg.Decimal();
            }
            input.ReadMessage(WorkThreshold);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Parameters of LMT orders on a leg which is currently working.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PrimaryOrdersLimit : pb::IMessage<PrimaryOrdersLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PrimaryOrdersLimit> _parser = new pb::MessageParser<PrimaryOrdersLimit>(() => new PrimaryOrdersLimit());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PrimaryOrdersLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersLimit(PrimaryOrdersLimit other) : this() {
      _hasBits0 = other._hasBits0;
      uint32MinQtyIncrement_ = other.uint32MinQtyIncrement_;
      minQtyIncrement_ = other.minQtyIncrement_ != null ? other.minQtyIncrement_.Clone() : null;
      queueHoldersMinSize_ = other.queueHoldersMinSize_;
      queueHoldersMaxSize_ = other.queueHoldersMaxSize_;
      queueHoldersDistance_ = other.queueHoldersDistance_;
      orderSizeRestoreThreshold_ = other.orderSizeRestoreThreshold_;
      uint32VisibleQty_ = other.uint32VisibleQty_;
      visibleQty_ = other.visibleQty_ != null ? other.visibleQty_.Clone() : null;
      uint32MinVisibleQty_ = other.uint32MinVisibleQty_;
      minVisibleQty_ = other.minVisibleQty_ != null ? other.minVisibleQty_.Clone() : null;
      workingOrdersPriceRange_ = other.workingOrdersPriceRange_;
      minPriceChange_ = other.minPriceChange_;
      primaryOrdersFifoQueueSize_ = other.primaryOrdersFifoQueueSize_;
      forceUpdatePeriod_ = other.forceUpdatePeriod_;
      ignoreObservedMarkets_ = other.ignoreObservedMarkets_;
      maxDimming_ = other.maxDimming_;
      farFromMarketMode_ = other.farFromMarketMode_;
      ticksAwayToWork_ = other.ticksAwayToWork_;
      domUsage_ = other.domUsage_;
      domMultilevelQty_ = other.domMultilevelQty_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersLimit Clone() {
      return new PrimaryOrdersLimit(this);
    }

    /// <summary>Field number for the "uint32_min_qty_increment" field.</summary>
    public const int Uint32MinQtyIncrementFieldNumber = 1;
    private readonly static uint Uint32MinQtyIncrementDefaultValue = 0;

    private uint uint32MinQtyIncrement_;
    /// <summary>
    /// Note: use min_qty_increment field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32MinQtyIncrement {
      get { if ((_hasBits0 & 1) != 0) { return uint32MinQtyIncrement_; } else { return Uint32MinQtyIncrementDefaultValue; } }
      set {
        _hasBits0 |= 1;
        uint32MinQtyIncrement_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_min_qty_increment" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32MinQtyIncrement {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "uint32_min_qty_increment" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32MinQtyIncrement() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "min_qty_increment" field.</summary>
    public const int MinQtyIncrementFieldNumber = 18;
    private global::Cqg.Decimal minQtyIncrement_;
    /// <summary>
    /// Place an order only if the quantity available in the monitored leg is at least this much and
    /// to modify a working order only if the quantity available in the monitored leg increases by at least this much.
    /// Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal MinQtyIncrement {
      get { return minQtyIncrement_; }
      set {
        minQtyIncrement_ = value;
      }
    }

    /// <summary>Field number for the "queue_holders_min_size" field.</summary>
    public const int QueueHoldersMinSizeFieldNumber = 2;
    private readonly static uint QueueHoldersMinSizeDefaultValue = 0;

    private uint queueHoldersMinSize_;
    /// <summary>
    /// Queue holders (stacked orders) are additional orders placed in the queue
    /// at specified price levels away from the initial working order.
    /// Sets the minimum number of orders to include in the queue.
    /// Allowed values: 1-10, default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint QueueHoldersMinSize {
      get { if ((_hasBits0 & 2) != 0) { return queueHoldersMinSize_; } else { return QueueHoldersMinSizeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        queueHoldersMinSize_ = value;
      }
    }
    /// <summary>Gets whether the "queue_holders_min_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQueueHoldersMinSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "queue_holders_min_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQueueHoldersMinSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "queue_holders_max_size" field.</summary>
    public const int QueueHoldersMaxSizeFieldNumber = 3;
    private readonly static uint QueueHoldersMaxSizeDefaultValue = 0;

    private uint queueHoldersMaxSize_;
    /// <summary>
    /// Sets the maximum number of orders to include in the queue.
    /// Allowed values: 1-10 and not less than queue_holders_min_size, default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint QueueHoldersMaxSize {
      get { if ((_hasBits0 & 4) != 0) { return queueHoldersMaxSize_; } else { return QueueHoldersMaxSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        queueHoldersMaxSize_ = value;
      }
    }
    /// <summary>Gets whether the "queue_holders_max_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQueueHoldersMaxSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "queue_holders_max_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQueueHoldersMaxSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "queue_holders_distance" field.</summary>
    public const int QueueHoldersDistanceFieldNumber = 4;
    private readonly static uint QueueHoldersDistanceDefaultValue = 0;

    private uint queueHoldersDistance_;
    /// <summary>
    /// Indicates how many price levels (ticks) to skip between orders in the queue.
    /// Allowed range is 1-5, default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint QueueHoldersDistance {
      get { if ((_hasBits0 & 8) != 0) { return queueHoldersDistance_; } else { return QueueHoldersDistanceDefaultValue; } }
      set {
        _hasBits0 |= 8;
        queueHoldersDistance_ = value;
      }
    }
    /// <summary>Gets whether the "queue_holders_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQueueHoldersDistance {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "queue_holders_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQueueHoldersDistance() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "order_size_restore_threshold" field.</summary>
    public const int OrderSizeRestoreThresholdFieldNumber = 5;
    private readonly static uint OrderSizeRestoreThresholdDefaultValue = 0;

    private uint orderSizeRestoreThreshold_;
    /// <summary>
    /// Indicates how far the market should run
    /// before maximizing size of a recently placed order that is now part of the group of stacked orders.
    /// Must be less than queue_holders_min_size, default is 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OrderSizeRestoreThreshold {
      get { if ((_hasBits0 & 16) != 0) { return orderSizeRestoreThreshold_; } else { return OrderSizeRestoreThresholdDefaultValue; } }
      set {
        _hasBits0 |= 16;
        orderSizeRestoreThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "order_size_restore_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderSizeRestoreThreshold {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "order_size_restore_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderSizeRestoreThreshold() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "uint32_visible_qty" field.</summary>
    public const int Uint32VisibleQtyFieldNumber = 6;
    private readonly static uint Uint32VisibleQtyDefaultValue = 0;

    private uint uint32VisibleQty_;
    /// <summary>
    /// Note: use visible_qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32VisibleQty {
      get { if ((_hasBits0 & 32) != 0) { return uint32VisibleQty_; } else { return Uint32VisibleQtyDefaultValue; } }
      set {
        _hasBits0 |= 32;
        uint32VisibleQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_visible_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32VisibleQty {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "uint32_visible_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32VisibleQty() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "visible_qty" field.</summary>
    public const int VisibleQtyFieldNumber = 19;
    private global::Cqg.Decimal visibleQty_;
    /// <summary>
    /// Primary Iceberg order visible size in lots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal VisibleQty {
      get { return visibleQty_; }
      set {
        visibleQty_ = value;
      }
    }

    /// <summary>Field number for the "uint32_min_visible_qty" field.</summary>
    public const int Uint32MinVisibleQtyFieldNumber = 7;
    private readonly static uint Uint32MinVisibleQtyDefaultValue = 0;

    private uint uint32MinVisibleQty_;
    /// <summary>
    /// Note: use min_visible_qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32MinVisibleQty {
      get { if ((_hasBits0 & 64) != 0) { return uint32MinVisibleQty_; } else { return Uint32MinVisibleQtyDefaultValue; } }
      set {
        _hasBits0 |= 64;
        uint32MinVisibleQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_min_visible_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32MinVisibleQty {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "uint32_min_visible_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32MinVisibleQty() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "min_visible_qty" field.</summary>
    public const int MinVisibleQtyFieldNumber = 20;
    private global::Cqg.Decimal minVisibleQty_;
    /// <summary>
    /// Primary Iceberg order min visible size in lots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal MinVisibleQty {
      get { return minVisibleQty_; }
      set {
        minVisibleQty_ = value;
      }
    }

    /// <summary>Field number for the "working_orders_price_range" field.</summary>
    public const int WorkingOrdersPriceRangeFieldNumber = 8;
    private readonly static uint WorkingOrdersPriceRangeDefaultValue = 0;

    private uint workingOrdersPriceRange_;
    /// <summary>
    /// Maximal distance between the market price and the old/new limit price of working primary leg
    /// orders, which allows modifications of these orders' prices(in ticks).
    /// Zero value is acceptable and means that the orders are modified at any distance.
    /// 0 is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint WorkingOrdersPriceRange {
      get { if ((_hasBits0 & 128) != 0) { return workingOrdersPriceRange_; } else { return WorkingOrdersPriceRangeDefaultValue; } }
      set {
        _hasBits0 |= 128;
        workingOrdersPriceRange_ = value;
      }
    }
    /// <summary>Gets whether the "working_orders_price_range" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingOrdersPriceRange {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "working_orders_price_range" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingOrdersPriceRange() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "min_price_change" field.</summary>
    public const int MinPriceChangeFieldNumber = 9;
    private readonly static uint MinPriceChangeDefaultValue = 0;

    private uint minPriceChange_;
    /// <summary>
    /// Minimal difference between the old and the new limit prices of working
    /// primary leg orders, which allows modifications of these orders' prices (in ticks).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MinPriceChange {
      get { if ((_hasBits0 & 256) != 0) { return minPriceChange_; } else { return MinPriceChangeDefaultValue; } }
      set {
        _hasBits0 |= 256;
        minPriceChange_ = value;
      }
    }
    /// <summary>Gets whether the "min_price_change" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinPriceChange {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "min_price_change" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinPriceChange() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "primary_orders_fifo_queue_size" field.</summary>
    public const int PrimaryOrdersFifoQueueSizeFieldNumber = 10;
    private readonly static uint PrimaryOrdersFifoQueueSizeDefaultValue = 0;

    private uint primaryOrdersFifoQueueSize_;
    /// <summary>
    /// Maximum number of leg orders per price level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PrimaryOrdersFifoQueueSize {
      get { if ((_hasBits0 & 512) != 0) { return primaryOrdersFifoQueueSize_; } else { return PrimaryOrdersFifoQueueSizeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        primaryOrdersFifoQueueSize_ = value;
      }
    }
    /// <summary>Gets whether the "primary_orders_fifo_queue_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrimaryOrdersFifoQueueSize {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "primary_orders_fifo_queue_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrimaryOrdersFifoQueueSize() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "force_update_period" field.</summary>
    public const int ForceUpdatePeriodFieldNumber = 11;
    private readonly static uint ForceUpdatePeriodDefaultValue = 0;

    private uint forceUpdatePeriod_;
    /// <summary>
    /// Period of updates to the working leg in milliseconds, such that every N ms,
    /// the leg is put where it ought to be placed based upon current prices.
    /// Default is to use the server settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ForceUpdatePeriod {
      get { if ((_hasBits0 & 1024) != 0) { return forceUpdatePeriod_; } else { return ForceUpdatePeriodDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        forceUpdatePeriod_ = value;
      }
    }
    /// <summary>Gets whether the "force_update_period" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasForceUpdatePeriod {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "force_update_period" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearForceUpdatePeriod() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "ignore_observed_markets" field.</summary>
    public const int IgnoreObservedMarketsFieldNumber = 12;
    private readonly static bool IgnoreObservedMarketsDefaultValue = false;

    private bool ignoreObservedMarkets_;
    /// <summary>
    /// Flag that shows whether observed markets must be used for primary orders size calculation or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IgnoreObservedMarkets {
      get { if ((_hasBits0 & 2048) != 0) { return ignoreObservedMarkets_; } else { return IgnoreObservedMarketsDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        ignoreObservedMarkets_ = value;
      }
    }
    /// <summary>Gets whether the "ignore_observed_markets" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIgnoreObservedMarkets {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "ignore_observed_markets" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIgnoreObservedMarkets() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "max_dimming" field.</summary>
    public const int MaxDimmingFieldNumber = 13;
    private readonly static uint MaxDimmingDefaultValue = 0;

    private uint maxDimming_;
    /// <summary>
    /// Specifies (in ticks) maximum distance
    /// primary order price could be moved from target one while creating best bid/ask.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxDimming {
      get { if ((_hasBits0 & 4096) != 0) { return maxDimming_; } else { return MaxDimmingDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        maxDimming_ = value;
      }
    }
    /// <summary>Gets whether the "max_dimming" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxDimming {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "max_dimming" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxDimming() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "far_from_market_mode" field.</summary>
    public const int FarFromMarketModeFieldNumber = 14;
    private readonly static uint FarFromMarketModeDefaultValue = 0;

    private uint farFromMarketMode_;
    /// <summary>
    /// Mode of handling primary leg orders with target price far from market. One of FarFromMarketMode enums.
    /// Default is to use the server settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint FarFromMarketMode {
      get { if ((_hasBits0 & 8192) != 0) { return farFromMarketMode_; } else { return FarFromMarketModeDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        farFromMarketMode_ = value;
      }
    }
    /// <summary>Gets whether the "far_from_market_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFarFromMarketMode {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "far_from_market_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFarFromMarketMode() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "ticks_away_to_work" field.</summary>
    public const int TicksAwayToWorkFieldNumber = 15;
    private readonly static int TicksAwayToWorkDefaultValue = 0;

    private int ticksAwayToWork_;
    /// <summary>
    /// Defines if and where server must work quantity that cannot lean onto current best bid/offer.
    /// Allowed range 0-9, default is to use the server setting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TicksAwayToWork {
      get { if ((_hasBits0 & 16384) != 0) { return ticksAwayToWork_; } else { return TicksAwayToWorkDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        ticksAwayToWork_ = value;
      }
    }
    /// <summary>Gets whether the "ticks_away_to_work" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTicksAwayToWork {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "ticks_away_to_work" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTicksAwayToWork() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "dom_usage" field.</summary>
    public const int DomUsageFieldNumber = 16;
    private readonly static uint DomUsageDefaultValue = 0;

    private uint domUsage_;
    /// <summary>
    /// How to work orders considering DOM data. One of DOMUsageMode enums. TOP_ONLY is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DomUsage {
      get { if ((_hasBits0 & 32768) != 0) { return domUsage_; } else { return DomUsageDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        domUsage_ = value;
      }
    }
    /// <summary>Gets whether the "dom_usage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDomUsage {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "dom_usage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDomUsage() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "dom_multilevel_qty" field.</summary>
    public const int DomMultilevelQtyFieldNumber = 17;
    private readonly static uint DomMultilevelQtyDefaultValue = 0;

    private uint domMultilevelQty_;
    /// <summary>
    /// Work up to this number of orders to get required volume if dom_usage is DOM_USAGE_MODE_MULTILEVELS.
    /// Allowed range 1-10, default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DomMultilevelQty {
      get { if ((_hasBits0 & 65536) != 0) { return domMultilevelQty_; } else { return DomMultilevelQtyDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        domMultilevelQty_ = value;
      }
    }
    /// <summary>Gets whether the "dom_multilevel_qty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDomMultilevelQty {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "dom_multilevel_qty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDomMultilevelQty() {
      _hasBits0 &= ~65536;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PrimaryOrdersLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PrimaryOrdersLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uint32MinQtyIncrement != other.Uint32MinQtyIncrement) return false;
      if (!object.Equals(MinQtyIncrement, other.MinQtyIncrement)) return false;
      if (QueueHoldersMinSize != other.QueueHoldersMinSize) return false;
      if (QueueHoldersMaxSize != other.QueueHoldersMaxSize) return false;
      if (QueueHoldersDistance != other.QueueHoldersDistance) return false;
      if (OrderSizeRestoreThreshold != other.OrderSizeRestoreThreshold) return false;
      if (Uint32VisibleQty != other.Uint32VisibleQty) return false;
      if (!object.Equals(VisibleQty, other.VisibleQty)) return false;
      if (Uint32MinVisibleQty != other.Uint32MinVisibleQty) return false;
      if (!object.Equals(MinVisibleQty, other.MinVisibleQty)) return false;
      if (WorkingOrdersPriceRange != other.WorkingOrdersPriceRange) return false;
      if (MinPriceChange != other.MinPriceChange) return false;
      if (PrimaryOrdersFifoQueueSize != other.PrimaryOrdersFifoQueueSize) return false;
      if (ForceUpdatePeriod != other.ForceUpdatePeriod) return false;
      if (IgnoreObservedMarkets != other.IgnoreObservedMarkets) return false;
      if (MaxDimming != other.MaxDimming) return false;
      if (FarFromMarketMode != other.FarFromMarketMode) return false;
      if (TicksAwayToWork != other.TicksAwayToWork) return false;
      if (DomUsage != other.DomUsage) return false;
      if (DomMultilevelQty != other.DomMultilevelQty) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUint32MinQtyIncrement) hash ^= Uint32MinQtyIncrement.GetHashCode();
      if (minQtyIncrement_ != null) hash ^= MinQtyIncrement.GetHashCode();
      if (HasQueueHoldersMinSize) hash ^= QueueHoldersMinSize.GetHashCode();
      if (HasQueueHoldersMaxSize) hash ^= QueueHoldersMaxSize.GetHashCode();
      if (HasQueueHoldersDistance) hash ^= QueueHoldersDistance.GetHashCode();
      if (HasOrderSizeRestoreThreshold) hash ^= OrderSizeRestoreThreshold.GetHashCode();
      if (HasUint32VisibleQty) hash ^= Uint32VisibleQty.GetHashCode();
      if (visibleQty_ != null) hash ^= VisibleQty.GetHashCode();
      if (HasUint32MinVisibleQty) hash ^= Uint32MinVisibleQty.GetHashCode();
      if (minVisibleQty_ != null) hash ^= MinVisibleQty.GetHashCode();
      if (HasWorkingOrdersPriceRange) hash ^= WorkingOrdersPriceRange.GetHashCode();
      if (HasMinPriceChange) hash ^= MinPriceChange.GetHashCode();
      if (HasPrimaryOrdersFifoQueueSize) hash ^= PrimaryOrdersFifoQueueSize.GetHashCode();
      if (HasForceUpdatePeriod) hash ^= ForceUpdatePeriod.GetHashCode();
      if (HasIgnoreObservedMarkets) hash ^= IgnoreObservedMarkets.GetHashCode();
      if (HasMaxDimming) hash ^= MaxDimming.GetHashCode();
      if (HasFarFromMarketMode) hash ^= FarFromMarketMode.GetHashCode();
      if (HasTicksAwayToWork) hash ^= TicksAwayToWork.GetHashCode();
      if (HasDomUsage) hash ^= DomUsage.GetHashCode();
      if (HasDomMultilevelQty) hash ^= DomMultilevelQty.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUint32MinQtyIncrement) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32MinQtyIncrement);
      }
      if (HasQueueHoldersMinSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(QueueHoldersMinSize);
      }
      if (HasQueueHoldersMaxSize) {
        output.WriteRawTag(24);
        output.WriteUInt32(QueueHoldersMaxSize);
      }
      if (HasQueueHoldersDistance) {
        output.WriteRawTag(32);
        output.WriteUInt32(QueueHoldersDistance);
      }
      if (HasOrderSizeRestoreThreshold) {
        output.WriteRawTag(40);
        output.WriteUInt32(OrderSizeRestoreThreshold);
      }
      if (HasUint32VisibleQty) {
        output.WriteRawTag(48);
        output.WriteUInt32(Uint32VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        output.WriteRawTag(56);
        output.WriteUInt32(Uint32MinVisibleQty);
      }
      if (HasWorkingOrdersPriceRange) {
        output.WriteRawTag(64);
        output.WriteUInt32(WorkingOrdersPriceRange);
      }
      if (HasMinPriceChange) {
        output.WriteRawTag(72);
        output.WriteUInt32(MinPriceChange);
      }
      if (HasPrimaryOrdersFifoQueueSize) {
        output.WriteRawTag(80);
        output.WriteUInt32(PrimaryOrdersFifoQueueSize);
      }
      if (HasForceUpdatePeriod) {
        output.WriteRawTag(88);
        output.WriteUInt32(ForceUpdatePeriod);
      }
      if (HasIgnoreObservedMarkets) {
        output.WriteRawTag(96);
        output.WriteBool(IgnoreObservedMarkets);
      }
      if (HasMaxDimming) {
        output.WriteRawTag(104);
        output.WriteUInt32(MaxDimming);
      }
      if (HasFarFromMarketMode) {
        output.WriteRawTag(112);
        output.WriteUInt32(FarFromMarketMode);
      }
      if (HasTicksAwayToWork) {
        output.WriteRawTag(120);
        output.WriteInt32(TicksAwayToWork);
      }
      if (HasDomUsage) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(DomUsage);
      }
      if (HasDomMultilevelQty) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(DomMultilevelQty);
      }
      if (minQtyIncrement_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(MinQtyIncrement);
      }
      if (visibleQty_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(VisibleQty);
      }
      if (minVisibleQty_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(MinVisibleQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUint32MinQtyIncrement) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32MinQtyIncrement);
      }
      if (HasQueueHoldersMinSize) {
        output.WriteRawTag(16);
        output.WriteUInt32(QueueHoldersMinSize);
      }
      if (HasQueueHoldersMaxSize) {
        output.WriteRawTag(24);
        output.WriteUInt32(QueueHoldersMaxSize);
      }
      if (HasQueueHoldersDistance) {
        output.WriteRawTag(32);
        output.WriteUInt32(QueueHoldersDistance);
      }
      if (HasOrderSizeRestoreThreshold) {
        output.WriteRawTag(40);
        output.WriteUInt32(OrderSizeRestoreThreshold);
      }
      if (HasUint32VisibleQty) {
        output.WriteRawTag(48);
        output.WriteUInt32(Uint32VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        output.WriteRawTag(56);
        output.WriteUInt32(Uint32MinVisibleQty);
      }
      if (HasWorkingOrdersPriceRange) {
        output.WriteRawTag(64);
        output.WriteUInt32(WorkingOrdersPriceRange);
      }
      if (HasMinPriceChange) {
        output.WriteRawTag(72);
        output.WriteUInt32(MinPriceChange);
      }
      if (HasPrimaryOrdersFifoQueueSize) {
        output.WriteRawTag(80);
        output.WriteUInt32(PrimaryOrdersFifoQueueSize);
      }
      if (HasForceUpdatePeriod) {
        output.WriteRawTag(88);
        output.WriteUInt32(ForceUpdatePeriod);
      }
      if (HasIgnoreObservedMarkets) {
        output.WriteRawTag(96);
        output.WriteBool(IgnoreObservedMarkets);
      }
      if (HasMaxDimming) {
        output.WriteRawTag(104);
        output.WriteUInt32(MaxDimming);
      }
      if (HasFarFromMarketMode) {
        output.WriteRawTag(112);
        output.WriteUInt32(FarFromMarketMode);
      }
      if (HasTicksAwayToWork) {
        output.WriteRawTag(120);
        output.WriteInt32(TicksAwayToWork);
      }
      if (HasDomUsage) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(DomUsage);
      }
      if (HasDomMultilevelQty) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(DomMultilevelQty);
      }
      if (minQtyIncrement_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(MinQtyIncrement);
      }
      if (visibleQty_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(VisibleQty);
      }
      if (minVisibleQty_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(MinVisibleQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasUint32MinQtyIncrement) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32MinQtyIncrement);
      }
      if (minQtyIncrement_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MinQtyIncrement);
      }
      if (HasQueueHoldersMinSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(QueueHoldersMinSize);
      }
      if (HasQueueHoldersMaxSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(QueueHoldersMaxSize);
      }
      if (HasQueueHoldersDistance) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(QueueHoldersDistance);
      }
      if (HasOrderSizeRestoreThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OrderSizeRestoreThreshold);
      }
      if (HasUint32VisibleQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32VisibleQty);
      }
      if (visibleQty_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32MinVisibleQty);
      }
      if (minVisibleQty_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MinVisibleQty);
      }
      if (HasWorkingOrdersPriceRange) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WorkingOrdersPriceRange);
      }
      if (HasMinPriceChange) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinPriceChange);
      }
      if (HasPrimaryOrdersFifoQueueSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PrimaryOrdersFifoQueueSize);
      }
      if (HasForceUpdatePeriod) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ForceUpdatePeriod);
      }
      if (HasIgnoreObservedMarkets) {
        size += 1 + 1;
      }
      if (HasMaxDimming) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxDimming);
      }
      if (HasFarFromMarketMode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FarFromMarketMode);
      }
      if (HasTicksAwayToWork) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TicksAwayToWork);
      }
      if (HasDomUsage) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(DomUsage);
      }
      if (HasDomMultilevelQty) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(DomMultilevelQty);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PrimaryOrdersLimit other) {
      if (other == null) {
        return;
      }
      if (other.HasUint32MinQtyIncrement) {
        Uint32MinQtyIncrement = other.Uint32MinQtyIncrement;
      }
      if (other.minQtyIncrement_ != null) {
        if (minQtyIncrement_ == null) {
          MinQtyIncrement = new global::Cqg.Decimal();
        }
        MinQtyIncrement.MergeFrom(other.MinQtyIncrement);
      }
      if (other.HasQueueHoldersMinSize) {
        QueueHoldersMinSize = other.QueueHoldersMinSize;
      }
      if (other.HasQueueHoldersMaxSize) {
        QueueHoldersMaxSize = other.QueueHoldersMaxSize;
      }
      if (other.HasQueueHoldersDistance) {
        QueueHoldersDistance = other.QueueHoldersDistance;
      }
      if (other.HasOrderSizeRestoreThreshold) {
        OrderSizeRestoreThreshold = other.OrderSizeRestoreThreshold;
      }
      if (other.HasUint32VisibleQty) {
        Uint32VisibleQty = other.Uint32VisibleQty;
      }
      if (other.visibleQty_ != null) {
        if (visibleQty_ == null) {
          VisibleQty = new global::Cqg.Decimal();
        }
        VisibleQty.MergeFrom(other.VisibleQty);
      }
      if (other.HasUint32MinVisibleQty) {
        Uint32MinVisibleQty = other.Uint32MinVisibleQty;
      }
      if (other.minVisibleQty_ != null) {
        if (minVisibleQty_ == null) {
          MinVisibleQty = new global::Cqg.Decimal();
        }
        MinVisibleQty.MergeFrom(other.MinVisibleQty);
      }
      if (other.HasWorkingOrdersPriceRange) {
        WorkingOrdersPriceRange = other.WorkingOrdersPriceRange;
      }
      if (other.HasMinPriceChange) {
        MinPriceChange = other.MinPriceChange;
      }
      if (other.HasPrimaryOrdersFifoQueueSize) {
        PrimaryOrdersFifoQueueSize = other.PrimaryOrdersFifoQueueSize;
      }
      if (other.HasForceUpdatePeriod) {
        ForceUpdatePeriod = other.ForceUpdatePeriod;
      }
      if (other.HasIgnoreObservedMarkets) {
        IgnoreObservedMarkets = other.IgnoreObservedMarkets;
      }
      if (other.HasMaxDimming) {
        MaxDimming = other.MaxDimming;
      }
      if (other.HasFarFromMarketMode) {
        FarFromMarketMode = other.FarFromMarketMode;
      }
      if (other.HasTicksAwayToWork) {
        TicksAwayToWork = other.TicksAwayToWork;
      }
      if (other.HasDomUsage) {
        DomUsage = other.DomUsage;
      }
      if (other.HasDomMultilevelQty) {
        DomMultilevelQty = other.DomMultilevelQty;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Uint32MinQtyIncrement = input.ReadUInt32();
            break;
          }
          case 16: {
            QueueHoldersMinSize = input.ReadUInt32();
            break;
          }
          case 24: {
            QueueHoldersMaxSize = input.ReadUInt32();
            break;
          }
          case 32: {
            QueueHoldersDistance = input.ReadUInt32();
            break;
          }
          case 40: {
            OrderSizeRestoreThreshold = input.ReadUInt32();
            break;
          }
          case 48: {
            Uint32VisibleQty = input.ReadUInt32();
            break;
          }
          case 56: {
            Uint32MinVisibleQty = input.ReadUInt32();
            break;
          }
          case 64: {
            WorkingOrdersPriceRange = input.ReadUInt32();
            break;
          }
          case 72: {
            MinPriceChange = input.ReadUInt32();
            break;
          }
          case 80: {
            PrimaryOrdersFifoQueueSize = input.ReadUInt32();
            break;
          }
          case 88: {
            ForceUpdatePeriod = input.ReadUInt32();
            break;
          }
          case 96: {
            IgnoreObservedMarkets = input.ReadBool();
            break;
          }
          case 104: {
            MaxDimming = input.ReadUInt32();
            break;
          }
          case 112: {
            FarFromMarketMode = input.ReadUInt32();
            break;
          }
          case 120: {
            TicksAwayToWork = input.ReadInt32();
            break;
          }
          case 128: {
            DomUsage = input.ReadUInt32();
            break;
          }
          case 136: {
            DomMultilevelQty = input.ReadUInt32();
            break;
          }
          case 146: {
            if (minQtyIncrement_ == null) {
              MinQtyIncrement = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinQtyIncrement);
            break;
          }
          case 154: {
            if (visibleQty_ == null) {
              VisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(VisibleQty);
            break;
          }
          case 162: {
            if (minVisibleQty_ == null) {
              MinVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinVisibleQty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Uint32MinQtyIncrement = input.ReadUInt32();
            break;
          }
          case 16: {
            QueueHoldersMinSize = input.ReadUInt32();
            break;
          }
          case 24: {
            QueueHoldersMaxSize = input.ReadUInt32();
            break;
          }
          case 32: {
            QueueHoldersDistance = input.ReadUInt32();
            break;
          }
          case 40: {
            OrderSizeRestoreThreshold = input.ReadUInt32();
            break;
          }
          case 48: {
            Uint32VisibleQty = input.ReadUInt32();
            break;
          }
          case 56: {
            Uint32MinVisibleQty = input.ReadUInt32();
            break;
          }
          case 64: {
            WorkingOrdersPriceRange = input.ReadUInt32();
            break;
          }
          case 72: {
            MinPriceChange = input.ReadUInt32();
            break;
          }
          case 80: {
            PrimaryOrdersFifoQueueSize = input.ReadUInt32();
            break;
          }
          case 88: {
            ForceUpdatePeriod = input.ReadUInt32();
            break;
          }
          case 96: {
            IgnoreObservedMarkets = input.ReadBool();
            break;
          }
          case 104: {
            MaxDimming = input.ReadUInt32();
            break;
          }
          case 112: {
            FarFromMarketMode = input.ReadUInt32();
            break;
          }
          case 120: {
            TicksAwayToWork = input.ReadInt32();
            break;
          }
          case 128: {
            DomUsage = input.ReadUInt32();
            break;
          }
          case 136: {
            DomMultilevelQty = input.ReadUInt32();
            break;
          }
          case 146: {
            if (minQtyIncrement_ == null) {
              MinQtyIncrement = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinQtyIncrement);
            break;
          }
          case 154: {
            if (visibleQty_ == null) {
              VisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(VisibleQty);
            break;
          }
          case 162: {
            if (minVisibleQty_ == null) {
              MinVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinVisibleQty);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PrimaryOrdersLimit message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Mode of working primary orders with price far from market.
      /// </summary>
      public enum FarFromMarketMode {
        /// <summary>
        /// Primary orders will be canceled (won't be placed) if a new target price is far from market.
        /// </summary>
        [pbr::OriginalName("FAR_FROM_MARKET_MODE_NO_ORDERS")] NoOrders = 1,
        /// <summary>
        /// Primary orders will be moved away from market (will be left untouched) if a new target price is far from market.
        /// </summary>
        [pbr::OriginalName("FAR_FROM_MARKET_MODE_MOVE_AWAY_ONLY")] MoveAwayOnly = 2,
        /// <summary>
        /// Primary orders will be left untouched if current and a new target price are both far from market.
        /// </summary>
        [pbr::OriginalName("FAR_FROM_MARKET_MODE_DONT_MOVE")] DontMove = 3,
      }

      /// <summary>
      /// Modes of handling DOM data.
      /// </summary>
      public enum DOMUsageMode {
        /// <summary>
        /// Use only top levels of DOMs and produce a single level of primary orders.
        /// </summary>
        [pbr::OriginalName("DOM_USAGE_MODE_TOP_ONLY")] TopOnly = 1,
        /// <summary>
        /// Use multiple levels of DOMs and produce multiple levels of primary orders.
        /// </summary>
        [pbr::OriginalName("DOM_USAGE_MODE_MULTILEVELS")] Multilevels = 2,
        /// <summary>
        /// Produce a single level of primary orders of the full quantity
        /// corresponding to the worst DOM prices with a sufficient cumulative quantity.
        /// </summary>
        [pbr::OriginalName("DOM_USAGE_MODE_FULL_SIZE_WORST_PRICE")] FullSizeWorstPrice = 3,
        /// <summary>
        /// Produce a single level of primary orders of the full quantity corresponding
        /// to average DOM prices with a sufficient cumulative quantity.
        /// </summary>
        [pbr::OriginalName("DOM_USAGE_MODE_FULL_SIZE_AVERAGE_PRICE")] FullSizeAveragePrice = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// Sniper rule means don't place any primary order.
  /// It just watches markets waiting for the moment when the strategy order's LMT price is available.
  /// Then secondary orders on all legs must be placed.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PrimaryOrdersSniper : pb::IMessage<PrimaryOrdersSniper>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PrimaryOrdersSniper> _parser = new pb::MessageParser<PrimaryOrdersSniper>(() => new PrimaryOrdersSniper());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PrimaryOrdersSniper> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersSniper() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersSniper(PrimaryOrdersSniper other) : this() {
      _hasBits0 = other._hasBits0;
      legDuration_ = other.legDuration_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrimaryOrdersSniper Clone() {
      return new PrimaryOrdersSniper(this);
    }

    /// <summary>Field number for the "leg_duration" field.</summary>
    public const int LegDurationFieldNumber = 1;
    private readonly static uint LegDurationDefaultValue = 0;

    private uint legDuration_;
    /// <summary>
    /// One of LegDuration enums.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint LegDuration {
      get { if ((_hasBits0 & 1) != 0) { return legDuration_; } else { return LegDurationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        legDuration_ = value;
      }
    }
    /// <summary>Gets whether the "leg_duration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLegDuration {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "leg_duration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLegDuration() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PrimaryOrdersSniper);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PrimaryOrdersSniper other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LegDuration != other.LegDuration) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLegDuration) hash ^= LegDuration.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLegDuration) {
        output.WriteRawTag(8);
        output.WriteUInt32(LegDuration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLegDuration) {
        output.WriteRawTag(8);
        output.WriteUInt32(LegDuration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLegDuration) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LegDuration);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PrimaryOrdersSniper other) {
      if (other == null) {
        return;
      }
      if (other.HasLegDuration) {
        LegDuration = other.LegDuration;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LegDuration = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            LegDuration = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PrimaryOrdersSniper message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Duration for sniper leg orders
      /// </summary>
      public enum LegDuration {
        [pbr::OriginalName("LEG_DURATION_DAY")] Day = 1,
        /// <summary>
        /// Fill and kill
        /// </summary>
        [pbr::OriginalName("LEG_DURATION_FAK")] Fak = 2,
        /// <summary>
        /// Fill or kill
        /// </summary>
        [pbr::OriginalName("LEG_DURATION_FOK")] Fok = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// LMT secondary orders parameters.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SecondaryOrdersLimit : pb::IMessage<SecondaryOrdersLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecondaryOrdersLimit> _parser = new pb::MessageParser<SecondaryOrdersLimit>(() => new SecondaryOrdersLimit());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecondaryOrdersLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersLimit(SecondaryOrdersLimit other) : this() {
      _hasBits0 = other._hasBits0;
      initialOffset_ = other.initialOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersLimit Clone() {
      return new SecondaryOrdersLimit(this);
    }

    /// <summary>Field number for the "initial_offset" field.</summary>
    public const int InitialOffsetFieldNumber = 1;
    private readonly static double InitialOffsetDefaultValue = 0D;

    private double initialOffset_;
    /// <summary>
    /// Offset to adjust secondary order price at the moment of place. Default is 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double InitialOffset {
      get { if ((_hasBits0 & 1) != 0) { return initialOffset_; } else { return InitialOffsetDefaultValue; } }
      set {
        _hasBits0 |= 1;
        initialOffset_ = value;
      }
    }
    /// <summary>Gets whether the "initial_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitialOffset {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "initial_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitialOffset() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecondaryOrdersLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecondaryOrdersLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(InitialOffset, other.InitialOffset)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasInitialOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(InitialOffset);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasInitialOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(InitialOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasInitialOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(InitialOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasInitialOffset) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecondaryOrdersLimit other) {
      if (other == null) {
        return;
      }
      if (other.HasInitialOffset) {
        InitialOffset = other.InitialOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            InitialOffset = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            InitialOffset = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// MKT secondary orders parameters.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SecondaryOrdersMarket : pb::IMessage<SecondaryOrdersMarket>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecondaryOrdersMarket> _parser = new pb::MessageParser<SecondaryOrdersMarket>(() => new SecondaryOrdersMarket());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecondaryOrdersMarket> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersMarket() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersMarket(SecondaryOrdersMarket other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersMarket Clone() {
      return new SecondaryOrdersMarket(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecondaryOrdersMarket);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecondaryOrdersMarket other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecondaryOrdersMarket other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Pay up secondary orders parameters.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SecondaryOrdersPayUp : pb::IMessage<SecondaryOrdersPayUp>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecondaryOrdersPayUp> _parser = new pb::MessageParser<SecondaryOrdersPayUp>(() => new SecondaryOrdersPayUp());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecondaryOrdersPayUp> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersPayUp() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersPayUp(SecondaryOrdersPayUp other) : this() {
      _hasBits0 = other._hasBits0;
      offset_ = other.offset_;
      initialOffset_ = other.initialOffset_;
      conditionTimeout_ = other.conditionTimeout_;
      uint32ConditionAbsoluteVolume_ = other.uint32ConditionAbsoluteVolume_;
      conditionAbsoluteVolume_ = other.conditionAbsoluteVolume_ != null ? other.conditionAbsoluteVolume_.Clone() : null;
      conditionOppositeVolumeRatio_ = other.conditionOppositeVolumeRatio_;
      conditionBbaVolumeRatio_ = other.conditionBbaVolumeRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersPayUp Clone() {
      return new SecondaryOrdersPayUp(this);
    }

    /// <summary>Field number for the "offset" field.</summary>
    public const int OffsetFieldNumber = 1;
    private readonly static double OffsetDefaultValue = 0D;

    private double offset_;
    /// <summary>
    /// Offset to modify the price of a hung secondary order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Offset {
      get { if ((_hasBits0 & 1) != 0) { return offset_; } else { return OffsetDefaultValue; } }
      set {
        _hasBits0 |= 1;
        offset_ = value;
      }
    }
    /// <summary>Gets whether the "offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOffset {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOffset() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "initial_offset" field.</summary>
    public const int InitialOffsetFieldNumber = 2;
    private readonly static double InitialOffsetDefaultValue = 0D;

    private double initialOffset_;
    /// <summary>
    /// Offset to adjust the secondary order price at the moment of placement.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double InitialOffset {
      get { if ((_hasBits0 & 2) != 0) { return initialOffset_; } else { return InitialOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        initialOffset_ = value;
      }
    }
    /// <summary>Gets whether the "initial_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitialOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "initial_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitialOffset() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "condition_timeout" field.</summary>
    public const int ConditionTimeoutFieldNumber = 3;
    private readonly static uint ConditionTimeoutDefaultValue = 0;

    private uint conditionTimeout_;
    /// <summary>
    /// One of the conditions below must be set.
    /// Condition to check that pointed time interval is passed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ConditionTimeout {
      get { if ((_hasBits0 & 4) != 0) { return conditionTimeout_; } else { return ConditionTimeoutDefaultValue; } }
      set {
        _hasBits0 |= 4;
        conditionTimeout_ = value;
      }
    }
    /// <summary>Gets whether the "condition_timeout" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionTimeout {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "condition_timeout" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionTimeout() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "uint32_condition_absolute_volume" field.</summary>
    public const int Uint32ConditionAbsoluteVolumeFieldNumber = 4;
    private readonly static uint Uint32ConditionAbsoluteVolumeDefaultValue = 0;

    private uint uint32ConditionAbsoluteVolume_;
    /// <summary>
    /// Note: use condition_absolute_volume field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32ConditionAbsoluteVolume {
      get { if ((_hasBits0 & 8) != 0) { return uint32ConditionAbsoluteVolume_; } else { return Uint32ConditionAbsoluteVolumeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        uint32ConditionAbsoluteVolume_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_condition_absolute_volume" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32ConditionAbsoluteVolume {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "uint32_condition_absolute_volume" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32ConditionAbsoluteVolume() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "condition_absolute_volume" field.</summary>
    public const int ConditionAbsoluteVolumeFieldNumber = 7;
    private global::Cqg.Decimal conditionAbsoluteVolume_;
    /// <summary>
    /// Condition to check the opposite market volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal ConditionAbsoluteVolume {
      get { return conditionAbsoluteVolume_; }
      set {
        conditionAbsoluteVolume_ = value;
      }
    }

    /// <summary>Field number for the "condition_opposite_volume_ratio" field.</summary>
    public const int ConditionOppositeVolumeRatioFieldNumber = 5;
    private readonly static double ConditionOppositeVolumeRatioDefaultValue = 0D;

    private double conditionOppositeVolumeRatio_;
    /// <summary>
    /// Condition to check the ratio between the opposite side and secondary order sizes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ConditionOppositeVolumeRatio {
      get { if ((_hasBits0 & 16) != 0) { return conditionOppositeVolumeRatio_; } else { return ConditionOppositeVolumeRatioDefaultValue; } }
      set {
        _hasBits0 |= 16;
        conditionOppositeVolumeRatio_ = value;
      }
    }
    /// <summary>Gets whether the "condition_opposite_volume_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionOppositeVolumeRatio {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "condition_opposite_volume_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionOppositeVolumeRatio() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "condition_bba_volume_ratio" field.</summary>
    public const int ConditionBbaVolumeRatioFieldNumber = 6;
    private readonly static double ConditionBbaVolumeRatioDefaultValue = 0D;

    private double conditionBbaVolumeRatio_;
    /// <summary>
    /// Condition to check the opposite side and the local side volumes ratio.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ConditionBbaVolumeRatio {
      get { if ((_hasBits0 & 32) != 0) { return conditionBbaVolumeRatio_; } else { return ConditionBbaVolumeRatioDefaultValue; } }
      set {
        _hasBits0 |= 32;
        conditionBbaVolumeRatio_ = value;
      }
    }
    /// <summary>Gets whether the "condition_bba_volume_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionBbaVolumeRatio {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "condition_bba_volume_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionBbaVolumeRatio() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecondaryOrdersPayUp);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecondaryOrdersPayUp other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Offset, other.Offset)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(InitialOffset, other.InitialOffset)) return false;
      if (ConditionTimeout != other.ConditionTimeout) return false;
      if (Uint32ConditionAbsoluteVolume != other.Uint32ConditionAbsoluteVolume) return false;
      if (!object.Equals(ConditionAbsoluteVolume, other.ConditionAbsoluteVolume)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ConditionOppositeVolumeRatio, other.ConditionOppositeVolumeRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ConditionBbaVolumeRatio, other.ConditionBbaVolumeRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Offset);
      if (HasInitialOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(InitialOffset);
      if (HasConditionTimeout) hash ^= ConditionTimeout.GetHashCode();
      if (HasUint32ConditionAbsoluteVolume) hash ^= Uint32ConditionAbsoluteVolume.GetHashCode();
      if (conditionAbsoluteVolume_ != null) hash ^= ConditionAbsoluteVolume.GetHashCode();
      if (HasConditionOppositeVolumeRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ConditionOppositeVolumeRatio);
      if (HasConditionBbaVolumeRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ConditionBbaVolumeRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(Offset);
      }
      if (HasInitialOffset) {
        output.WriteRawTag(17);
        output.WriteDouble(InitialOffset);
      }
      if (HasConditionTimeout) {
        output.WriteRawTag(24);
        output.WriteUInt32(ConditionTimeout);
      }
      if (HasUint32ConditionAbsoluteVolume) {
        output.WriteRawTag(32);
        output.WriteUInt32(Uint32ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        output.WriteRawTag(41);
        output.WriteDouble(ConditionOppositeVolumeRatio);
      }
      if (HasConditionBbaVolumeRatio) {
        output.WriteRawTag(49);
        output.WriteDouble(ConditionBbaVolumeRatio);
      }
      if (conditionAbsoluteVolume_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ConditionAbsoluteVolume);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(Offset);
      }
      if (HasInitialOffset) {
        output.WriteRawTag(17);
        output.WriteDouble(InitialOffset);
      }
      if (HasConditionTimeout) {
        output.WriteRawTag(24);
        output.WriteUInt32(ConditionTimeout);
      }
      if (HasUint32ConditionAbsoluteVolume) {
        output.WriteRawTag(32);
        output.WriteUInt32(Uint32ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        output.WriteRawTag(41);
        output.WriteDouble(ConditionOppositeVolumeRatio);
      }
      if (HasConditionBbaVolumeRatio) {
        output.WriteRawTag(49);
        output.WriteDouble(ConditionBbaVolumeRatio);
      }
      if (conditionAbsoluteVolume_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ConditionAbsoluteVolume);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasOffset) {
        size += 1 + 8;
      }
      if (HasInitialOffset) {
        size += 1 + 8;
      }
      if (HasConditionTimeout) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ConditionTimeout);
      }
      if (HasUint32ConditionAbsoluteVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32ConditionAbsoluteVolume);
      }
      if (conditionAbsoluteVolume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        size += 1 + 8;
      }
      if (HasConditionBbaVolumeRatio) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecondaryOrdersPayUp other) {
      if (other == null) {
        return;
      }
      if (other.HasOffset) {
        Offset = other.Offset;
      }
      if (other.HasInitialOffset) {
        InitialOffset = other.InitialOffset;
      }
      if (other.HasConditionTimeout) {
        ConditionTimeout = other.ConditionTimeout;
      }
      if (other.HasUint32ConditionAbsoluteVolume) {
        Uint32ConditionAbsoluteVolume = other.Uint32ConditionAbsoluteVolume;
      }
      if (other.conditionAbsoluteVolume_ != null) {
        if (conditionAbsoluteVolume_ == null) {
          ConditionAbsoluteVolume = new global::Cqg.Decimal();
        }
        ConditionAbsoluteVolume.MergeFrom(other.ConditionAbsoluteVolume);
      }
      if (other.HasConditionOppositeVolumeRatio) {
        ConditionOppositeVolumeRatio = other.ConditionOppositeVolumeRatio;
      }
      if (other.HasConditionBbaVolumeRatio) {
        ConditionBbaVolumeRatio = other.ConditionBbaVolumeRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Offset = input.ReadDouble();
            break;
          }
          case 17: {
            InitialOffset = input.ReadDouble();
            break;
          }
          case 24: {
            ConditionTimeout = input.ReadUInt32();
            break;
          }
          case 32: {
            Uint32ConditionAbsoluteVolume = input.ReadUInt32();
            break;
          }
          case 41: {
            ConditionOppositeVolumeRatio = input.ReadDouble();
            break;
          }
          case 49: {
            ConditionBbaVolumeRatio = input.ReadDouble();
            break;
          }
          case 58: {
            if (conditionAbsoluteVolume_ == null) {
              ConditionAbsoluteVolume = new global::Cqg.Decimal();
            }
            input.ReadMessage(ConditionAbsoluteVolume);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            Offset = input.ReadDouble();
            break;
          }
          case 17: {
            InitialOffset = input.ReadDouble();
            break;
          }
          case 24: {
            ConditionTimeout = input.ReadUInt32();
            break;
          }
          case 32: {
            Uint32ConditionAbsoluteVolume = input.ReadUInt32();
            break;
          }
          case 41: {
            ConditionOppositeVolumeRatio = input.ReadDouble();
            break;
          }
          case 49: {
            ConditionBbaVolumeRatio = input.ReadDouble();
            break;
          }
          case 58: {
            if (conditionAbsoluteVolume_ == null) {
              ConditionAbsoluteVolume = new global::Cqg.Decimal();
            }
            input.ReadMessage(ConditionAbsoluteVolume);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Trailing secondary orders parameters.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SecondaryOrdersTrailing : pb::IMessage<SecondaryOrdersTrailing>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecondaryOrdersTrailing> _parser = new pb::MessageParser<SecondaryOrdersTrailing>(() => new SecondaryOrdersTrailing());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecondaryOrdersTrailing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersTrailing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersTrailing(SecondaryOrdersTrailing other) : this() {
      _hasBits0 = other._hasBits0;
      trailingOffset_ = other.trailingOffset_;
      trailingPeg_ = other.trailingPeg_;
      initialOffset_ = other.initialOffset_;
      maxTrail_ = other.maxTrail_;
      uint32ConditionAbsoluteVolume_ = other.uint32ConditionAbsoluteVolume_;
      conditionAbsoluteVolume_ = other.conditionAbsoluteVolume_ != null ? other.conditionAbsoluteVolume_.Clone() : null;
      conditionOppositeVolumeRatio_ = other.conditionOppositeVolumeRatio_;
      conditionBbaVolumeRatio_ = other.conditionBbaVolumeRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecondaryOrdersTrailing Clone() {
      return new SecondaryOrdersTrailing(this);
    }

    /// <summary>Field number for the "trailing_offset" field.</summary>
    public const int TrailingOffsetFieldNumber = 1;
    private readonly static double TrailingOffsetDefaultValue = 0D;

    private double trailingOffset_;
    /// <summary>
    /// Trailing offset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double TrailingOffset {
      get { if ((_hasBits0 & 1) != 0) { return trailingOffset_; } else { return TrailingOffsetDefaultValue; } }
      set {
        _hasBits0 |= 1;
        trailingOffset_ = value;
      }
    }
    /// <summary>Gets whether the "trailing_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrailingOffset {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "trailing_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrailingOffset() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "trailing_peg" field.</summary>
    public const int TrailingPegFieldNumber = 2;
    private readonly static uint TrailingPegDefaultValue = 0;

    private uint trailingPeg_;
    /// <summary>
    /// Peg that price must follow. One of Order.TrailingPeg enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint TrailingPeg {
      get { if ((_hasBits0 & 2) != 0) { return trailingPeg_; } else { return TrailingPegDefaultValue; } }
      set {
        _hasBits0 |= 2;
        trailingPeg_ = value;
      }
    }
    /// <summary>Gets whether the "trailing_peg" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrailingPeg {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "trailing_peg" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrailingPeg() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "initial_offset" field.</summary>
    public const int InitialOffsetFieldNumber = 3;
    private readonly static double InitialOffsetDefaultValue = 0D;

    private double initialOffset_;
    /// <summary>
    /// Offset to adjust secondary order price at the moment of place.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double InitialOffset {
      get { if ((_hasBits0 & 4) != 0) { return initialOffset_; } else { return InitialOffsetDefaultValue; } }
      set {
        _hasBits0 |= 4;
        initialOffset_ = value;
      }
    }
    /// <summary>Gets whether the "initial_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitialOffset {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "initial_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitialOffset() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_trail" field.</summary>
    public const int MaxTrailFieldNumber = 4;
    private readonly static double MaxTrailDefaultValue = 0D;

    private double maxTrail_;
    /// <summary>
    /// Maximum distance to trail away from the initial price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double MaxTrail {
      get { if ((_hasBits0 & 8) != 0) { return maxTrail_; } else { return MaxTrailDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxTrail_ = value;
      }
    }
    /// <summary>Gets whether the "max_trail" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxTrail {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_trail" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxTrail() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "uint32_condition_absolute_volume" field.</summary>
    public const int Uint32ConditionAbsoluteVolumeFieldNumber = 5;
    private readonly static uint Uint32ConditionAbsoluteVolumeDefaultValue = 0;

    private uint uint32ConditionAbsoluteVolume_;
    /// <summary>
    /// Note: use condition_absolute_volume field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32ConditionAbsoluteVolume {
      get { if ((_hasBits0 & 16) != 0) { return uint32ConditionAbsoluteVolume_; } else { return Uint32ConditionAbsoluteVolumeDefaultValue; } }
      set {
        _hasBits0 |= 16;
        uint32ConditionAbsoluteVolume_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_condition_absolute_volume" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32ConditionAbsoluteVolume {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "uint32_condition_absolute_volume" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32ConditionAbsoluteVolume() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "condition_absolute_volume" field.</summary>
    public const int ConditionAbsoluteVolumeFieldNumber = 8;
    private global::Cqg.Decimal conditionAbsoluteVolume_;
    /// <summary>
    /// Condition that checks the opposite market volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal ConditionAbsoluteVolume {
      get { return conditionAbsoluteVolume_; }
      set {
        conditionAbsoluteVolume_ = value;
      }
    }

    /// <summary>Field number for the "condition_opposite_volume_ratio" field.</summary>
    public const int ConditionOppositeVolumeRatioFieldNumber = 6;
    private readonly static double ConditionOppositeVolumeRatioDefaultValue = 0D;

    private double conditionOppositeVolumeRatio_;
    /// <summary>
    /// Condition that checks relation between opposite side and secondary order sizes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ConditionOppositeVolumeRatio {
      get { if ((_hasBits0 & 32) != 0) { return conditionOppositeVolumeRatio_; } else { return ConditionOppositeVolumeRatioDefaultValue; } }
      set {
        _hasBits0 |= 32;
        conditionOppositeVolumeRatio_ = value;
      }
    }
    /// <summary>Gets whether the "condition_opposite_volume_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionOppositeVolumeRatio {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "condition_opposite_volume_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionOppositeVolumeRatio() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "condition_bba_volume_ratio" field.</summary>
    public const int ConditionBbaVolumeRatioFieldNumber = 7;
    private readonly static double ConditionBbaVolumeRatioDefaultValue = 0D;

    private double conditionBbaVolumeRatio_;
    /// <summary>
    /// Condition that checks the opposite side and the local side volumes ratio.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ConditionBbaVolumeRatio {
      get { if ((_hasBits0 & 64) != 0) { return conditionBbaVolumeRatio_; } else { return ConditionBbaVolumeRatioDefaultValue; } }
      set {
        _hasBits0 |= 64;
        conditionBbaVolumeRatio_ = value;
      }
    }
    /// <summary>Gets whether the "condition_bba_volume_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionBbaVolumeRatio {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "condition_bba_volume_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionBbaVolumeRatio() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecondaryOrdersTrailing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecondaryOrdersTrailing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TrailingOffset, other.TrailingOffset)) return false;
      if (TrailingPeg != other.TrailingPeg) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(InitialOffset, other.InitialOffset)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MaxTrail, other.MaxTrail)) return false;
      if (Uint32ConditionAbsoluteVolume != other.Uint32ConditionAbsoluteVolume) return false;
      if (!object.Equals(ConditionAbsoluteVolume, other.ConditionAbsoluteVolume)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ConditionOppositeVolumeRatio, other.ConditionOppositeVolumeRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ConditionBbaVolumeRatio, other.ConditionBbaVolumeRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTrailingOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TrailingOffset);
      if (HasTrailingPeg) hash ^= TrailingPeg.GetHashCode();
      if (HasInitialOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(InitialOffset);
      if (HasMaxTrail) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MaxTrail);
      if (HasUint32ConditionAbsoluteVolume) hash ^= Uint32ConditionAbsoluteVolume.GetHashCode();
      if (conditionAbsoluteVolume_ != null) hash ^= ConditionAbsoluteVolume.GetHashCode();
      if (HasConditionOppositeVolumeRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ConditionOppositeVolumeRatio);
      if (HasConditionBbaVolumeRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ConditionBbaVolumeRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTrailingOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(TrailingOffset);
      }
      if (HasTrailingPeg) {
        output.WriteRawTag(16);
        output.WriteUInt32(TrailingPeg);
      }
      if (HasInitialOffset) {
        output.WriteRawTag(25);
        output.WriteDouble(InitialOffset);
      }
      if (HasMaxTrail) {
        output.WriteRawTag(33);
        output.WriteDouble(MaxTrail);
      }
      if (HasUint32ConditionAbsoluteVolume) {
        output.WriteRawTag(40);
        output.WriteUInt32(Uint32ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        output.WriteRawTag(49);
        output.WriteDouble(ConditionOppositeVolumeRatio);
      }
      if (HasConditionBbaVolumeRatio) {
        output.WriteRawTag(57);
        output.WriteDouble(ConditionBbaVolumeRatio);
      }
      if (conditionAbsoluteVolume_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ConditionAbsoluteVolume);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTrailingOffset) {
        output.WriteRawTag(9);
        output.WriteDouble(TrailingOffset);
      }
      if (HasTrailingPeg) {
        output.WriteRawTag(16);
        output.WriteUInt32(TrailingPeg);
      }
      if (HasInitialOffset) {
        output.WriteRawTag(25);
        output.WriteDouble(InitialOffset);
      }
      if (HasMaxTrail) {
        output.WriteRawTag(33);
        output.WriteDouble(MaxTrail);
      }
      if (HasUint32ConditionAbsoluteVolume) {
        output.WriteRawTag(40);
        output.WriteUInt32(Uint32ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        output.WriteRawTag(49);
        output.WriteDouble(ConditionOppositeVolumeRatio);
      }
      if (HasConditionBbaVolumeRatio) {
        output.WriteRawTag(57);
        output.WriteDouble(ConditionBbaVolumeRatio);
      }
      if (conditionAbsoluteVolume_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ConditionAbsoluteVolume);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTrailingOffset) {
        size += 1 + 8;
      }
      if (HasTrailingPeg) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TrailingPeg);
      }
      if (HasInitialOffset) {
        size += 1 + 8;
      }
      if (HasMaxTrail) {
        size += 1 + 8;
      }
      if (HasUint32ConditionAbsoluteVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32ConditionAbsoluteVolume);
      }
      if (conditionAbsoluteVolume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConditionAbsoluteVolume);
      }
      if (HasConditionOppositeVolumeRatio) {
        size += 1 + 8;
      }
      if (HasConditionBbaVolumeRatio) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecondaryOrdersTrailing other) {
      if (other == null) {
        return;
      }
      if (other.HasTrailingOffset) {
        TrailingOffset = other.TrailingOffset;
      }
      if (other.HasTrailingPeg) {
        TrailingPeg = other.TrailingPeg;
      }
      if (other.HasInitialOffset) {
        InitialOffset = other.InitialOffset;
      }
      if (other.HasMaxTrail) {
        MaxTrail = other.MaxTrail;
      }
      if (other.HasUint32ConditionAbsoluteVolume) {
        Uint32ConditionAbsoluteVolume = other.Uint32ConditionAbsoluteVolume;
      }
      if (other.conditionAbsoluteVolume_ != null) {
        if (conditionAbsoluteVolume_ == null) {
          ConditionAbsoluteVolume = new global::Cqg.Decimal();
        }
        ConditionAbsoluteVolume.MergeFrom(other.ConditionAbsoluteVolume);
      }
      if (other.HasConditionOppositeVolumeRatio) {
        ConditionOppositeVolumeRatio = other.ConditionOppositeVolumeRatio;
      }
      if (other.HasConditionBbaVolumeRatio) {
        ConditionBbaVolumeRatio = other.ConditionBbaVolumeRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            TrailingOffset = input.ReadDouble();
            break;
          }
          case 16: {
            TrailingPeg = input.ReadUInt32();
            break;
          }
          case 25: {
            InitialOffset = input.ReadDouble();
            break;
          }
          case 33: {
            MaxTrail = input.ReadDouble();
            break;
          }
          case 40: {
            Uint32ConditionAbsoluteVolume = input.ReadUInt32();
            break;
          }
          case 49: {
            ConditionOppositeVolumeRatio = input.ReadDouble();
            break;
          }
          case 57: {
            ConditionBbaVolumeRatio = input.ReadDouble();
            break;
          }
          case 66: {
            if (conditionAbsoluteVolume_ == null) {
              ConditionAbsoluteVolume = new global::Cqg.Decimal();
            }
            input.ReadMessage(ConditionAbsoluteVolume);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            TrailingOffset = input.ReadDouble();
            break;
          }
          case 16: {
            TrailingPeg = input.ReadUInt32();
            break;
          }
          case 25: {
            InitialOffset = input.ReadDouble();
            break;
          }
          case 33: {
            MaxTrail = input.ReadDouble();
            break;
          }
          case 40: {
            Uint32ConditionAbsoluteVolume = input.ReadUInt32();
            break;
          }
          case 49: {
            ConditionOppositeVolumeRatio = input.ReadDouble();
            break;
          }
          case 57: {
            ConditionBbaVolumeRatio = input.ReadDouble();
            break;
          }
          case 66: {
            if (conditionAbsoluteVolume_ == null) {
              ConditionAbsoluteVolume = new global::Cqg.Decimal();
            }
            input.ReadMessage(ConditionAbsoluteVolume);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Aggregation market taking mode:
  /// the order is held on the server until the price becomes available in at least one market;
  /// at which time, the server sends an order to the exchange.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class MarketTakingParameters : pb::IMessage<MarketTakingParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketTakingParameters> _parser = new pb::MessageParser<MarketTakingParameters>(() => new MarketTakingParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MarketTakingParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketTakingParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketTakingParameters(MarketTakingParameters other) : this() {
      _hasBits0 = other._hasBits0;
      allocationPercent_ = other.allocationPercent_;
      workingTimeout_ = other.workingTimeout_;
      orderType_ = other.orderType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketTakingParameters Clone() {
      return new MarketTakingParameters(this);
    }

    /// <summary>Field number for the "allocation_percent" field.</summary>
    public const int AllocationPercentFieldNumber = 1;
    private readonly static double AllocationPercentDefaultValue = 0D;

    private double allocationPercent_;
    /// <summary>
    /// Allocation percent (in range 0...1) for the leg (must total 100% among all legs).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AllocationPercent {
      get { if ((_hasBits0 & 1) != 0) { return allocationPercent_; } else { return AllocationPercentDefaultValue; } }
      set {
        _hasBits0 |= 1;
        allocationPercent_ = value;
      }
    }
    /// <summary>Gets whether the "allocation_percent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAllocationPercent {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "allocation_percent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAllocationPercent() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "working_timeout" field.</summary>
    public const int WorkingTimeoutFieldNumber = 2;
    private readonly static uint WorkingTimeoutDefaultValue = 0;

    private uint workingTimeout_;
    /// <summary>
    /// Time period (in ms) that the order can work (after exchange ack)
    /// before the server considers it timed out and cancels it (0 means 'never',
    /// leaves order working until filled, cancelled, or expired).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint WorkingTimeout {
      get { if ((_hasBits0 & 2) != 0) { return workingTimeout_; } else { return WorkingTimeoutDefaultValue; } }
      set {
        _hasBits0 |= 2;
        workingTimeout_ = value;
      }
    }
    /// <summary>Gets whether the "working_timeout" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingTimeout {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "working_timeout" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingTimeout() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "order_type" field.</summary>
    public const int OrderTypeFieldNumber = 3;
    private readonly static uint OrderTypeDefaultValue = 0;

    private uint orderType_;
    /// <summary>
    /// Type of order placed for the leg. One of MarketTakingLimitOrderType enums.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OrderType {
      get { if ((_hasBits0 & 4) != 0) { return orderType_; } else { return OrderTypeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        orderType_ = value;
      }
    }
    /// <summary>Gets whether the "order_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "order_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderType() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MarketTakingParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MarketTakingParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AllocationPercent, other.AllocationPercent)) return false;
      if (WorkingTimeout != other.WorkingTimeout) return false;
      if (OrderType != other.OrderType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAllocationPercent) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AllocationPercent);
      if (HasWorkingTimeout) hash ^= WorkingTimeout.GetHashCode();
      if (HasOrderType) hash ^= OrderType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAllocationPercent) {
        output.WriteRawTag(9);
        output.WriteDouble(AllocationPercent);
      }
      if (HasWorkingTimeout) {
        output.WriteRawTag(16);
        output.WriteUInt32(WorkingTimeout);
      }
      if (HasOrderType) {
        output.WriteRawTag(24);
        output.WriteUInt32(OrderType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAllocationPercent) {
        output.WriteRawTag(9);
        output.WriteDouble(AllocationPercent);
      }
      if (HasWorkingTimeout) {
        output.WriteRawTag(16);
        output.WriteUInt32(WorkingTimeout);
      }
      if (HasOrderType) {
        output.WriteRawTag(24);
        output.WriteUInt32(OrderType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAllocationPercent) {
        size += 1 + 8;
      }
      if (HasWorkingTimeout) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WorkingTimeout);
      }
      if (HasOrderType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OrderType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MarketTakingParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasAllocationPercent) {
        AllocationPercent = other.AllocationPercent;
      }
      if (other.HasWorkingTimeout) {
        WorkingTimeout = other.WorkingTimeout;
      }
      if (other.HasOrderType) {
        OrderType = other.OrderType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            AllocationPercent = input.ReadDouble();
            break;
          }
          case 16: {
            WorkingTimeout = input.ReadUInt32();
            break;
          }
          case 24: {
            OrderType = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            AllocationPercent = input.ReadDouble();
            break;
          }
          case 16: {
            WorkingTimeout = input.ReadUInt32();
            break;
          }
          case 24: {
            OrderType = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the MarketTakingParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Type of order placed for the leg.
      /// </summary>
      public enum MarketTakingLimitOrderType {
        [pbr::OriginalName("MARKET_TAKING_LIMIT_ORDER_TYPE_LMT")] Lmt = 1,
        [pbr::OriginalName("MARKET_TAKING_LIMIT_ORDER_TYPE_MKT")] Mkt = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Aggregation market making mode: the order is sent immediately to the exchanges based on the allocation percent.
  /// The server then manages the orders to get them filled as quickly as possible at the given price.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class MarketMakingParameters : pb::IMessage<MarketMakingParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketMakingParameters> _parser = new pb::MessageParser<MarketMakingParameters>(() => new MarketMakingParameters());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MarketMakingParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketMakingParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketMakingParameters(MarketMakingParameters other) : this() {
      _hasBits0 = other._hasBits0;
      allocationPercent_ = other.allocationPercent_;
      uint32VisibleQty_ = other.uint32VisibleQty_;
      uint32MinVisibleQty_ = other.uint32MinVisibleQty_;
      uint32NativeVisibleQty_ = other.uint32NativeVisibleQty_;
      visibleQty_ = other.visibleQty_ != null ? other.visibleQty_.Clone() : null;
      minVisibleQty_ = other.minVisibleQty_ != null ? other.minVisibleQty_.Clone() : null;
      nativeVisibleQty_ = other.nativeVisibleQty_ != null ? other.nativeVisibleQty_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MarketMakingParameters Clone() {
      return new MarketMakingParameters(this);
    }

    /// <summary>Field number for the "allocation_percent" field.</summary>
    public const int AllocationPercentFieldNumber = 1;
    private readonly static double AllocationPercentDefaultValue = 0D;

    private double allocationPercent_;
    /// <summary>
    /// Allocation percent (in range 0...1) for the leg (doesn't have to total 100% allocation among all legs).
    /// Default is 0, the market making mode is turned off for the leg.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AllocationPercent {
      get { if ((_hasBits0 & 1) != 0) { return allocationPercent_; } else { return AllocationPercentDefaultValue; } }
      set {
        _hasBits0 |= 1;
        allocationPercent_ = value;
      }
    }
    /// <summary>Gets whether the "allocation_percent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAllocationPercent {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "allocation_percent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAllocationPercent() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_visible_qty" field.</summary>
    public const int Uint32VisibleQtyFieldNumber = 2;
    private readonly static uint Uint32VisibleQtyDefaultValue = 0;

    private uint uint32VisibleQty_;
    /// <summary>
    /// Note: use visible_qty instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32VisibleQty {
      get { if ((_hasBits0 & 2) != 0) { return uint32VisibleQty_; } else { return Uint32VisibleQtyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32VisibleQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_visible_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32VisibleQty {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_visible_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32VisibleQty() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "uint32_min_visible_qty" field.</summary>
    public const int Uint32MinVisibleQtyFieldNumber = 3;
    private readonly static uint Uint32MinVisibleQtyDefaultValue = 0;

    private uint uint32MinVisibleQty_;
    /// <summary>
    /// Note: use min_visible_qty instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32MinVisibleQty {
      get { if ((_hasBits0 & 4) != 0) { return uint32MinVisibleQty_; } else { return Uint32MinVisibleQtyDefaultValue; } }
      set {
        _hasBits0 |= 4;
        uint32MinVisibleQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_min_visible_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32MinVisibleQty {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "uint32_min_visible_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32MinVisibleQty() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "uint32_native_visible_qty" field.</summary>
    public const int Uint32NativeVisibleQtyFieldNumber = 4;
    private readonly static uint Uint32NativeVisibleQtyDefaultValue = 0;

    private uint uint32NativeVisibleQty_;
    /// <summary>
    /// Note: use native_visible_qty instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Uint32NativeVisibleQty {
      get { if ((_hasBits0 & 8) != 0) { return uint32NativeVisibleQty_; } else { return Uint32NativeVisibleQtyDefaultValue; } }
      set {
        _hasBits0 |= 8;
        uint32NativeVisibleQty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_native_visible_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUint32NativeVisibleQty {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "uint32_native_visible_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUint32NativeVisibleQty() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "visible_qty" field.</summary>
    public const int VisibleQtyFieldNumber = 5;
    private global::Cqg.Decimal visibleQty_;
    /// <summary>
    /// Visible size in lots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal VisibleQty {
      get { return visibleQty_; }
      set {
        visibleQty_ = value;
      }
    }

    /// <summary>Field number for the "min_visible_qty" field.</summary>
    public const int MinVisibleQtyFieldNumber = 6;
    private global::Cqg.Decimal minVisibleQty_;
    /// <summary>
    /// Min visible size in lots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal MinVisibleQty {
      get { return minVisibleQty_; }
      set {
        minVisibleQty_ = value;
      }
    }

    /// <summary>Field number for the "native_visible_qty" field.</summary>
    public const int NativeVisibleQtyFieldNumber = 7;
    private global::Cqg.Decimal nativeVisibleQty_;
    /// <summary>
    /// Visible size of native Iceberg.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal NativeVisibleQty {
      get { return nativeVisibleQty_; }
      set {
        nativeVisibleQty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MarketMakingParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MarketMakingParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AllocationPercent, other.AllocationPercent)) return false;
      if (Uint32VisibleQty != other.Uint32VisibleQty) return false;
      if (Uint32MinVisibleQty != other.Uint32MinVisibleQty) return false;
      if (Uint32NativeVisibleQty != other.Uint32NativeVisibleQty) return false;
      if (!object.Equals(VisibleQty, other.VisibleQty)) return false;
      if (!object.Equals(MinVisibleQty, other.MinVisibleQty)) return false;
      if (!object.Equals(NativeVisibleQty, other.NativeVisibleQty)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAllocationPercent) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AllocationPercent);
      if (HasUint32VisibleQty) hash ^= Uint32VisibleQty.GetHashCode();
      if (HasUint32MinVisibleQty) hash ^= Uint32MinVisibleQty.GetHashCode();
      if (HasUint32NativeVisibleQty) hash ^= Uint32NativeVisibleQty.GetHashCode();
      if (visibleQty_ != null) hash ^= VisibleQty.GetHashCode();
      if (minVisibleQty_ != null) hash ^= MinVisibleQty.GetHashCode();
      if (nativeVisibleQty_ != null) hash ^= NativeVisibleQty.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAllocationPercent) {
        output.WriteRawTag(9);
        output.WriteDouble(AllocationPercent);
      }
      if (HasUint32VisibleQty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        output.WriteRawTag(24);
        output.WriteUInt32(Uint32MinVisibleQty);
      }
      if (HasUint32NativeVisibleQty) {
        output.WriteRawTag(32);
        output.WriteUInt32(Uint32NativeVisibleQty);
      }
      if (visibleQty_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VisibleQty);
      }
      if (minVisibleQty_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(MinVisibleQty);
      }
      if (nativeVisibleQty_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NativeVisibleQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAllocationPercent) {
        output.WriteRawTag(9);
        output.WriteDouble(AllocationPercent);
      }
      if (HasUint32VisibleQty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        output.WriteRawTag(24);
        output.WriteUInt32(Uint32MinVisibleQty);
      }
      if (HasUint32NativeVisibleQty) {
        output.WriteRawTag(32);
        output.WriteUInt32(Uint32NativeVisibleQty);
      }
      if (visibleQty_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VisibleQty);
      }
      if (minVisibleQty_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(MinVisibleQty);
      }
      if (nativeVisibleQty_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NativeVisibleQty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAllocationPercent) {
        size += 1 + 8;
      }
      if (HasUint32VisibleQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32VisibleQty);
      }
      if (HasUint32MinVisibleQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32MinVisibleQty);
      }
      if (HasUint32NativeVisibleQty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32NativeVisibleQty);
      }
      if (visibleQty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VisibleQty);
      }
      if (minVisibleQty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinVisibleQty);
      }
      if (nativeVisibleQty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NativeVisibleQty);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MarketMakingParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasAllocationPercent) {
        AllocationPercent = other.AllocationPercent;
      }
      if (other.HasUint32VisibleQty) {
        Uint32VisibleQty = other.Uint32VisibleQty;
      }
      if (other.HasUint32MinVisibleQty) {
        Uint32MinVisibleQty = other.Uint32MinVisibleQty;
      }
      if (other.HasUint32NativeVisibleQty) {
        Uint32NativeVisibleQty = other.Uint32NativeVisibleQty;
      }
      if (other.visibleQty_ != null) {
        if (visibleQty_ == null) {
          VisibleQty = new global::Cqg.Decimal();
        }
        VisibleQty.MergeFrom(other.VisibleQty);
      }
      if (other.minVisibleQty_ != null) {
        if (minVisibleQty_ == null) {
          MinVisibleQty = new global::Cqg.Decimal();
        }
        MinVisibleQty.MergeFrom(other.MinVisibleQty);
      }
      if (other.nativeVisibleQty_ != null) {
        if (nativeVisibleQty_ == null) {
          NativeVisibleQty = new global::Cqg.Decimal();
        }
        NativeVisibleQty.MergeFrom(other.NativeVisibleQty);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            AllocationPercent = input.ReadDouble();
            break;
          }
          case 16: {
            Uint32VisibleQty = input.ReadUInt32();
            break;
          }
          case 24: {
            Uint32MinVisibleQty = input.ReadUInt32();
            break;
          }
          case 32: {
            Uint32NativeVisibleQty = input.ReadUInt32();
            break;
          }
          case 42: {
            if (visibleQty_ == null) {
              VisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(VisibleQty);
            break;
          }
          case 50: {
            if (minVisibleQty_ == null) {
              MinVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinVisibleQty);
            break;
          }
          case 58: {
            if (nativeVisibleQty_ == null) {
              NativeVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(NativeVisibleQty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            AllocationPercent = input.ReadDouble();
            break;
          }
          case 16: {
            Uint32VisibleQty = input.ReadUInt32();
            break;
          }
          case 24: {
            Uint32MinVisibleQty = input.ReadUInt32();
            break;
          }
          case 32: {
            Uint32NativeVisibleQty = input.ReadUInt32();
            break;
          }
          case 42: {
            if (visibleQty_ == null) {
              VisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(VisibleQty);
            break;
          }
          case 50: {
            if (minVisibleQty_ == null) {
              MinVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(MinVisibleQty);
            break;
          }
          case 58: {
            if (nativeVisibleQty_ == null) {
              NativeVisibleQty = new global::Cqg.Decimal();
            }
            input.ReadMessage(NativeVisibleQty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request to resolve previously reported hung quantity on a synthetic strategy order by
  /// 1) placing orders to offset filled leg position(s) at current mkt price(s) and (simultaneously)
  /// 2) cancelling the hung quantity.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SyntheticLiquidate : pb::IMessage<SyntheticLiquidate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SyntheticLiquidate> _parser = new pb::MessageParser<SyntheticLiquidate>(() => new SyntheticLiquidate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SyntheticLiquidate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticLiquidate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticLiquidate(SyntheticLiquidate other) : this() {
      _hasBits0 = other._hasBits0;
      accountId_ = other.accountId_;
      orderId_ = other.orderId_;
      hangId_ = other.hangId_;
      whenUtcTime_ = other.whenUtcTime_;
      whenUtcTimestamp_ = other.whenUtcTimestamp_ != null ? other.whenUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticLiquidate Clone() {
      return new SyntheticLiquidate(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Id of an account that is used to place an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 1) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "order_id" field.</summary>
    public const int OrderIdFieldNumber = 2;
    private readonly static string OrderIdDefaultValue = "";

    private string orderId_;
    /// <summary>
    /// Order id assigned by server after last modification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OrderId {
      get { return orderId_ ?? OrderIdDefaultValue; }
      set {
        orderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderId {
      get { return orderId_ != null; }
    }
    /// <summary>Clears the value of the "order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderId() {
      orderId_ = null;
    }

    /// <summary>Field number for the "hang_id" field.</summary>
    public const int HangIdFieldNumber = 3;
    private readonly static int HangIdDefaultValue = 0;

    private int hangId_;
    /// <summary>
    /// Id of the hang from the SyntheticHang message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HangId {
      get { if ((_hasBits0 & 2) != 0) { return hangId_; } else { return HangIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        hangId_ = value;
      }
    }
    /// <summary>Gets whether the "hang_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHangId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "hang_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHangId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "when_utc_time" field.</summary>
    public const int WhenUtcTimeFieldNumber = 4;
    private readonly static long WhenUtcTimeDefaultValue = 0L;

    private long whenUtcTime_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// Note: use when_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long WhenUtcTime {
      get { if ((_hasBits0 & 4) != 0) { return whenUtcTime_; } else { return WhenUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        whenUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "when_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWhenUtcTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "when_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWhenUtcTime() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "when_utc_timestamp" field.</summary>
    public const int WhenUtcTimestampFieldNumber = 5;
    private global::Google.Protobuf.Timestamp whenUtcTimestamp_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp WhenUtcTimestamp {
      get { return whenUtcTimestamp_; }
      set {
        whenUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SyntheticLiquidate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SyntheticLiquidate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccountId != other.AccountId) return false;
      if (OrderId != other.OrderId) return false;
      if (HangId != other.HangId) return false;
      if (WhenUtcTime != other.WhenUtcTime) return false;
      if (!object.Equals(WhenUtcTimestamp, other.WhenUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasOrderId) hash ^= OrderId.GetHashCode();
      if (HasHangId) hash ^= HangId.GetHashCode();
      if (HasWhenUtcTime) hash ^= WhenUtcTime.GetHashCode();
      if (whenUtcTimestamp_ != null) hash ^= WhenUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OrderId);
      }
      if (HasHangId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(HangId);
      }
      if (HasWhenUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SyntheticLiquidate other) {
      if (other == null) {
        return;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasOrderId) {
        OrderId = other.OrderId;
      }
      if (other.HasHangId) {
        HangId = other.HangId;
      }
      if (other.HasWhenUtcTime) {
        WhenUtcTime = other.WhenUtcTime;
      }
      if (other.whenUtcTimestamp_ != null) {
        if (whenUtcTimestamp_ == null) {
          WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        WhenUtcTimestamp.MergeFrom(other.WhenUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request to resolve previously reported hung quantity on a synthetic strategy order by
  /// 1) placing LMT orders to offset filled leg position(s) at their fill price(s) and (simultaneously)
  /// 2) cancelling the hung quantity.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SyntheticScratch : pb::IMessage<SyntheticScratch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SyntheticScratch> _parser = new pb::MessageParser<SyntheticScratch>(() => new SyntheticScratch());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SyntheticScratch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticScratch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticScratch(SyntheticScratch other) : this() {
      _hasBits0 = other._hasBits0;
      accountId_ = other.accountId_;
      orderId_ = other.orderId_;
      hangId_ = other.hangId_;
      whenUtcTime_ = other.whenUtcTime_;
      whenUtcTimestamp_ = other.whenUtcTimestamp_ != null ? other.whenUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SyntheticScratch Clone() {
      return new SyntheticScratch(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Id of an account that is used to place an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 1) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "order_id" field.</summary>
    public const int OrderIdFieldNumber = 2;
    private readonly static string OrderIdDefaultValue = "";

    private string orderId_;
    /// <summary>
    /// Order id assigned by server after last modification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OrderId {
      get { return orderId_ ?? OrderIdDefaultValue; }
      set {
        orderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderId {
      get { return orderId_ != null; }
    }
    /// <summary>Clears the value of the "order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderId() {
      orderId_ = null;
    }

    /// <summary>Field number for the "hang_id" field.</summary>
    public const int HangIdFieldNumber = 3;
    private readonly static int HangIdDefaultValue = 0;

    private int hangId_;
    /// <summary>
    /// Id of the hang from the SyntheticHang message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HangId {
      get { if ((_hasBits0 & 2) != 0) { return hangId_; } else { return HangIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        hangId_ = value;
      }
    }
    /// <summary>Gets whether the "hang_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHangId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "hang_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHangId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "when_utc_time" field.</summary>
    public const int WhenUtcTimeFieldNumber = 4;
    private readonly static long WhenUtcTimeDefaultValue = 0L;

    private long whenUtcTime_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// Note: use when_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long WhenUtcTime {
      get { if ((_hasBits0 & 4) != 0) { return whenUtcTime_; } else { return WhenUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        whenUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "when_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWhenUtcTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "when_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWhenUtcTime() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "when_utc_timestamp" field.</summary>
    public const int WhenUtcTimestampFieldNumber = 5;
    private global::Google.Protobuf.Timestamp whenUtcTimestamp_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp WhenUtcTimestamp {
      get { return whenUtcTimestamp_; }
      set {
        whenUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SyntheticScratch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SyntheticScratch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccountId != other.AccountId) return false;
      if (OrderId != other.OrderId) return false;
      if (HangId != other.HangId) return false;
      if (WhenUtcTime != other.WhenUtcTime) return false;
      if (!object.Equals(WhenUtcTimestamp, other.WhenUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasOrderId) hash ^= OrderId.GetHashCode();
      if (HasHangId) hash ^= HangId.GetHashCode();
      if (HasWhenUtcTime) hash ^= WhenUtcTime.GetHashCode();
      if (whenUtcTimestamp_ != null) hash ^= WhenUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OrderId);
      }
      if (HasHangId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(HangId);
      }
      if (HasWhenUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SyntheticScratch other) {
      if (other == null) {
        return;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasOrderId) {
        OrderId = other.OrderId;
      }
      if (other.HasHangId) {
        HangId = other.HangId;
      }
      if (other.HasWhenUtcTime) {
        WhenUtcTime = other.WhenUtcTime;
      }
      if (other.whenUtcTimestamp_ != null) {
        if (whenUtcTimestamp_ == null) {
          WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        WhenUtcTimestamp.MergeFrom(other.WhenUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Modify an order to get an immediate fill
  /// (on either the entire order or previously reported hanging quantity on a synthetic strategy order).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GoMarket : pb::IMessage<GoMarket>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GoMarket> _parser = new pb::MessageParser<GoMarket>(() => new GoMarket());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GoMarket> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Strategy2.Strategy2Reflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GoMarket() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GoMarket(GoMarket other) : this() {
      _hasBits0 = other._hasBits0;
      accountId_ = other.accountId_;
      orderId_ = other.orderId_;
      hangId_ = other.hangId_;
      whenUtcTime_ = other.whenUtcTime_;
      whenUtcTimestamp_ = other.whenUtcTimestamp_ != null ? other.whenUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GoMarket Clone() {
      return new GoMarket(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Id of an account that is used to place an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AccountId {
      get { if ((_hasBits0 & 1) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "order_id" field.</summary>
    public const int OrderIdFieldNumber = 2;
    private readonly static string OrderIdDefaultValue = "";

    private string orderId_;
    /// <summary>
    /// Order id assigned by the server after the last modification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OrderId {
      get { return orderId_ ?? OrderIdDefaultValue; }
      set {
        orderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOrderId {
      get { return orderId_ != null; }
    }
    /// <summary>Clears the value of the "order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOrderId() {
      orderId_ = null;
    }

    /// <summary>Field number for the "hang_id" field.</summary>
    public const int HangIdFieldNumber = 3;
    private readonly static int HangIdDefaultValue = 0;

    private int hangId_;
    /// <summary>
    /// Id of the hang from the SyntheticHang message,
    /// if this request applies to hung quantity on a synthetic strategy order;
    /// Not set, if this request applies to the whole order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HangId {
      get { if ((_hasBits0 & 2) != 0) { return hangId_; } else { return HangIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        hangId_ = value;
      }
    }
    /// <summary>Gets whether the "hang_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHangId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "hang_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHangId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "when_utc_time" field.</summary>
    public const int WhenUtcTimeFieldNumber = 4;
    private readonly static long WhenUtcTimeDefaultValue = 0L;

    private long whenUtcTime_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// Note: use when_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long WhenUtcTime {
      get { if ((_hasBits0 & 4) != 0) { return whenUtcTime_; } else { return WhenUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        whenUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "when_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWhenUtcTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "when_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWhenUtcTime() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "when_utc_timestamp" field.</summary>
    public const int WhenUtcTimestampFieldNumber = 5;
    private global::Google.Protobuf.Timestamp whenUtcTimestamp_;
    /// <summary>
    /// Client side time when a request was submitted (UTC).
    /// If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.Timestamp WhenUtcTimestamp {
      get { return whenUtcTimestamp_; }
      set {
        whenUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GoMarket);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GoMarket other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AccountId != other.AccountId) return false;
      if (OrderId != other.OrderId) return false;
      if (HangId != other.HangId) return false;
      if (WhenUtcTime != other.WhenUtcTime) return false;
      if (!object.Equals(WhenUtcTimestamp, other.WhenUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasOrderId) hash ^= OrderId.GetHashCode();
      if (HasHangId) hash ^= HangId.GetHashCode();
      if (HasWhenUtcTime) hash ^= WhenUtcTime.GetHashCode();
      if (whenUtcTimestamp_ != null) hash ^= WhenUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAccountId) {
        output.WriteRawTag(8);
        output.WriteSInt32(AccountId);
      }
      if (HasOrderId) {
        output.WriteRawTag(18);
        output.WriteString(OrderId);
      }
      if (HasHangId) {
        output.WriteRawTag(24);
        output.WriteSInt32(HangId);
      }
      if (HasWhenUtcTime) {
        output.WriteRawTag(32);
        output.WriteSInt64(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OrderId);
      }
      if (HasHangId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(HangId);
      }
      if (HasWhenUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(WhenUtcTime);
      }
      if (whenUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WhenUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GoMarket other) {
      if (other == null) {
        return;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasOrderId) {
        OrderId = other.OrderId;
      }
      if (other.HasHangId) {
        HangId = other.HangId;
      }
      if (other.HasWhenUtcTime) {
        WhenUtcTime = other.WhenUtcTime;
      }
      if (other.whenUtcTimestamp_ != null) {
        if (whenUtcTimestamp_ == null) {
          WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        WhenUtcTimestamp.MergeFrom(other.WhenUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 18: {
            OrderId = input.ReadString();
            break;
          }
          case 24: {
            HangId = input.ReadSInt32();
            break;
          }
          case 32: {
            WhenUtcTime = input.ReadSInt64();
            break;
          }
          case 42: {
            if (whenUtcTimestamp_ == null) {
              WhenUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(WhenUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
