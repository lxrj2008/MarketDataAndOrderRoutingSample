// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/strategy_definition_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace StrategyDefinition2 {

  /// <summary>Holder for reflection information generated from WebAPI/strategy_definition_2.proto</summary>
  public static partial class StrategyDefinition2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/strategy_definition_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static StrategyDefinition2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJXZWJBUEkvc3RyYXRlZ3lfZGVmaW5pdGlvbl8yLnByb3RvEhVzdHJhdGVn",
            "eV9kZWZpbml0aW9uXzIaFGNvbW1vbi9kZWNpbWFsLnByb3RvIpUDChJTdHJh",
            "dGVneURlZmluaXRpb24SEwoLYWdncmVnYXRpb24YASABKAgSQgoRZXhjaGFu",
            "Z2Vfc3RyYXRlZ3kYAiABKAsyJy5zdHJhdGVneV9kZWZpbml0aW9uXzIuRXhj",
            "aGFuZ2VTdHJhdGVneRIVCg1uYXRpdmVfc3ByZWFkGAkgASgIEhEKCXRpY2tf",
            "c2l6ZRgDIAEoARIUCgxwcmljZV9vZmZzZXQYBCABKAESFgoOcm91bmRfbGVn",
            "X21vZGUYBSABKA0SEgoKbm9kZV9pbmRleBgGIAIoDRJHChBub2RlX2RlZmlu",
            "aXRpb25zGAcgAygLMi0uc3RyYXRlZ3lfZGVmaW5pdGlvbl8yLlN0cmF0ZWd5",
            "Tm9kZURlZmluaXRpb24SGAoQdXNlcl9kZXNjcmlwdGlvbhgIIAEoCSJXCgxS",
            "b3VuZExlZ01vZGUSFwoTUk9VTkRfTEVHX01PREVfRE9XThABEhUKEVJPVU5E",
            "X0xFR19NT0RFX1VQEAISFwoTUk9VTkRfTEVHX01PREVfTUFUSBADIi4KEEV4",
            "Y2hhbmdlU3RyYXRlZ3kSGgoScmVxdWVzdGVkX2NxZ190eXBlGAEgASgJIt4B",
            "Cg1MZWdEZWZpbml0aW9uEhMKC2NvbnRyYWN0X2lkGAEgAigNEhIKCm5vZGVf",
            "aW5kZXgYAiACKA0SHAoQZG91YmxlX3F0eV9yYXRpbxgDIAEoAUICGAESHwoJ",
            "cXR5X3JhdGlvGAggASgLMgwuY3FnLkRlY2ltYWwSEwoLcHJpY2VfcmF0aW8Y",
            "BCABKAESFAoMcHJpY2Vfb2Zmc2V0GAUgASgBEhYKDmNvdmVyaW5nX3ByaWNl",
            "GAYgASgBEiIKDG9wdGlvbl9kZWx0YRgHIAEoCzIMLmNxZy5EZWNpbWFsIrgB",
            "Cg5OZXN0ZWRTdHJhdGVneRI9CgpkZWZpbml0aW9uGAEgAigLMikuc3RyYXRl",
            "Z3lfZGVmaW5pdGlvbl8yLlN0cmF0ZWd5RGVmaW5pdGlvbhITCgtjb250cmFj",
            "dF9pZBgEIAEoDRIcChBkb3VibGVfcXR5X3JhdGlvGAIgASgBQgIYARIfCglx",
            "dHlfcmF0aW8YBSABKAsyDC5jcWcuRGVjaW1hbBITCgtwcmljZV9yYXRpbxgD",
            "IAEoASL8AQoWU3RyYXRlZ3lOb2RlRGVmaW5pdGlvbhIWCg5ub2RlX29wZXJh",
            "dGlvbhgCIAEoDRIxCgNsZWcYAyABKAsyJC5zdHJhdGVneV9kZWZpbml0aW9u",
            "XzIuTGVnRGVmaW5pdGlvbhI+Cg9uZXN0ZWRfc3RyYXRlZ3kYBCABKAsyJS5z",
            "dHJhdGVneV9kZWZpbml0aW9uXzIuTmVzdGVkU3RyYXRlZ3kiVwoNTm9kZU9w",
            "ZXJhdGlvbhIWChJOT0RFX09QRVJBVElPTl9TVU0QARIWChJOT0RFX09QRVJB",
            "VElPTl9NVUwQAhIWChJOT0RFX09QRVJBVElPTl9ESVYQAyJCChZBbGdvU3Ry",
            "YXRlZ3lEZWZpbml0aW9uEhQKDGFiYnJldmlhdGlvbhgBIAEoCRISCgpkZWZp",
            "bml0aW9uGAIgASgJ"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Cqg.DecimalReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.StrategyDefinition), global::StrategyDefinition2.StrategyDefinition.Parser, new[]{ "Aggregation", "ExchangeStrategy", "NativeSpread", "TickSize", "PriceOffset", "RoundLegMode", "NodeIndex", "NodeDefinitions", "UserDescription" }, null, new[]{ typeof(global::StrategyDefinition2.StrategyDefinition.Types.RoundLegMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.ExchangeStrategy), global::StrategyDefinition2.ExchangeStrategy.Parser, new[]{ "RequestedCqgType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.LegDefinition), global::StrategyDefinition2.LegDefinition.Parser, new[]{ "ContractId", "NodeIndex", "DoubleQtyRatio", "QtyRatio", "PriceRatio", "PriceOffset", "CoveringPrice", "OptionDelta" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.NestedStrategy), global::StrategyDefinition2.NestedStrategy.Parser, new[]{ "Definition", "ContractId", "DoubleQtyRatio", "QtyRatio", "PriceRatio" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.StrategyNodeDefinition), global::StrategyDefinition2.StrategyNodeDefinition.Parser, new[]{ "NodeOperation", "Leg", "NestedStrategy" }, null, new[]{ typeof(global::StrategyDefinition2.StrategyNodeDefinition.Types.NodeOperation) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.AlgoStrategyDefinition), global::StrategyDefinition2.AlgoStrategyDefinition.Parser, new[]{ "Abbreviation", "Definition" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Message describing a synthetic, a user defined strategy or a native spread.
  /// It is a tree where terminal nodes (legs) are outright contracts, non-terminal ones are nested strategies.
  /// Nodes are defined from the BUY perspective.
  /// Maximum strategy nesting level:
  /// - Synthetic strategies: 2 (i.e. strategy of strategies of legs);
  /// - Exchange strategies: depends only on exchange.
  /// Maximum number of legs in the whole strategy:
  /// - Synthetic strategies: 40;
  /// - Exchange strategies: depends only on exchange.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyDefinition : pb::IMessage<StrategyDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyDefinition> _parser = new pb::MessageParser<StrategyDefinition>(() => new StrategyDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinition(StrategyDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      aggregation_ = other.aggregation_;
      exchangeStrategy_ = other.exchangeStrategy_ != null ? other.exchangeStrategy_.Clone() : null;
      nativeSpread_ = other.nativeSpread_;
      tickSize_ = other.tickSize_;
      priceOffset_ = other.priceOffset_;
      roundLegMode_ = other.roundLegMode_;
      nodeIndex_ = other.nodeIndex_;
      nodeDefinitions_ = other.nodeDefinitions_.Clone();
      userDescription_ = other.userDescription_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyDefinition Clone() {
      return new StrategyDefinition(this);
    }

    /// <summary>Field number for the "aggregation" field.</summary>
    public const int AggregationFieldNumber = 1;
    private readonly static bool AggregationDefaultValue = false;

    private bool aggregation_;
    /// <summary>
    /// The strategy is of the aggregation type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Aggregation {
      get { if ((_hasBits0 & 1) != 0) { return aggregation_; } else { return AggregationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        aggregation_ = value;
      }
    }
    /// <summary>Gets whether the "aggregation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAggregation {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "aggregation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAggregation() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "exchange_strategy" field.</summary>
    public const int ExchangeStrategyFieldNumber = 2;
    private global::StrategyDefinition2.ExchangeStrategy exchangeStrategy_;
    /// <summary>
    /// If specified - defines exchange strategy, otherwise - synthetic strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::StrategyDefinition2.ExchangeStrategy ExchangeStrategy {
      get { return exchangeStrategy_; }
      set {
        exchangeStrategy_ = value;
      }
    }

    /// <summary>Field number for the "native_spread" field.</summary>
    public const int NativeSpreadFieldNumber = 9;
    private readonly static bool NativeSpreadDefaultValue = false;

    private bool nativeSpread_;
    /// <summary>
    /// The strategy is a native spread.
    /// Note: this field can only be set by server and cannot be used in StrategyDefinitionRequest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NativeSpread {
      get { if ((_hasBits0 & 32) != 0) { return nativeSpread_; } else { return NativeSpreadDefaultValue; } }
      set {
        _hasBits0 |= 32;
        nativeSpread_ = value;
      }
    }
    /// <summary>Gets whether the "native_spread" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNativeSpread {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "native_spread" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNativeSpread() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "tick_size" field.</summary>
    public const int TickSizeFieldNumber = 3;
    private readonly static double TickSizeDefaultValue = 0D;

    private double tickSize_;
    /// <summary>
    /// Strategy tick size (correct price format). The tick size of the 1st leg is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double TickSize {
      get { if ((_hasBits0 & 2) != 0) { return tickSize_; } else { return TickSizeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tickSize_ = value;
      }
    }
    /// <summary>Gets whether the "tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTickSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTickSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "price_offset" field.</summary>
    public const int PriceOffsetFieldNumber = 4;
    private readonly static double PriceOffsetDefaultValue = 0D;

    private double priceOffset_;
    /// <summary>
    /// Additive offset for computation of strategy price.
    /// 0 is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PriceOffset {
      get { if ((_hasBits0 & 4) != 0) { return priceOffset_; } else { return PriceOffsetDefaultValue; } }
      set {
        _hasBits0 |= 4;
        priceOffset_ = value;
      }
    }
    /// <summary>Gets whether the "price_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceOffset {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceOffset() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "round_leg_mode" field.</summary>
    public const int RoundLegModeFieldNumber = 5;
    private readonly static uint RoundLegModeDefaultValue = 0;

    private uint roundLegMode_;
    /// <summary>
    /// Controls how to handle fractional quantities when calculating leg quantities for an order on this strategy,
    /// One of RoundLegMode enums, ROUND_LEG_MODE_DOWN is default. Ignored for aggregations and exchange strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint RoundLegMode {
      get { if ((_hasBits0 & 8) != 0) { return roundLegMode_; } else { return RoundLegModeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        roundLegMode_ = value;
      }
    }
    /// <summary>Gets whether the "round_leg_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRoundLegMode {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "round_leg_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRoundLegMode() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 6;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 16) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "node_definitions" field.</summary>
    public const int NodeDefinitionsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::StrategyDefinition2.StrategyNodeDefinition> _repeated_nodeDefinitions_codec
        = pb::FieldCodec.ForMessage(58, global::StrategyDefinition2.StrategyNodeDefinition.Parser);
    private readonly pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition> nodeDefinitions_ = new pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition>();
    /// <summary>
    /// Legs or nested strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition> NodeDefinitions {
      get { return nodeDefinitions_; }
    }

    /// <summary>Field number for the "user_description" field.</summary>
    public const int UserDescriptionFieldNumber = 8;
    private readonly static string UserDescriptionDefaultValue = "";

    private string userDescription_;
    /// <summary>
    /// User text associated with the strategy. Allowed to be specified only for non-exchange strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string UserDescription {
      get { return userDescription_ ?? UserDescriptionDefaultValue; }
      set {
        userDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user_description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUserDescription {
      get { return userDescription_ != null; }
    }
    /// <summary>Clears the value of the "user_description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUserDescription() {
      userDescription_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Aggregation != other.Aggregation) return false;
      if (!object.Equals(ExchangeStrategy, other.ExchangeStrategy)) return false;
      if (NativeSpread != other.NativeSpread) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickSize, other.TickSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceOffset, other.PriceOffset)) return false;
      if (RoundLegMode != other.RoundLegMode) return false;
      if (NodeIndex != other.NodeIndex) return false;
      if(!nodeDefinitions_.Equals(other.nodeDefinitions_)) return false;
      if (UserDescription != other.UserDescription) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAggregation) hash ^= Aggregation.GetHashCode();
      if (exchangeStrategy_ != null) hash ^= ExchangeStrategy.GetHashCode();
      if (HasNativeSpread) hash ^= NativeSpread.GetHashCode();
      if (HasTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickSize);
      if (HasPriceOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceOffset);
      if (HasRoundLegMode) hash ^= RoundLegMode.GetHashCode();
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      hash ^= nodeDefinitions_.GetHashCode();
      if (HasUserDescription) hash ^= UserDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAggregation) {
        output.WriteRawTag(8);
        output.WriteBool(Aggregation);
      }
      if (exchangeStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExchangeStrategy);
      }
      if (HasTickSize) {
        output.WriteRawTag(25);
        output.WriteDouble(TickSize);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceOffset);
      }
      if (HasRoundLegMode) {
        output.WriteRawTag(40);
        output.WriteUInt32(RoundLegMode);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(48);
        output.WriteUInt32(NodeIndex);
      }
      nodeDefinitions_.WriteTo(output, _repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        output.WriteRawTag(66);
        output.WriteString(UserDescription);
      }
      if (HasNativeSpread) {
        output.WriteRawTag(72);
        output.WriteBool(NativeSpread);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAggregation) {
        output.WriteRawTag(8);
        output.WriteBool(Aggregation);
      }
      if (exchangeStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExchangeStrategy);
      }
      if (HasTickSize) {
        output.WriteRawTag(25);
        output.WriteDouble(TickSize);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceOffset);
      }
      if (HasRoundLegMode) {
        output.WriteRawTag(40);
        output.WriteUInt32(RoundLegMode);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(48);
        output.WriteUInt32(NodeIndex);
      }
      nodeDefinitions_.WriteTo(ref output, _repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        output.WriteRawTag(66);
        output.WriteString(UserDescription);
      }
      if (HasNativeSpread) {
        output.WriteRawTag(72);
        output.WriteBool(NativeSpread);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAggregation) {
        size += 1 + 1;
      }
      if (exchangeStrategy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExchangeStrategy);
      }
      if (HasNativeSpread) {
        size += 1 + 1;
      }
      if (HasTickSize) {
        size += 1 + 8;
      }
      if (HasPriceOffset) {
        size += 1 + 8;
      }
      if (HasRoundLegMode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoundLegMode);
      }
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      size += nodeDefinitions_.CalculateSize(_repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(UserDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasAggregation) {
        Aggregation = other.Aggregation;
      }
      if (other.exchangeStrategy_ != null) {
        if (exchangeStrategy_ == null) {
          ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
        }
        ExchangeStrategy.MergeFrom(other.ExchangeStrategy);
      }
      if (other.HasNativeSpread) {
        NativeSpread = other.NativeSpread;
      }
      if (other.HasTickSize) {
        TickSize = other.TickSize;
      }
      if (other.HasPriceOffset) {
        PriceOffset = other.PriceOffset;
      }
      if (other.HasRoundLegMode) {
        RoundLegMode = other.RoundLegMode;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      nodeDefinitions_.Add(other.nodeDefinitions_);
      if (other.HasUserDescription) {
        UserDescription = other.UserDescription;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Aggregation = input.ReadBool();
            break;
          }
          case 18: {
            if (exchangeStrategy_ == null) {
              ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
            }
            input.ReadMessage(ExchangeStrategy);
            break;
          }
          case 25: {
            TickSize = input.ReadDouble();
            break;
          }
          case 33: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 40: {
            RoundLegMode = input.ReadUInt32();
            break;
          }
          case 48: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 58: {
            nodeDefinitions_.AddEntriesFrom(input, _repeated_nodeDefinitions_codec);
            break;
          }
          case 66: {
            UserDescription = input.ReadString();
            break;
          }
          case 72: {
            NativeSpread = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Aggregation = input.ReadBool();
            break;
          }
          case 18: {
            if (exchangeStrategy_ == null) {
              ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
            }
            input.ReadMessage(ExchangeStrategy);
            break;
          }
          case 25: {
            TickSize = input.ReadDouble();
            break;
          }
          case 33: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 40: {
            RoundLegMode = input.ReadUInt32();
            break;
          }
          case 48: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 58: {
            nodeDefinitions_.AddEntriesFrom(ref input, _repeated_nodeDefinitions_codec);
            break;
          }
          case 66: {
            UserDescription = input.ReadString();
            break;
          }
          case 72: {
            NativeSpread = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyDefinition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Using a fractional trade ratio may result in fractional lots. If so, the number of lots has to be rounded.
      /// Rounding applies only to complex strategies with fractional quantity ratios.
      /// </summary>
      public enum RoundLegMode {
        /// <summary>
        /// always round down, e.g. 1.1 -> 1 and -2.1 -> -2
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_DOWN")] Down = 1,
        /// <summary>
        /// always round up, e.g. 1.1 -> 2 and -2.1 -> -3
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_UP")] Up = 2,
        /// <summary>
        /// round up when fractional part is 5 or greater;
        /// round down when fractional part is less than 5, e.g. 1.1 -> 1 and 1.6 -> 2
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_MATH")] Math = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Defines a strategy created by an individual and registered by an exchange for general open market trading.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ExchangeStrategy : pb::IMessage<ExchangeStrategy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExchangeStrategy> _parser = new pb::MessageParser<ExchangeStrategy>(() => new ExchangeStrategy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExchangeStrategy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExchangeStrategy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExchangeStrategy(ExchangeStrategy other) : this() {
      requestedCqgType_ = other.requestedCqgType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExchangeStrategy Clone() {
      return new ExchangeStrategy(this);
    }

    /// <summary>Field number for the "requested_cqg_type" field.</summary>
    public const int RequestedCqgTypeFieldNumber = 1;
    private readonly static string RequestedCqgTypeDefaultValue = "";

    private string requestedCqgType_;
    /// <summary>
    /// Value of this field might be chosen from the predefined list to specify requested CQG exchange strategy type.
    /// List of supported types can be found in document ExchangeStrategyRequestedCQGTypes.adoc.
    /// "custom" if omitted.
    /// This field is never provided in response.
    /// Strategy can be created on exchange even if requested type is different than actual type recognized by exchange.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RequestedCqgType {
      get { return requestedCqgType_ ?? RequestedCqgTypeDefaultValue; }
      set {
        requestedCqgType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "requested_cqg_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRequestedCqgType {
      get { return requestedCqgType_ != null; }
    }
    /// <summary>Clears the value of the "requested_cqg_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRequestedCqgType() {
      requestedCqgType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExchangeStrategy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExchangeStrategy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RequestedCqgType != other.RequestedCqgType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequestedCqgType) hash ^= RequestedCqgType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRequestedCqgType) {
        output.WriteRawTag(10);
        output.WriteString(RequestedCqgType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRequestedCqgType) {
        output.WriteRawTag(10);
        output.WriteString(RequestedCqgType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRequestedCqgType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RequestedCqgType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExchangeStrategy other) {
      if (other == null) {
        return;
      }
      if (other.HasRequestedCqgType) {
        RequestedCqgType = other.RequestedCqgType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RequestedCqgType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RequestedCqgType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a leg (resolved contract) of a strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LegDefinition : pb::IMessage<LegDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LegDefinition> _parser = new pb::MessageParser<LegDefinition>(() => new LegDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LegDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LegDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LegDefinition(LegDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      nodeIndex_ = other.nodeIndex_;
      doubleQtyRatio_ = other.doubleQtyRatio_;
      qtyRatio_ = other.qtyRatio_ != null ? other.qtyRatio_.Clone() : null;
      priceRatio_ = other.priceRatio_;
      priceOffset_ = other.priceOffset_;
      coveringPrice_ = other.coveringPrice_;
      optionDelta_ = other.optionDelta_ != null ? other.optionDelta_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LegDefinition Clone() {
      return new LegDefinition(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Id of the leg contract.
    /// Note: in case of receiving unknown id the contract metadata can be obtained via ContractMetadataRequest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 2;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeIndex {
      get { if ((_hasBits0 & 2) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "double_qty_ratio" field.</summary>
    public const int DoubleQtyRatioFieldNumber = 3;
    private readonly static double DoubleQtyRatioDefaultValue = 0D;

    private double doubleQtyRatio_;
    /// <summary>
    /// Note: use qty_ratio field instead.
    /// This field has precision 1e-12 and can have maximum value of 9223372.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double DoubleQtyRatio {
      get { if ((_hasBits0 & 4) != 0) { return doubleQtyRatio_; } else { return DoubleQtyRatioDefaultValue; } }
      set {
        _hasBits0 |= 4;
        doubleQtyRatio_ = value;
      }
    }
    /// <summary>Gets whether the "double_qty_ratio" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDoubleQtyRatio {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "double_qty_ratio" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDoubleQtyRatio() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "qty_ratio" field.</summary>
    public const int QtyRatioFieldNumber = 8;
    private global::Cqg.Decimal qtyRatio_;
    /// <summary>
    /// Leg quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
    /// Must be integer for an aggregation.
    /// Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal QtyRatio {
      get { return qtyRatio_; }
      set {
        qtyRatio_ = value;
      }
    }

    /// <summary>Field number for the "price_ratio" field.</summary>
    public const int PriceRatioFieldNumber = 4;
    private readonly static double PriceRatioDefaultValue = 0D;

    private double priceRatio_;
    /// <summary>
    /// Leg price calculation ratio, signed decimal, coefficient in strategy price formula before the leg contract.
    /// Same as qty_ratio if omitted.
    /// This field has precision 1e-12 and can have maximum value of 9223372.
    /// Applicable for legs of an aggregation or a multiplicative strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PriceRatio {
      get { if ((_hasBits0 & 8) != 0) { return priceRatio_; } else { return PriceRatioDefaultValue; } }
      set {
        _hasBits0 |= 8;
        priceRatio_ = value;
      }
    }
    /// <summary>Gets whether the "price_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceRatio {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "price_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceRatio() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "price_offset" field.</summary>
    public const int PriceOffsetFieldNumber = 5;
    private readonly static double PriceOffsetDefaultValue = 0D;

    private double priceOffset_;
    /// <summary>
    /// Price offset for this leg (correct price format), only specified for legs of an aggregation or 
    /// a multiplicative strategy.
    /// 0 is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PriceOffset {
      get { if ((_hasBits0 & 16) != 0) { return priceOffset_; } else { return PriceOffsetDefaultValue; } }
      set {
        _hasBits0 |= 16;
        priceOffset_ = value;
      }
    }
    /// <summary>Gets whether the "price_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceOffset {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "price_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceOffset() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "covering_price" field.</summary>
    public const int CoveringPriceFieldNumber = 6;
    private readonly static double CoveringPriceDefaultValue = 0D;

    private double coveringPrice_;
    /// <summary>
    /// Price of covering future contract. For exchange strategy only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CoveringPrice {
      get { if ((_hasBits0 & 32) != 0) { return coveringPrice_; } else { return CoveringPriceDefaultValue; } }
      set {
        _hasBits0 |= 32;
        coveringPrice_ = value;
      }
    }
    /// <summary>Gets whether the "covering_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCoveringPrice {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "covering_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCoveringPrice() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "option_delta" field.</summary>
    public const int OptionDeltaFieldNumber = 7;
    private global::Cqg.Decimal optionDelta_;
    /// <summary>
    /// Used to calculate the quantity of futures covering the option or options strategy. For exchange strategy only.
    /// Note: only qty_ratio sign means side of the leg (buy if positive or sell if negative).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal OptionDelta {
      get { return optionDelta_; }
      set {
        optionDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LegDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LegDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if (NodeIndex != other.NodeIndex) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DoubleQtyRatio, other.DoubleQtyRatio)) return false;
      if (!object.Equals(QtyRatio, other.QtyRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceRatio, other.PriceRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceOffset, other.PriceOffset)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CoveringPrice, other.CoveringPrice)) return false;
      if (!object.Equals(OptionDelta, other.OptionDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasDoubleQtyRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DoubleQtyRatio);
      if (qtyRatio_ != null) hash ^= QtyRatio.GetHashCode();
      if (HasPriceRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceRatio);
      if (HasPriceOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceOffset);
      if (HasCoveringPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CoveringPrice);
      if (optionDelta_ != null) hash ^= OptionDelta.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeIndex);
      }
      if (HasDoubleQtyRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(DoubleQtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceRatio);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(41);
        output.WriteDouble(PriceOffset);
      }
      if (HasCoveringPrice) {
        output.WriteRawTag(49);
        output.WriteDouble(CoveringPrice);
      }
      if (optionDelta_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(OptionDelta);
      }
      if (qtyRatio_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(QtyRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeIndex);
      }
      if (HasDoubleQtyRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(DoubleQtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceRatio);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(41);
        output.WriteDouble(PriceOffset);
      }
      if (HasCoveringPrice) {
        output.WriteRawTag(49);
        output.WriteDouble(CoveringPrice);
      }
      if (optionDelta_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(OptionDelta);
      }
      if (qtyRatio_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(QtyRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasDoubleQtyRatio) {
        size += 1 + 8;
      }
      if (qtyRatio_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(QtyRatio);
      }
      if (HasPriceRatio) {
        size += 1 + 8;
      }
      if (HasPriceOffset) {
        size += 1 + 8;
      }
      if (HasCoveringPrice) {
        size += 1 + 8;
      }
      if (optionDelta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OptionDelta);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LegDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasDoubleQtyRatio) {
        DoubleQtyRatio = other.DoubleQtyRatio;
      }
      if (other.qtyRatio_ != null) {
        if (qtyRatio_ == null) {
          QtyRatio = new global::Cqg.Decimal();
        }
        QtyRatio.MergeFrom(other.QtyRatio);
      }
      if (other.HasPriceRatio) {
        PriceRatio = other.PriceRatio;
      }
      if (other.HasPriceOffset) {
        PriceOffset = other.PriceOffset;
      }
      if (other.HasCoveringPrice) {
        CoveringPrice = other.CoveringPrice;
      }
      if (other.optionDelta_ != null) {
        if (optionDelta_ == null) {
          OptionDelta = new global::Cqg.Decimal();
        }
        OptionDelta.MergeFrom(other.OptionDelta);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 25: {
            DoubleQtyRatio = input.ReadDouble();
            break;
          }
          case 33: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 41: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 49: {
            CoveringPrice = input.ReadDouble();
            break;
          }
          case 58: {
            if (optionDelta_ == null) {
              OptionDelta = new global::Cqg.Decimal();
            }
            input.ReadMessage(OptionDelta);
            break;
          }
          case 66: {
            if (qtyRatio_ == null) {
              QtyRatio = new global::Cqg.Decimal();
            }
            input.ReadMessage(QtyRatio);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 25: {
            DoubleQtyRatio = input.ReadDouble();
            break;
          }
          case 33: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 41: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 49: {
            CoveringPrice = input.ReadDouble();
            break;
          }
          case 58: {
            if (optionDelta_ == null) {
              OptionDelta = new global::Cqg.Decimal();
            }
            input.ReadMessage(OptionDelta);
            break;
          }
          case 66: {
            if (qtyRatio_ == null) {
              QtyRatio = new global::Cqg.Decimal();
            }
            input.ReadMessage(QtyRatio);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a strategy nested inside a parent strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NestedStrategy : pb::IMessage<NestedStrategy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NestedStrategy> _parser = new pb::MessageParser<NestedStrategy>(() => new NestedStrategy());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NestedStrategy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NestedStrategy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NestedStrategy(NestedStrategy other) : this() {
      _hasBits0 = other._hasBits0;
      definition_ = other.definition_ != null ? other.definition_.Clone() : null;
      contractId_ = other.contractId_;
      doubleQtyRatio_ = other.doubleQtyRatio_;
      qtyRatio_ = other.qtyRatio_ != null ? other.qtyRatio_.Clone() : null;
      priceRatio_ = other.priceRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NestedStrategy Clone() {
      return new NestedStrategy(this);
    }

    /// <summary>Field number for the "definition" field.</summary>
    public const int DefinitionFieldNumber = 1;
    private global::StrategyDefinition2.StrategyDefinition definition_;
    /// <summary>
    /// Nested strategy definition.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::StrategyDefinition2.StrategyDefinition Definition {
      get { return definition_; }
      set {
        definition_ = value;
      }
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 4;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Id of the nested strategy, if it already exists on exchange.
    /// Note: can be provided by server in case of receiving contract metadata for multi-level strategy.
    /// Note: in case of receiving unknown id the contract metadata can be obtained via ContractMetadataRequest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ContractId {
      get { if ((_hasBits0 & 4) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContractId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContractId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "double_qty_ratio" field.</summary>
    public const int DoubleQtyRatioFieldNumber = 2;
    private readonly static double DoubleQtyRatioDefaultValue = 0D;

    private double doubleQtyRatio_;
    /// <summary>
    /// Note: use qty_ratio field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double DoubleQtyRatio {
      get { if ((_hasBits0 & 1) != 0) { return doubleQtyRatio_; } else { return DoubleQtyRatioDefaultValue; } }
      set {
        _hasBits0 |= 1;
        doubleQtyRatio_ = value;
      }
    }
    /// <summary>Gets whether the "double_qty_ratio" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDoubleQtyRatio {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "double_qty_ratio" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDoubleQtyRatio() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "qty_ratio" field.</summary>
    public const int QtyRatioFieldNumber = 5;
    private global::Cqg.Decimal qtyRatio_;
    /// <summary>
    /// Quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
    /// Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cqg.Decimal QtyRatio {
      get { return qtyRatio_; }
      set {
        qtyRatio_ = value;
      }
    }

    /// <summary>Field number for the "price_ratio" field.</summary>
    public const int PriceRatioFieldNumber = 3;
    private readonly static double PriceRatioDefaultValue = 0D;

    private double priceRatio_;
    /// <summary>
    /// Leg price calculation ratio, signed decimal, coefficient in strategy price formula.
    /// Same as qty_ratio if omitted.
    /// Applicable for legs of an aggregation or a multiplicative strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PriceRatio {
      get { if ((_hasBits0 & 2) != 0) { return priceRatio_; } else { return PriceRatioDefaultValue; } }
      set {
        _hasBits0 |= 2;
        priceRatio_ = value;
      }
    }
    /// <summary>Gets whether the "price_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriceRatio {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "price_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriceRatio() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NestedStrategy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NestedStrategy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Definition, other.Definition)) return false;
      if (ContractId != other.ContractId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DoubleQtyRatio, other.DoubleQtyRatio)) return false;
      if (!object.Equals(QtyRatio, other.QtyRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceRatio, other.PriceRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (definition_ != null) hash ^= Definition.GetHashCode();
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasDoubleQtyRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DoubleQtyRatio);
      if (qtyRatio_ != null) hash ^= QtyRatio.GetHashCode();
      if (HasPriceRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (definition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Definition);
      }
      if (HasDoubleQtyRatio) {
        output.WriteRawTag(17);
        output.WriteDouble(DoubleQtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceRatio);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (qtyRatio_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(QtyRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (definition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Definition);
      }
      if (HasDoubleQtyRatio) {
        output.WriteRawTag(17);
        output.WriteDouble(DoubleQtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceRatio);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (qtyRatio_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(QtyRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (definition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Definition);
      }
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasDoubleQtyRatio) {
        size += 1 + 8;
      }
      if (qtyRatio_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(QtyRatio);
      }
      if (HasPriceRatio) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NestedStrategy other) {
      if (other == null) {
        return;
      }
      if (other.definition_ != null) {
        if (definition_ == null) {
          Definition = new global::StrategyDefinition2.StrategyDefinition();
        }
        Definition.MergeFrom(other.Definition);
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasDoubleQtyRatio) {
        DoubleQtyRatio = other.DoubleQtyRatio;
      }
      if (other.qtyRatio_ != null) {
        if (qtyRatio_ == null) {
          QtyRatio = new global::Cqg.Decimal();
        }
        QtyRatio.MergeFrom(other.QtyRatio);
      }
      if (other.HasPriceRatio) {
        PriceRatio = other.PriceRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (definition_ == null) {
              Definition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(Definition);
            break;
          }
          case 17: {
            DoubleQtyRatio = input.ReadDouble();
            break;
          }
          case 25: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (qtyRatio_ == null) {
              QtyRatio = new global::Cqg.Decimal();
            }
            input.ReadMessage(QtyRatio);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (definition_ == null) {
              Definition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(Definition);
            break;
          }
          case 17: {
            DoubleQtyRatio = input.ReadDouble();
            break;
          }
          case 25: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (qtyRatio_ == null) {
              QtyRatio = new global::Cqg.Decimal();
            }
            input.ReadMessage(QtyRatio);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Child node definition within the parent strategy tree. Can be either a resolved contract (leg) or a nested strategy.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StrategyNodeDefinition : pb::IMessage<StrategyNodeDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyNodeDefinition> _parser = new pb::MessageParser<StrategyNodeDefinition>(() => new StrategyNodeDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StrategyNodeDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyNodeDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyNodeDefinition(StrategyNodeDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      nodeOperation_ = other.nodeOperation_;
      leg_ = other.leg_ != null ? other.leg_.Clone() : null;
      nestedStrategy_ = other.nestedStrategy_ != null ? other.nestedStrategy_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyNodeDefinition Clone() {
      return new StrategyNodeDefinition(this);
    }

    /// <summary>Field number for the "node_operation" field.</summary>
    public const int NodeOperationFieldNumber = 2;
    private readonly static uint NodeOperationDefaultValue = 0;

    private uint nodeOperation_;
    /// <summary>
    /// Specified node operation, one of NodeOperation enums, the default is SUM.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NodeOperation {
      get { if ((_hasBits0 & 1) != 0) { return nodeOperation_; } else { return NodeOperationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeOperation_ = value;
      }
    }
    /// <summary>Gets whether the "node_operation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeOperation {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_operation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeOperation() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "leg" field.</summary>
    public const int LegFieldNumber = 3;
    private global::StrategyDefinition2.LegDefinition leg_;
    /// <summary>
    /// Leg definition, if the node is a resolved contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::StrategyDefinition2.LegDefinition Leg {
      get { return leg_; }
      set {
        leg_ = value;
      }
    }

    /// <summary>Field number for the "nested_strategy" field.</summary>
    public const int NestedStrategyFieldNumber = 4;
    private global::StrategyDefinition2.NestedStrategy nestedStrategy_;
    /// <summary>
    /// Nested strategy, mutually exclusive with 'leg' attribute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::StrategyDefinition2.NestedStrategy NestedStrategy {
      get { return nestedStrategy_; }
      set {
        nestedStrategy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StrategyNodeDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StrategyNodeDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeOperation != other.NodeOperation) return false;
      if (!object.Equals(Leg, other.Leg)) return false;
      if (!object.Equals(NestedStrategy, other.NestedStrategy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeOperation) hash ^= NodeOperation.GetHashCode();
      if (leg_ != null) hash ^= Leg.GetHashCode();
      if (nestedStrategy_ != null) hash ^= NestedStrategy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeOperation);
      }
      if (leg_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Leg);
      }
      if (nestedStrategy_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NestedStrategy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeOperation);
      }
      if (leg_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Leg);
      }
      if (nestedStrategy_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NestedStrategy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeOperation) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeOperation);
      }
      if (leg_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Leg);
      }
      if (nestedStrategy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NestedStrategy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StrategyNodeDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeOperation) {
        NodeOperation = other.NodeOperation;
      }
      if (other.leg_ != null) {
        if (leg_ == null) {
          Leg = new global::StrategyDefinition2.LegDefinition();
        }
        Leg.MergeFrom(other.Leg);
      }
      if (other.nestedStrategy_ != null) {
        if (nestedStrategy_ == null) {
          NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
        }
        NestedStrategy.MergeFrom(other.NestedStrategy);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 16: {
            NodeOperation = input.ReadUInt32();
            break;
          }
          case 26: {
            if (leg_ == null) {
              Leg = new global::StrategyDefinition2.LegDefinition();
            }
            input.ReadMessage(Leg);
            break;
          }
          case 34: {
            if (nestedStrategy_ == null) {
              NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
            }
            input.ReadMessage(NestedStrategy);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 16: {
            NodeOperation = input.ReadUInt32();
            break;
          }
          case 26: {
            if (leg_ == null) {
              Leg = new global::StrategyDefinition2.LegDefinition();
            }
            input.ReadMessage(Leg);
            break;
          }
          case 34: {
            if (nestedStrategy_ == null) {
              NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
            }
            input.ReadMessage(NestedStrategy);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyNodeDefinition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Operation on a node of the synthetic strategy.
      /// Associating an operation with a node allows using different operations, e.g. multiplication and subtraction,
      /// without introducing intermediate StrategyDefinition entities.
      /// MUL and DIV cannot be mixed with SUM within the same StrategyDefinition.node_definition array.
      /// i.e. node1 / node2 * node3 is allowed, but node1 / node2 + node3 is not.
      /// </summary>
      public enum NodeOperation {
        /// <summary>
        /// Add the quantity and the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_SUM")] Sum = 1,
        /// <summary>
        /// Add the quantity but multiply the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_MUL")] Mul = 2,
        /// <summary>
        /// Subtract the quantity but divide the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_DIV")] Div = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Algo strategy definition.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AlgoStrategyDefinition : pb::IMessage<AlgoStrategyDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AlgoStrategyDefinition> _parser = new pb::MessageParser<AlgoStrategyDefinition>(() => new AlgoStrategyDefinition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AlgoStrategyDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinition(AlgoStrategyDefinition other) : this() {
      abbreviation_ = other.abbreviation_;
      definition_ = other.definition_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlgoStrategyDefinition Clone() {
      return new AlgoStrategyDefinition(this);
    }

    /// <summary>Field number for the "abbreviation" field.</summary>
    public const int AbbreviationFieldNumber = 1;
    private readonly static string AbbreviationDefaultValue = "";

    private string abbreviation_;
    /// <summary>
    /// Algo strategy abbreviation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Abbreviation {
      get { return abbreviation_ ?? AbbreviationDefaultValue; }
      set {
        abbreviation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "abbreviation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAbbreviation {
      get { return abbreviation_ != null; }
    }
    /// <summary>Clears the value of the "abbreviation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAbbreviation() {
      abbreviation_ = null;
    }

    /// <summary>Field number for the "definition" field.</summary>
    public const int DefinitionFieldNumber = 2;
    private readonly static string DefinitionDefaultValue = "";

    private string definition_;
    /// <summary>
    /// Algo strategy definition.
    /// Contains FIXatdl document that describes the list of parameters, their types and some UI specifics.
    /// Non-standard extensions to FIXatdl may be used.
    /// Ignore algo strategy if definition cannot be completely parsed by client.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Definition {
      get { return definition_ ?? DefinitionDefaultValue; }
      set {
        definition_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "definition" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefinition {
      get { return definition_ != null; }
    }
    /// <summary>Clears the value of the "definition" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefinition() {
      definition_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AlgoStrategyDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AlgoStrategyDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Abbreviation != other.Abbreviation) return false;
      if (Definition != other.Definition) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAbbreviation) hash ^= Abbreviation.GetHashCode();
      if (HasDefinition) hash ^= Definition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAbbreviation) {
        output.WriteRawTag(10);
        output.WriteString(Abbreviation);
      }
      if (HasDefinition) {
        output.WriteRawTag(18);
        output.WriteString(Definition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAbbreviation) {
        output.WriteRawTag(10);
        output.WriteString(Abbreviation);
      }
      if (HasDefinition) {
        output.WriteRawTag(18);
        output.WriteString(Definition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAbbreviation) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Abbreviation);
      }
      if (HasDefinition) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Definition);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AlgoStrategyDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasAbbreviation) {
        Abbreviation = other.Abbreviation;
      }
      if (other.HasDefinition) {
        Definition = other.Definition;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Abbreviation = input.ReadString();
            break;
          }
          case 18: {
            Definition = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Abbreviation = input.ReadString();
            break;
          }
          case 18: {
            Definition = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
